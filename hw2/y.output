Rules never reduced

   51 @3: /* empty */

   53 @4: /* empty */

  139 for_single_entry: funct_invoc


State 0 conflicts: 7 shift/reduce
State 11 conflicts: 7 shift/reduce
State 13 conflicts: 1 shift/reduce
State 17 conflicts: 8 shift/reduce, 7 reduce/reduce
State 18 conflicts: 7 reduce/reduce
State 25 conflicts: 8 shift/reduce
State 26 conflicts: 8 shift/reduce
State 27 conflicts: 8 reduce/reduce
State 28 conflicts: 8 reduce/reduce
State 29 conflicts: 8 reduce/reduce
State 30 conflicts: 8 reduce/reduce
State 33 conflicts: 8 shift/reduce
State 97 conflicts: 1 shift/reduce
State 134 conflicts: 1 shift/reduce
State 135 conflicts: 1 shift/reduce
State 136 conflicts: 14 shift/reduce
State 137 conflicts: 1 shift/reduce
State 138 conflicts: 1 shift/reduce
State 139 conflicts: 1 shift/reduce
State 140 conflicts: 1 shift/reduce
State 141 conflicts: 1 shift/reduce
State 142 conflicts: 1 shift/reduce
State 143 conflicts: 1 shift/reduce
State 144 conflicts: 1 shift/reduce
State 145 conflicts: 1 shift/reduce
State 146 conflicts: 1 shift/reduce
State 147 conflicts: 1 shift/reduce
State 172 conflicts: 10 shift/reduce
State 188 conflicts: 1 shift/reduce
State 207 conflicts: 3 reduce/reduce
State 232 conflicts: 1 shift/reduce
State 256 conflicts: 1 shift/reduce
State 257 conflicts: 1 shift/reduce
State 258 conflicts: 14 shift/reduce
State 259 conflicts: 1 shift/reduce
State 260 conflicts: 1 shift/reduce
State 261 conflicts: 1 shift/reduce
State 262 conflicts: 1 shift/reduce
State 263 conflicts: 1 shift/reduce
State 264 conflicts: 1 shift/reduce


Grammar

    0 $accept: program $end

    1 program: decl_and_def_list

    2 decl_and_def_list: decl_and_def_list declaration_list
    3                  | declaration_list decl_and_def_list
    4                  | definition_list
    5                  | definition_list decl_and_def_list

    6 declaration_list: declaration_list const_decl
    7                 | declaration_list var_decl
    8                 | declaration_list funct_decl
    9                 | declaration_list proc_decl
   10                 | const_decl
   11                 | var_decl
   12                 | funct_decl
   13                 | proc_decl

   14 @1: /* empty */

   15 @2: /* empty */

   16 var_decl: type @1 var_list @2 SEMICOLON

   17 type: INT
   18     | DOUBLE
   19     | FLOAT
   20     | STRING
   21     | BOOL
   22     | BOOLEAN

   23 identifier: symbol_id
   24           | symbol_id array_indice

   25 symbol_id: ID

   26 array_indice: array_indice L_BRACKET CONS_INTEGER R_BRACKET
   27             | L_BRACKET CONS_INTEGER R_BRACKET

   28 var_list: var_list COMMA var_single
   29         | var_single

   30 var_single: identifier
   31           | symbol_id ASSIGN expr
   32           | symbol_id array_indice ASSIGN init_array

   33 init_array: expr_list R_BRACE

   34 expr_list: L_BRACE nonEmpty_expr_list
   35          | L_BRACE

   36 nonEmpty_expr_list: nonEmpty_expr_list COMMA expr
   37                   | expr

   38 const_decl: CONST type const_list SEMICOLON

   39 const_list: const_init COMMA const_list
   40           | const_init

   41 const_init: symbol_id ASSIGN literal_constant

   42 literal_constant: CONS_INTEGER
   43                 | CONS_FLOAT
   44                 | CONS_SCIENTIFIC
   45                 | CONS_STRING
   46                 | CONS_BOOL

   47 funct_decl: type symbol_id L_PAREN arg_list R_PAREN SEMICOLON

   48 proc_decl: VOID symbol_id L_PAREN arg_list R_PAREN SEMICOLON

   49 definition_list: definition definition_list
   50                | definition

   51 @3: /* empty */

   52 definition: @3 type symbol_id arg_list R_PAREN compound_st

   53 @4: /* empty */

   54 definition: @4 VOID symbol_id arg_list R_PAREN compound_st

   55 arg_list: L_PAREN nonEmpty_arg_list
   56         | L_PAREN

   57 nonEmpty_arg_list: arg COMMA nonEmpty_arg_list
   58                  | arg

   59 arg: type identifier

   60 compound_st: compound_list R_BRACE

   61 compound_list: L_BRACE compound_list var_const_decl_list
   62              | L_BRACE compound_list stat_list
   63              | L_BRACE

   64 var_const_decl_list: var_const_decl_list var_decl
   65                    | var_const_decl_list const_decl
   66                    | var_decl
   67                    | const_decl

   68 stat_list: stat_list statement
   69          | statement

   70 statement: compound_st
   71          | simple_st
   72          | condition_st
   73          | while_st
   74          | for_st
   75          | jump_st
   76          | funct_invoc

   77 simple_st: var_ref ASSIGN expr SEMICOLON
   78          | PRINT var_ref SEMICOLON
   79          | PRINT expr SEMICOLON
   80          | READ var_ref SEMICOLON

   81 var_ref: symbol_id
   82        | symbol_id arr_ref_indice

   83 arr_ref_indice: arr_ref_index arr_ref_indice
   84               | arr_ref_index

   85 arr_ref_index: L_BRACKET expr R_BRACKET

   86 condition_st: IF L_PAREN bool_expr R_PAREN compound_st
   87             | IF L_PAREN bool_expr R_PAREN compound_st ELSE compound_st

   88 bool_expr: expr

   89 while_st: WHILE L_PAREN bool_expr R_PAREN compound_st
   90         | DO compound_st WHILE L_PAREN bool_expr R_PAREN SEMICOLON

   91 jump_st: RETURN expr SEMICOLON
   92        | BREAK SEMICOLON
   93        | CONTINUE SEMICOLON

   94 expr: L_PAREN expr R_PAREN
   95     | expr OR expr
   96     | expr AND expr
   97     | expr NOT expr
   98     | expr LESS expr
   99     | expr LESS_EQ expr
  100     | expr EQUAL expr
  101     | expr GREAT_EQ expr
  102     | expr GREAT expr
  103     | expr NOT_EQ expr
  104     | expr PLUS expr
  105     | expr MINUS expr
  106     | expr MULTIPLY expr
  107     | expr DIVIDE expr
  108     | expr MOD expr
  109     | MINUS expr
  110     | literal_constant
  111     | var_ref
  112     | funct_invoc

  113 for_st: FOR for_init for_control for_incre R_PAREN compound_st

  114 for_init: L_PAREN nonEmpty_for_init
  115         | L_PAREN

  116 nonEmpty_for_init: nonEmpty_for_init COMMA for_single_entry
  117                  | for_single_entry

  118 for_incre: SEMICOLON nonEmpty_for_incre
  119          | SEMICOLON

  120 nonEmpty_for_incre: nonEmpty_for_incre COMMA for_single_entry
  121                   | for_single_entry

  122 for_control: SEMICOLON nonEmpty_for_control
  123            | SEMICOLON

  124 nonEmpty_for_control: nonEmpty_for_control COMMA for_control_entry
  125                     | for_control_entry

  126 for_control_entry: expr OR expr
  127                  | expr AND expr
  128                  | expr NOT expr
  129                  | expr LESS expr
  130                  | expr LESS_EQ expr
  131                  | expr EQUAL expr
  132                  | expr GREAT_EQ expr
  133                  | expr GREAT expr
  134                  | expr NOT_EQ expr
  135                  | symbol_id ASSIGN expr
  136                  | symbol_id array_indice ASSIGN init_array

  137 for_single_entry: symbol_id ASSIGN expr
  138                 | symbol_id array_indice ASSIGN init_array
  139                 | funct_invoc
  140                 | expr

  141 funct_invoc: symbol_id funct_invoc_list R_PAREN SEMICOLON

  142 funct_invoc_list: L_PAREN
  143                 | L_PAREN nonEmpty_funct_invoc_list COMMA expr

  144 nonEmpty_funct_invoc_list: nonEmpty_funct_invoc_list COMMA expr
  145                          | expr


Terminals, with rules where they appear

$end (0) 0
error (256)
VOID (258) 48 54
CONST (259) 38
STRING (260) 20
DOUBLE (261) 18
FLOAT (262) 19
BOOL (263) 21
INT (264) 17
BOOLEAN (265) 22
L_PAREN (266) 47 48 55 56 86 87 89 90 94 114 115 142 143
R_PAREN (267) 47 48 52 54 86 87 89 90 94 113 141
L_BRACKET (268) 26 27 85
R_BRACKET (269) 26 27 85
L_BRACE (270) 34 35 61 62 63
R_BRACE (271) 33 60
OR (272) 95 126
AND (273) 96 127
NOT (274) 97 128
NOT_EQ (275) 103 134
GREAT (276) 102 133
GREAT_EQ (277) 101 132
EQUAL (278) 100 131
LESS_EQ (279) 99 130
LESS (280) 98 129
MINUS (281) 105 109
PLUS (282) 104
MOD (283) 108
DIVIDE (284) 107
MULTIPLY (285) 106
ASSIGN (286) 31 32 41 77 135 136 137 138
WHILE (287) 89 90
DO (288) 90
IF (289) 86 87
ELSE (290) 87
FOR (291) 113
PRINT (292) 78 79
READ (293) 80
CONTINUE (294) 93
BREAK (295) 92
RETURN (296) 91
ID (297) 25
SEMICOLON (298) 16 38 47 48 77 78 79 80 90 91 92 93 118 119 122 123
    141
COMMA (299) 28 36 39 57 116 120 124 143 144
CONS_INTEGER (300) 26 27 42
CONS_FLOAT (301) 43
CONS_SCIENTIFIC (302) 44
CONS_STRING (303) 45
CONS_BOOL (304) 46


Nonterminals, with rules where they appear

$accept (50)
    on left: 0
program (51)
    on left: 1, on right: 0
decl_and_def_list (52)
    on left: 2 3 4 5, on right: 1 2 3 5
declaration_list (53)
    on left: 6 7 8 9 10 11 12 13, on right: 2 3 6 7 8 9
var_decl (54)
    on left: 16, on right: 7 11 64 66
@1 (55)
    on left: 14, on right: 16
@2 (56)
    on left: 15, on right: 16
type (57)
    on left: 17 18 19 20 21 22, on right: 16 38 47 52 59
identifier (58)
    on left: 23 24, on right: 30 59
symbol_id (59)
    on left: 25, on right: 23 24 31 32 41 47 48 52 54 81 82 135 136
    137 138 141
array_indice (60)
    on left: 26 27, on right: 24 26 32 136 138
var_list (61)
    on left: 28 29, on right: 16 28
var_single (62)
    on left: 30 31 32, on right: 28 29
init_array (63)
    on left: 33, on right: 32 136 138
expr_list (64)
    on left: 34 35, on right: 33
nonEmpty_expr_list (65)
    on left: 36 37, on right: 34 36
const_decl (66)
    on left: 38, on right: 6 10 65 67
const_list (67)
    on left: 39 40, on right: 38 39
const_init (68)
    on left: 41, on right: 39 40
literal_constant (69)
    on left: 42 43 44 45 46, on right: 41 110
funct_decl (70)
    on left: 47, on right: 8 12
proc_decl (71)
    on left: 48, on right: 9 13
definition_list (72)
    on left: 49 50, on right: 4 5 49
definition (73)
    on left: 52 54, on right: 49 50
@3 (74)
    on left: 51, on right: 52
@4 (75)
    on left: 53, on right: 54
arg_list (76)
    on left: 55 56, on right: 47 48 52 54
nonEmpty_arg_list (77)
    on left: 57 58, on right: 55 57
arg (78)
    on left: 59, on right: 57 58
compound_st (79)
    on left: 60, on right: 52 54 70 86 87 89 90 113
compound_list (80)
    on left: 61 62 63, on right: 60 61 62
var_const_decl_list (81)
    on left: 64 65 66 67, on right: 61 64 65
stat_list (82)
    on left: 68 69, on right: 62 68
statement (83)
    on left: 70 71 72 73 74 75 76, on right: 68 69
simple_st (84)
    on left: 77 78 79 80, on right: 71
var_ref (85)
    on left: 81 82, on right: 77 78 80 111
arr_ref_indice (86)
    on left: 83 84, on right: 82 83
arr_ref_index (87)
    on left: 85, on right: 83 84
condition_st (88)
    on left: 86 87, on right: 72
bool_expr (89)
    on left: 88, on right: 86 87 89 90
while_st (90)
    on left: 89 90, on right: 73
jump_st (91)
    on left: 91 92 93, on right: 75
expr (92)
    on left: 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108
    109 110 111 112, on right: 31 36 37 77 79 85 88 91 94 95 96 97
    98 99 100 101 102 103 104 105 106 107 108 109 126 127 128 129 130
    131 132 133 134 135 137 140 143 144 145
for_st (93)
    on left: 113, on right: 74
for_init (94)
    on left: 114 115, on right: 113
nonEmpty_for_init (95)
    on left: 116 117, on right: 114 116
for_incre (96)
    on left: 118 119, on right: 113
nonEmpty_for_incre (97)
    on left: 120 121, on right: 118 120
for_control (98)
    on left: 122 123, on right: 113
nonEmpty_for_control (99)
    on left: 124 125, on right: 122 124
for_control_entry (100)
    on left: 126 127 128 129 130 131 132 133 134 135 136,
    on right: 124 125
for_single_entry (101)
    on left: 137 138 139 140, on right: 116 117 120 121
funct_invoc (102)
    on left: 141, on right: 76 112 139
funct_invoc_list (103)
    on left: 142 143, on right: 141
nonEmpty_funct_invoc_list (104)
    on left: 144 145, on right: 143 144


state 0

    0 $accept: . program $end

    VOID     shift, and go to state 1
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    VOID     [reduce using rule 53 (@4)]
    STRING   [reduce using rule 51 (@3)]
    DOUBLE   [reduce using rule 51 (@3)]
    FLOAT    [reduce using rule 51 (@3)]
    BOOL     [reduce using rule 51 (@3)]
    INT      [reduce using rule 51 (@3)]
    BOOLEAN  [reduce using rule 51 (@3)]

    program            go to state 9
    decl_and_def_list  go to state 10
    declaration_list   go to state 11
    var_decl           go to state 12
    type               go to state 13
    const_decl         go to state 14
    funct_decl         go to state 15
    proc_decl          go to state 16
    definition_list    go to state 17
    definition         go to state 18
    @3                 go to state 19
    @4                 go to state 20


state 1

   48 proc_decl: VOID . symbol_id L_PAREN arg_list R_PAREN SEMICOLON

    ID  shift, and go to state 21

    symbol_id  go to state 22


state 2

   38 const_decl: CONST . type const_list SEMICOLON

    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    type  go to state 23


state 3

   20 type: STRING .

    $default  reduce using rule 20 (type)


state 4

   18 type: DOUBLE .

    $default  reduce using rule 18 (type)


state 5

   19 type: FLOAT .

    $default  reduce using rule 19 (type)


state 6

   21 type: BOOL .

    $default  reduce using rule 21 (type)


state 7

   17 type: INT .

    $default  reduce using rule 17 (type)


state 8

   22 type: BOOLEAN .

    $default  reduce using rule 22 (type)


state 9

    0 $accept: program . $end

    $end  shift, and go to state 24


state 10

    1 program: decl_and_def_list .
    2 decl_and_def_list: decl_and_def_list . declaration_list

    VOID     shift, and go to state 1
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    $default  reduce using rule 1 (program)

    declaration_list  go to state 25
    var_decl          go to state 12
    type              go to state 13
    const_decl        go to state 14
    funct_decl        go to state 15
    proc_decl         go to state 16


state 11

    3 decl_and_def_list: declaration_list . decl_and_def_list
    6 declaration_list: declaration_list . const_decl
    7                 | declaration_list . var_decl
    8                 | declaration_list . funct_decl
    9                 | declaration_list . proc_decl

    VOID     shift, and go to state 1
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    VOID     [reduce using rule 53 (@4)]
    STRING   [reduce using rule 51 (@3)]
    DOUBLE   [reduce using rule 51 (@3)]
    FLOAT    [reduce using rule 51 (@3)]
    BOOL     [reduce using rule 51 (@3)]
    INT      [reduce using rule 51 (@3)]
    BOOLEAN  [reduce using rule 51 (@3)]

    decl_and_def_list  go to state 26
    declaration_list   go to state 11
    var_decl           go to state 27
    type               go to state 13
    const_decl         go to state 28
    funct_decl         go to state 29
    proc_decl          go to state 30
    definition_list    go to state 17
    definition         go to state 18
    @3                 go to state 19
    @4                 go to state 20


state 12

   11 declaration_list: var_decl .

    $default  reduce using rule 11 (declaration_list)


state 13

   16 var_decl: type . @1 var_list @2 SEMICOLON
   47 funct_decl: type . symbol_id L_PAREN arg_list R_PAREN SEMICOLON

    ID  shift, and go to state 21

    ID  [reduce using rule 14 (@1)]

    @1         go to state 31
    symbol_id  go to state 32


state 14

   10 declaration_list: const_decl .

    $default  reduce using rule 10 (declaration_list)


state 15

   12 declaration_list: funct_decl .

    $default  reduce using rule 12 (declaration_list)


state 16

   13 declaration_list: proc_decl .

    $default  reduce using rule 13 (declaration_list)


state 17

    4 decl_and_def_list: definition_list .
    5                  | definition_list . decl_and_def_list

    VOID     shift, and go to state 1
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    VOID      [reduce using rule 4 (decl_and_def_list)]
    VOID      [reduce using rule 53 (@4)]
    CONST     [reduce using rule 4 (decl_and_def_list)]
    STRING    [reduce using rule 4 (decl_and_def_list)]
    STRING    [reduce using rule 51 (@3)]
    DOUBLE    [reduce using rule 4 (decl_and_def_list)]
    DOUBLE    [reduce using rule 51 (@3)]
    FLOAT     [reduce using rule 4 (decl_and_def_list)]
    FLOAT     [reduce using rule 51 (@3)]
    BOOL      [reduce using rule 4 (decl_and_def_list)]
    BOOL      [reduce using rule 51 (@3)]
    INT       [reduce using rule 4 (decl_and_def_list)]
    INT       [reduce using rule 51 (@3)]
    BOOLEAN   [reduce using rule 4 (decl_and_def_list)]
    BOOLEAN   [reduce using rule 51 (@3)]
    $default  reduce using rule 4 (decl_and_def_list)

    decl_and_def_list  go to state 33
    declaration_list   go to state 11
    var_decl           go to state 12
    type               go to state 13
    const_decl         go to state 14
    funct_decl         go to state 15
    proc_decl          go to state 16
    definition_list    go to state 17
    definition         go to state 18
    @3                 go to state 19
    @4                 go to state 20


state 18

   49 definition_list: definition . definition_list
   50                | definition .

    VOID      reduce using rule 50 (definition_list)
    VOID      [reduce using rule 53 (@4)]
    STRING    reduce using rule 50 (definition_list)
    STRING    [reduce using rule 51 (@3)]
    DOUBLE    reduce using rule 50 (definition_list)
    DOUBLE    [reduce using rule 51 (@3)]
    FLOAT     reduce using rule 50 (definition_list)
    FLOAT     [reduce using rule 51 (@3)]
    BOOL      reduce using rule 50 (definition_list)
    BOOL      [reduce using rule 51 (@3)]
    INT       reduce using rule 50 (definition_list)
    INT       [reduce using rule 51 (@3)]
    BOOLEAN   reduce using rule 50 (definition_list)
    BOOLEAN   [reduce using rule 51 (@3)]
    $default  reduce using rule 50 (definition_list)

    definition_list  go to state 34
    definition       go to state 18
    @3               go to state 19
    @4               go to state 20


state 19

   52 definition: @3 . type symbol_id arg_list R_PAREN compound_st

    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    type  go to state 35


state 20

   54 definition: @4 . VOID symbol_id arg_list R_PAREN compound_st

    VOID  shift, and go to state 36


state 21

   25 symbol_id: ID .

    $default  reduce using rule 25 (symbol_id)


state 22

   48 proc_decl: VOID symbol_id . L_PAREN arg_list R_PAREN SEMICOLON

    L_PAREN  shift, and go to state 37


state 23

   38 const_decl: CONST type . const_list SEMICOLON

    ID  shift, and go to state 21

    symbol_id   go to state 38
    const_list  go to state 39
    const_init  go to state 40


state 24

    0 $accept: program $end .

    $default  accept


state 25

    2 decl_and_def_list: decl_and_def_list declaration_list .
    6 declaration_list: declaration_list . const_decl
    7                 | declaration_list . var_decl
    8                 | declaration_list . funct_decl
    9                 | declaration_list . proc_decl

    VOID     shift, and go to state 1
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    VOID      [reduce using rule 2 (decl_and_def_list)]
    CONST     [reduce using rule 2 (decl_and_def_list)]
    STRING    [reduce using rule 2 (decl_and_def_list)]
    DOUBLE    [reduce using rule 2 (decl_and_def_list)]
    FLOAT     [reduce using rule 2 (decl_and_def_list)]
    BOOL      [reduce using rule 2 (decl_and_def_list)]
    INT       [reduce using rule 2 (decl_and_def_list)]
    BOOLEAN   [reduce using rule 2 (decl_and_def_list)]
    $default  reduce using rule 2 (decl_and_def_list)

    var_decl    go to state 41
    type        go to state 13
    const_decl  go to state 42
    funct_decl  go to state 43
    proc_decl   go to state 44


state 26

    2 decl_and_def_list: decl_and_def_list . declaration_list
    3                  | declaration_list decl_and_def_list .

    VOID     shift, and go to state 1
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    VOID      [reduce using rule 3 (decl_and_def_list)]
    CONST     [reduce using rule 3 (decl_and_def_list)]
    STRING    [reduce using rule 3 (decl_and_def_list)]
    DOUBLE    [reduce using rule 3 (decl_and_def_list)]
    FLOAT     [reduce using rule 3 (decl_and_def_list)]
    BOOL      [reduce using rule 3 (decl_and_def_list)]
    INT       [reduce using rule 3 (decl_and_def_list)]
    BOOLEAN   [reduce using rule 3 (decl_and_def_list)]
    $default  reduce using rule 3 (decl_and_def_list)

    declaration_list  go to state 25
    var_decl          go to state 12
    type              go to state 13
    const_decl        go to state 14
    funct_decl        go to state 15
    proc_decl         go to state 16


state 27

    7 declaration_list: declaration_list var_decl .
   11                 | var_decl .

    VOID      reduce using rule 7 (declaration_list)
    VOID      [reduce using rule 11 (declaration_list)]
    CONST     reduce using rule 7 (declaration_list)
    CONST     [reduce using rule 11 (declaration_list)]
    STRING    reduce using rule 7 (declaration_list)
    STRING    [reduce using rule 11 (declaration_list)]
    DOUBLE    reduce using rule 7 (declaration_list)
    DOUBLE    [reduce using rule 11 (declaration_list)]
    FLOAT     reduce using rule 7 (declaration_list)
    FLOAT     [reduce using rule 11 (declaration_list)]
    BOOL      reduce using rule 7 (declaration_list)
    BOOL      [reduce using rule 11 (declaration_list)]
    INT       reduce using rule 7 (declaration_list)
    INT       [reduce using rule 11 (declaration_list)]
    BOOLEAN   reduce using rule 7 (declaration_list)
    BOOLEAN   [reduce using rule 11 (declaration_list)]
    $default  reduce using rule 7 (declaration_list)


state 28

    6 declaration_list: declaration_list const_decl .
   10                 | const_decl .

    VOID      reduce using rule 6 (declaration_list)
    VOID      [reduce using rule 10 (declaration_list)]
    CONST     reduce using rule 6 (declaration_list)
    CONST     [reduce using rule 10 (declaration_list)]
    STRING    reduce using rule 6 (declaration_list)
    STRING    [reduce using rule 10 (declaration_list)]
    DOUBLE    reduce using rule 6 (declaration_list)
    DOUBLE    [reduce using rule 10 (declaration_list)]
    FLOAT     reduce using rule 6 (declaration_list)
    FLOAT     [reduce using rule 10 (declaration_list)]
    BOOL      reduce using rule 6 (declaration_list)
    BOOL      [reduce using rule 10 (declaration_list)]
    INT       reduce using rule 6 (declaration_list)
    INT       [reduce using rule 10 (declaration_list)]
    BOOLEAN   reduce using rule 6 (declaration_list)
    BOOLEAN   [reduce using rule 10 (declaration_list)]
    $default  reduce using rule 6 (declaration_list)


state 29

    8 declaration_list: declaration_list funct_decl .
   12                 | funct_decl .

    VOID      reduce using rule 8 (declaration_list)
    VOID      [reduce using rule 12 (declaration_list)]
    CONST     reduce using rule 8 (declaration_list)
    CONST     [reduce using rule 12 (declaration_list)]
    STRING    reduce using rule 8 (declaration_list)
    STRING    [reduce using rule 12 (declaration_list)]
    DOUBLE    reduce using rule 8 (declaration_list)
    DOUBLE    [reduce using rule 12 (declaration_list)]
    FLOAT     reduce using rule 8 (declaration_list)
    FLOAT     [reduce using rule 12 (declaration_list)]
    BOOL      reduce using rule 8 (declaration_list)
    BOOL      [reduce using rule 12 (declaration_list)]
    INT       reduce using rule 8 (declaration_list)
    INT       [reduce using rule 12 (declaration_list)]
    BOOLEAN   reduce using rule 8 (declaration_list)
    BOOLEAN   [reduce using rule 12 (declaration_list)]
    $default  reduce using rule 8 (declaration_list)


state 30

    9 declaration_list: declaration_list proc_decl .
   13                 | proc_decl .

    VOID      reduce using rule 9 (declaration_list)
    VOID      [reduce using rule 13 (declaration_list)]
    CONST     reduce using rule 9 (declaration_list)
    CONST     [reduce using rule 13 (declaration_list)]
    STRING    reduce using rule 9 (declaration_list)
    STRING    [reduce using rule 13 (declaration_list)]
    DOUBLE    reduce using rule 9 (declaration_list)
    DOUBLE    [reduce using rule 13 (declaration_list)]
    FLOAT     reduce using rule 9 (declaration_list)
    FLOAT     [reduce using rule 13 (declaration_list)]
    BOOL      reduce using rule 9 (declaration_list)
    BOOL      [reduce using rule 13 (declaration_list)]
    INT       reduce using rule 9 (declaration_list)
    INT       [reduce using rule 13 (declaration_list)]
    BOOLEAN   reduce using rule 9 (declaration_list)
    BOOLEAN   [reduce using rule 13 (declaration_list)]
    $default  reduce using rule 9 (declaration_list)


state 31

   16 var_decl: type @1 . var_list @2 SEMICOLON

    ID  shift, and go to state 21

    identifier  go to state 45
    symbol_id   go to state 46
    var_list    go to state 47
    var_single  go to state 48


state 32

   47 funct_decl: type symbol_id . L_PAREN arg_list R_PAREN SEMICOLON

    L_PAREN  shift, and go to state 49


state 33

    2 decl_and_def_list: decl_and_def_list . declaration_list
    5                  | definition_list decl_and_def_list .

    VOID     shift, and go to state 1
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    VOID      [reduce using rule 5 (decl_and_def_list)]
    CONST     [reduce using rule 5 (decl_and_def_list)]
    STRING    [reduce using rule 5 (decl_and_def_list)]
    DOUBLE    [reduce using rule 5 (decl_and_def_list)]
    FLOAT     [reduce using rule 5 (decl_and_def_list)]
    BOOL      [reduce using rule 5 (decl_and_def_list)]
    INT       [reduce using rule 5 (decl_and_def_list)]
    BOOLEAN   [reduce using rule 5 (decl_and_def_list)]
    $default  reduce using rule 5 (decl_and_def_list)

    declaration_list  go to state 25
    var_decl          go to state 12
    type              go to state 13
    const_decl        go to state 14
    funct_decl        go to state 15
    proc_decl         go to state 16


state 34

   49 definition_list: definition definition_list .

    $default  reduce using rule 49 (definition_list)


state 35

   52 definition: @3 type . symbol_id arg_list R_PAREN compound_st

    ID  shift, and go to state 21

    symbol_id  go to state 50


state 36

   54 definition: @4 VOID . symbol_id arg_list R_PAREN compound_st

    ID  shift, and go to state 21

    symbol_id  go to state 51


state 37

   48 proc_decl: VOID symbol_id L_PAREN . arg_list R_PAREN SEMICOLON

    L_PAREN  shift, and go to state 52

    arg_list  go to state 53


state 38

   41 const_init: symbol_id . ASSIGN literal_constant

    ASSIGN  shift, and go to state 54


state 39

   38 const_decl: CONST type const_list . SEMICOLON

    SEMICOLON  shift, and go to state 55


state 40

   39 const_list: const_init . COMMA const_list
   40           | const_init .

    COMMA  shift, and go to state 56

    $default  reduce using rule 40 (const_list)


state 41

    7 declaration_list: declaration_list var_decl .

    $default  reduce using rule 7 (declaration_list)


state 42

    6 declaration_list: declaration_list const_decl .

    $default  reduce using rule 6 (declaration_list)


state 43

    8 declaration_list: declaration_list funct_decl .

    $default  reduce using rule 8 (declaration_list)


state 44

    9 declaration_list: declaration_list proc_decl .

    $default  reduce using rule 9 (declaration_list)


state 45

   30 var_single: identifier .

    $default  reduce using rule 30 (var_single)


state 46

   23 identifier: symbol_id .
   24           | symbol_id . array_indice
   31 var_single: symbol_id . ASSIGN expr
   32           | symbol_id . array_indice ASSIGN init_array

    L_BRACKET  shift, and go to state 57
    ASSIGN     shift, and go to state 58

    $default  reduce using rule 23 (identifier)

    array_indice  go to state 59


state 47

   16 var_decl: type @1 var_list . @2 SEMICOLON
   28 var_list: var_list . COMMA var_single

    COMMA  shift, and go to state 60

    $default  reduce using rule 15 (@2)

    @2  go to state 61


state 48

   29 var_list: var_single .

    $default  reduce using rule 29 (var_list)


state 49

   47 funct_decl: type symbol_id L_PAREN . arg_list R_PAREN SEMICOLON

    L_PAREN  shift, and go to state 52

    arg_list  go to state 62


state 50

   52 definition: @3 type symbol_id . arg_list R_PAREN compound_st

    L_PAREN  shift, and go to state 52

    arg_list  go to state 63


state 51

   54 definition: @4 VOID symbol_id . arg_list R_PAREN compound_st

    L_PAREN  shift, and go to state 52

    arg_list  go to state 64


state 52

   55 arg_list: L_PAREN . nonEmpty_arg_list
   56         | L_PAREN .

    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    $default  reduce using rule 56 (arg_list)

    type               go to state 65
    nonEmpty_arg_list  go to state 66
    arg                go to state 67


state 53

   48 proc_decl: VOID symbol_id L_PAREN arg_list . R_PAREN SEMICOLON

    R_PAREN  shift, and go to state 68


state 54

   41 const_init: symbol_id ASSIGN . literal_constant

    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    literal_constant  go to state 74


state 55

   38 const_decl: CONST type const_list SEMICOLON .

    $default  reduce using rule 38 (const_decl)


state 56

   39 const_list: const_init COMMA . const_list

    ID  shift, and go to state 21

    symbol_id   go to state 38
    const_list  go to state 75
    const_init  go to state 40


state 57

   27 array_indice: L_BRACKET . CONS_INTEGER R_BRACKET

    CONS_INTEGER  shift, and go to state 76


state 58

   31 var_single: symbol_id ASSIGN . expr

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 79
    literal_constant  go to state 80
    var_ref           go to state 81
    expr              go to state 82
    funct_invoc       go to state 83


state 59

   24 identifier: symbol_id array_indice .
   26 array_indice: array_indice . L_BRACKET CONS_INTEGER R_BRACKET
   32 var_single: symbol_id array_indice . ASSIGN init_array

    L_BRACKET  shift, and go to state 84
    ASSIGN     shift, and go to state 85

    $default  reduce using rule 24 (identifier)


state 60

   28 var_list: var_list COMMA . var_single

    ID  shift, and go to state 21

    identifier  go to state 45
    symbol_id   go to state 46
    var_single  go to state 86


state 61

   16 var_decl: type @1 var_list @2 . SEMICOLON

    SEMICOLON  shift, and go to state 87


state 62

   47 funct_decl: type symbol_id L_PAREN arg_list . R_PAREN SEMICOLON

    R_PAREN  shift, and go to state 88


state 63

   52 definition: @3 type symbol_id arg_list . R_PAREN compound_st

    R_PAREN  shift, and go to state 89


state 64

   54 definition: @4 VOID symbol_id arg_list . R_PAREN compound_st

    R_PAREN  shift, and go to state 90


state 65

   59 arg: type . identifier

    ID  shift, and go to state 21

    identifier  go to state 91
    symbol_id   go to state 92


state 66

   55 arg_list: L_PAREN nonEmpty_arg_list .

    $default  reduce using rule 55 (arg_list)


state 67

   57 nonEmpty_arg_list: arg . COMMA nonEmpty_arg_list
   58                  | arg .

    COMMA  shift, and go to state 93

    $default  reduce using rule 58 (nonEmpty_arg_list)


state 68

   48 proc_decl: VOID symbol_id L_PAREN arg_list R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 94


state 69

   42 literal_constant: CONS_INTEGER .

    $default  reduce using rule 42 (literal_constant)


state 70

   43 literal_constant: CONS_FLOAT .

    $default  reduce using rule 43 (literal_constant)


state 71

   44 literal_constant: CONS_SCIENTIFIC .

    $default  reduce using rule 44 (literal_constant)


state 72

   45 literal_constant: CONS_STRING .

    $default  reduce using rule 45 (literal_constant)


state 73

   46 literal_constant: CONS_BOOL .

    $default  reduce using rule 46 (literal_constant)


state 74

   41 const_init: symbol_id ASSIGN literal_constant .

    $default  reduce using rule 41 (const_init)


state 75

   39 const_list: const_init COMMA const_list .

    $default  reduce using rule 39 (const_list)


state 76

   27 array_indice: L_BRACKET CONS_INTEGER . R_BRACKET

    R_BRACKET  shift, and go to state 95


state 77

   94 expr: L_PAREN . expr R_PAREN

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 79
    literal_constant  go to state 80
    var_ref           go to state 81
    expr              go to state 96
    funct_invoc       go to state 83


state 78

  109 expr: MINUS . expr

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 79
    literal_constant  go to state 80
    var_ref           go to state 81
    expr              go to state 97
    funct_invoc       go to state 83


state 79

   81 var_ref: symbol_id .
   82        | symbol_id . arr_ref_indice
  141 funct_invoc: symbol_id . funct_invoc_list R_PAREN SEMICOLON

    L_PAREN    shift, and go to state 98
    L_BRACKET  shift, and go to state 99

    $default  reduce using rule 81 (var_ref)

    arr_ref_indice    go to state 100
    arr_ref_index     go to state 101
    funct_invoc_list  go to state 102


state 80

  110 expr: literal_constant .

    $default  reduce using rule 110 (expr)


state 81

  111 expr: var_ref .

    $default  reduce using rule 111 (expr)


state 82

   31 var_single: symbol_id ASSIGN expr .
   95 expr: expr . OR expr
   96     | expr . AND expr
   97     | expr . NOT expr
   98     | expr . LESS expr
   99     | expr . LESS_EQ expr
  100     | expr . EQUAL expr
  101     | expr . GREAT_EQ expr
  102     | expr . GREAT expr
  103     | expr . NOT_EQ expr
  104     | expr . PLUS expr
  105     | expr . MINUS expr
  106     | expr . MULTIPLY expr
  107     | expr . DIVIDE expr
  108     | expr . MOD expr

    OR        shift, and go to state 103
    AND       shift, and go to state 104
    NOT       shift, and go to state 105
    NOT_EQ    shift, and go to state 106
    GREAT     shift, and go to state 107
    GREAT_EQ  shift, and go to state 108
    EQUAL     shift, and go to state 109
    LESS_EQ   shift, and go to state 110
    LESS      shift, and go to state 111
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    $default  reduce using rule 31 (var_single)


state 83

  112 expr: funct_invoc .

    $default  reduce using rule 112 (expr)


state 84

   26 array_indice: array_indice L_BRACKET . CONS_INTEGER R_BRACKET

    CONS_INTEGER  shift, and go to state 117


state 85

   32 var_single: symbol_id array_indice ASSIGN . init_array

    L_BRACE  shift, and go to state 118

    init_array  go to state 119
    expr_list   go to state 120


state 86

   28 var_list: var_list COMMA var_single .

    $default  reduce using rule 28 (var_list)


state 87

   16 var_decl: type @1 var_list @2 SEMICOLON .

    $default  reduce using rule 16 (var_decl)


state 88

   47 funct_decl: type symbol_id L_PAREN arg_list R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 121


state 89

   52 definition: @3 type symbol_id arg_list R_PAREN . compound_st

    L_BRACE  shift, and go to state 122

    compound_st    go to state 123
    compound_list  go to state 124


state 90

   54 definition: @4 VOID symbol_id arg_list R_PAREN . compound_st

    L_BRACE  shift, and go to state 122

    compound_st    go to state 125
    compound_list  go to state 124


state 91

   59 arg: type identifier .

    $default  reduce using rule 59 (arg)


state 92

   23 identifier: symbol_id .
   24           | symbol_id . array_indice

    L_BRACKET  shift, and go to state 57

    $default  reduce using rule 23 (identifier)

    array_indice  go to state 126


state 93

   57 nonEmpty_arg_list: arg COMMA . nonEmpty_arg_list

    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    type               go to state 65
    nonEmpty_arg_list  go to state 127
    arg                go to state 67


state 94

   48 proc_decl: VOID symbol_id L_PAREN arg_list R_PAREN SEMICOLON .

    $default  reduce using rule 48 (proc_decl)


state 95

   27 array_indice: L_BRACKET CONS_INTEGER R_BRACKET .

    $default  reduce using rule 27 (array_indice)


state 96

   94 expr: L_PAREN expr . R_PAREN
   95     | expr . OR expr
   96     | expr . AND expr
   97     | expr . NOT expr
   98     | expr . LESS expr
   99     | expr . LESS_EQ expr
  100     | expr . EQUAL expr
  101     | expr . GREAT_EQ expr
  102     | expr . GREAT expr
  103     | expr . NOT_EQ expr
  104     | expr . PLUS expr
  105     | expr . MINUS expr
  106     | expr . MULTIPLY expr
  107     | expr . DIVIDE expr
  108     | expr . MOD expr

    R_PAREN   shift, and go to state 128
    OR        shift, and go to state 103
    AND       shift, and go to state 104
    NOT       shift, and go to state 105
    NOT_EQ    shift, and go to state 106
    GREAT     shift, and go to state 107
    GREAT_EQ  shift, and go to state 108
    EQUAL     shift, and go to state 109
    LESS_EQ   shift, and go to state 110
    LESS      shift, and go to state 111
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116


state 97

   95 expr: expr . OR expr
   96     | expr . AND expr
   97     | expr . NOT expr
   98     | expr . LESS expr
   99     | expr . LESS_EQ expr
  100     | expr . EQUAL expr
  101     | expr . GREAT_EQ expr
  102     | expr . GREAT expr
  103     | expr . NOT_EQ expr
  104     | expr . PLUS expr
  105     | expr . MINUS expr
  106     | expr . MULTIPLY expr
  107     | expr . DIVIDE expr
  108     | expr . MOD expr
  109     | MINUS expr .

    NOT  shift, and go to state 105

    NOT       [reduce using rule 109 (expr)]
    $default  reduce using rule 109 (expr)


state 98

  142 funct_invoc_list: L_PAREN .
  143                 | L_PAREN . nonEmpty_funct_invoc_list COMMA expr

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    $default  reduce using rule 142 (funct_invoc_list)

    symbol_id                  go to state 79
    literal_constant           go to state 80
    var_ref                    go to state 81
    expr                       go to state 129
    funct_invoc                go to state 83
    nonEmpty_funct_invoc_list  go to state 130


state 99

   85 arr_ref_index: L_BRACKET . expr R_BRACKET

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 79
    literal_constant  go to state 80
    var_ref           go to state 81
    expr              go to state 131
    funct_invoc       go to state 83


state 100

   82 var_ref: symbol_id arr_ref_indice .

    $default  reduce using rule 82 (var_ref)


state 101

   83 arr_ref_indice: arr_ref_index . arr_ref_indice
   84               | arr_ref_index .

    L_BRACKET  shift, and go to state 99

    $default  reduce using rule 84 (arr_ref_indice)

    arr_ref_indice  go to state 132
    arr_ref_index   go to state 101


state 102

  141 funct_invoc: symbol_id funct_invoc_list . R_PAREN SEMICOLON

    R_PAREN  shift, and go to state 133


state 103

   95 expr: expr OR . expr

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 79
    literal_constant  go to state 80
    var_ref           go to state 81
    expr              go to state 134
    funct_invoc       go to state 83


state 104

   96 expr: expr AND . expr

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 79
    literal_constant  go to state 80
    var_ref           go to state 81
    expr              go to state 135
    funct_invoc       go to state 83


state 105

   97 expr: expr NOT . expr

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 79
    literal_constant  go to state 80
    var_ref           go to state 81
    expr              go to state 136
    funct_invoc       go to state 83


state 106

  103 expr: expr NOT_EQ . expr

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 79
    literal_constant  go to state 80
    var_ref           go to state 81
    expr              go to state 137
    funct_invoc       go to state 83


state 107

  102 expr: expr GREAT . expr

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 79
    literal_constant  go to state 80
    var_ref           go to state 81
    expr              go to state 138
    funct_invoc       go to state 83


state 108

  101 expr: expr GREAT_EQ . expr

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 79
    literal_constant  go to state 80
    var_ref           go to state 81
    expr              go to state 139
    funct_invoc       go to state 83


state 109

  100 expr: expr EQUAL . expr

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 79
    literal_constant  go to state 80
    var_ref           go to state 81
    expr              go to state 140
    funct_invoc       go to state 83


state 110

   99 expr: expr LESS_EQ . expr

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 79
    literal_constant  go to state 80
    var_ref           go to state 81
    expr              go to state 141
    funct_invoc       go to state 83


state 111

   98 expr: expr LESS . expr

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 79
    literal_constant  go to state 80
    var_ref           go to state 81
    expr              go to state 142
    funct_invoc       go to state 83


state 112

  105 expr: expr MINUS . expr

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 79
    literal_constant  go to state 80
    var_ref           go to state 81
    expr              go to state 143
    funct_invoc       go to state 83


state 113

  104 expr: expr PLUS . expr

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 79
    literal_constant  go to state 80
    var_ref           go to state 81
    expr              go to state 144
    funct_invoc       go to state 83


state 114

  108 expr: expr MOD . expr

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 79
    literal_constant  go to state 80
    var_ref           go to state 81
    expr              go to state 145
    funct_invoc       go to state 83


state 115

  107 expr: expr DIVIDE . expr

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 79
    literal_constant  go to state 80
    var_ref           go to state 81
    expr              go to state 146
    funct_invoc       go to state 83


state 116

  106 expr: expr MULTIPLY . expr

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 79
    literal_constant  go to state 80
    var_ref           go to state 81
    expr              go to state 147
    funct_invoc       go to state 83


state 117

   26 array_indice: array_indice L_BRACKET CONS_INTEGER . R_BRACKET

    R_BRACKET  shift, and go to state 148


state 118

   34 expr_list: L_BRACE . nonEmpty_expr_list
   35          | L_BRACE .

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    $default  reduce using rule 35 (expr_list)

    symbol_id           go to state 79
    nonEmpty_expr_list  go to state 149
    literal_constant    go to state 80
    var_ref             go to state 81
    expr                go to state 150
    funct_invoc         go to state 83


state 119

   32 var_single: symbol_id array_indice ASSIGN init_array .

    $default  reduce using rule 32 (var_single)


state 120

   33 init_array: expr_list . R_BRACE

    R_BRACE  shift, and go to state 151


state 121

   47 funct_decl: type symbol_id L_PAREN arg_list R_PAREN SEMICOLON .

    $default  reduce using rule 47 (funct_decl)


state 122

   61 compound_list: L_BRACE . compound_list var_const_decl_list
   62              | L_BRACE . compound_list stat_list
   63              | L_BRACE .

    L_BRACE  error (nonassociative)

    $default  reduce using rule 63 (compound_list)

    compound_list  go to state 152


state 123

   52 definition: @3 type symbol_id arg_list R_PAREN compound_st .

    $default  reduce using rule 52 (definition)


state 124

   60 compound_st: compound_list . R_BRACE

    R_BRACE  shift, and go to state 153


state 125

   54 definition: @4 VOID symbol_id arg_list R_PAREN compound_st .

    $default  reduce using rule 54 (definition)


state 126

   24 identifier: symbol_id array_indice .
   26 array_indice: array_indice . L_BRACKET CONS_INTEGER R_BRACKET

    L_BRACKET  shift, and go to state 84

    $default  reduce using rule 24 (identifier)


state 127

   57 nonEmpty_arg_list: arg COMMA nonEmpty_arg_list .

    $default  reduce using rule 57 (nonEmpty_arg_list)


state 128

   94 expr: L_PAREN expr R_PAREN .

    $default  reduce using rule 94 (expr)


state 129

   95 expr: expr . OR expr
   96     | expr . AND expr
   97     | expr . NOT expr
   98     | expr . LESS expr
   99     | expr . LESS_EQ expr
  100     | expr . EQUAL expr
  101     | expr . GREAT_EQ expr
  102     | expr . GREAT expr
  103     | expr . NOT_EQ expr
  104     | expr . PLUS expr
  105     | expr . MINUS expr
  106     | expr . MULTIPLY expr
  107     | expr . DIVIDE expr
  108     | expr . MOD expr
  145 nonEmpty_funct_invoc_list: expr .

    OR        shift, and go to state 103
    AND       shift, and go to state 104
    NOT       shift, and go to state 105
    NOT_EQ    shift, and go to state 106
    GREAT     shift, and go to state 107
    GREAT_EQ  shift, and go to state 108
    EQUAL     shift, and go to state 109
    LESS_EQ   shift, and go to state 110
    LESS      shift, and go to state 111
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    $default  reduce using rule 145 (nonEmpty_funct_invoc_list)


state 130

  143 funct_invoc_list: L_PAREN nonEmpty_funct_invoc_list . COMMA expr
  144 nonEmpty_funct_invoc_list: nonEmpty_funct_invoc_list . COMMA expr

    COMMA  shift, and go to state 154


state 131

   85 arr_ref_index: L_BRACKET expr . R_BRACKET
   95 expr: expr . OR expr
   96     | expr . AND expr
   97     | expr . NOT expr
   98     | expr . LESS expr
   99     | expr . LESS_EQ expr
  100     | expr . EQUAL expr
  101     | expr . GREAT_EQ expr
  102     | expr . GREAT expr
  103     | expr . NOT_EQ expr
  104     | expr . PLUS expr
  105     | expr . MINUS expr
  106     | expr . MULTIPLY expr
  107     | expr . DIVIDE expr
  108     | expr . MOD expr

    R_BRACKET  shift, and go to state 155
    OR         shift, and go to state 103
    AND        shift, and go to state 104
    NOT        shift, and go to state 105
    NOT_EQ     shift, and go to state 106
    GREAT      shift, and go to state 107
    GREAT_EQ   shift, and go to state 108
    EQUAL      shift, and go to state 109
    LESS_EQ    shift, and go to state 110
    LESS       shift, and go to state 111
    MINUS      shift, and go to state 112
    PLUS       shift, and go to state 113
    MOD        shift, and go to state 114
    DIVIDE     shift, and go to state 115
    MULTIPLY   shift, and go to state 116


state 132

   83 arr_ref_indice: arr_ref_index arr_ref_indice .

    $default  reduce using rule 83 (arr_ref_indice)


state 133

  141 funct_invoc: symbol_id funct_invoc_list R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 156


state 134

   95 expr: expr . OR expr
   95     | expr OR expr .
   96     | expr . AND expr
   97     | expr . NOT expr
   98     | expr . LESS expr
   99     | expr . LESS_EQ expr
  100     | expr . EQUAL expr
  101     | expr . GREAT_EQ expr
  102     | expr . GREAT expr
  103     | expr . NOT_EQ expr
  104     | expr . PLUS expr
  105     | expr . MINUS expr
  106     | expr . MULTIPLY expr
  107     | expr . DIVIDE expr
  108     | expr . MOD expr

    AND       shift, and go to state 104
    NOT       shift, and go to state 105
    NOT_EQ    shift, and go to state 106
    GREAT     shift, and go to state 107
    GREAT_EQ  shift, and go to state 108
    EQUAL     shift, and go to state 109
    LESS_EQ   shift, and go to state 110
    LESS      shift, and go to state 111
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    NOT       [reduce using rule 95 (expr)]
    $default  reduce using rule 95 (expr)


state 135

   95 expr: expr . OR expr
   96     | expr . AND expr
   96     | expr AND expr .
   97     | expr . NOT expr
   98     | expr . LESS expr
   99     | expr . LESS_EQ expr
  100     | expr . EQUAL expr
  101     | expr . GREAT_EQ expr
  102     | expr . GREAT expr
  103     | expr . NOT_EQ expr
  104     | expr . PLUS expr
  105     | expr . MINUS expr
  106     | expr . MULTIPLY expr
  107     | expr . DIVIDE expr
  108     | expr . MOD expr

    NOT       shift, and go to state 105
    NOT_EQ    shift, and go to state 106
    GREAT     shift, and go to state 107
    GREAT_EQ  shift, and go to state 108
    EQUAL     shift, and go to state 109
    LESS_EQ   shift, and go to state 110
    LESS      shift, and go to state 111
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    NOT       [reduce using rule 96 (expr)]
    $default  reduce using rule 96 (expr)


state 136

   95 expr: expr . OR expr
   96     | expr . AND expr
   97     | expr . NOT expr
   97     | expr NOT expr .
   98     | expr . LESS expr
   99     | expr . LESS_EQ expr
  100     | expr . EQUAL expr
  101     | expr . GREAT_EQ expr
  102     | expr . GREAT expr
  103     | expr . NOT_EQ expr
  104     | expr . PLUS expr
  105     | expr . MINUS expr
  106     | expr . MULTIPLY expr
  107     | expr . DIVIDE expr
  108     | expr . MOD expr

    OR        shift, and go to state 103
    AND       shift, and go to state 104
    NOT       shift, and go to state 105
    NOT_EQ    shift, and go to state 106
    GREAT     shift, and go to state 107
    GREAT_EQ  shift, and go to state 108
    EQUAL     shift, and go to state 109
    LESS_EQ   shift, and go to state 110
    LESS      shift, and go to state 111
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    OR        [reduce using rule 97 (expr)]
    AND       [reduce using rule 97 (expr)]
    NOT       [reduce using rule 97 (expr)]
    NOT_EQ    [reduce using rule 97 (expr)]
    GREAT     [reduce using rule 97 (expr)]
    GREAT_EQ  [reduce using rule 97 (expr)]
    EQUAL     [reduce using rule 97 (expr)]
    LESS_EQ   [reduce using rule 97 (expr)]
    LESS      [reduce using rule 97 (expr)]
    MINUS     [reduce using rule 97 (expr)]
    PLUS      [reduce using rule 97 (expr)]
    MOD       [reduce using rule 97 (expr)]
    DIVIDE    [reduce using rule 97 (expr)]
    MULTIPLY  [reduce using rule 97 (expr)]
    $default  reduce using rule 97 (expr)


state 137

   95 expr: expr . OR expr
   96     | expr . AND expr
   97     | expr . NOT expr
   98     | expr . LESS expr
   99     | expr . LESS_EQ expr
  100     | expr . EQUAL expr
  101     | expr . GREAT_EQ expr
  102     | expr . GREAT expr
  103     | expr . NOT_EQ expr
  103     | expr NOT_EQ expr .
  104     | expr . PLUS expr
  105     | expr . MINUS expr
  106     | expr . MULTIPLY expr
  107     | expr . DIVIDE expr
  108     | expr . MOD expr

    NOT       shift, and go to state 105
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    NOT       [reduce using rule 103 (expr)]
    $default  reduce using rule 103 (expr)


state 138

   95 expr: expr . OR expr
   96     | expr . AND expr
   97     | expr . NOT expr
   98     | expr . LESS expr
   99     | expr . LESS_EQ expr
  100     | expr . EQUAL expr
  101     | expr . GREAT_EQ expr
  102     | expr . GREAT expr
  102     | expr GREAT expr .
  103     | expr . NOT_EQ expr
  104     | expr . PLUS expr
  105     | expr . MINUS expr
  106     | expr . MULTIPLY expr
  107     | expr . DIVIDE expr
  108     | expr . MOD expr

    NOT       shift, and go to state 105
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    NOT       [reduce using rule 102 (expr)]
    $default  reduce using rule 102 (expr)


state 139

   95 expr: expr . OR expr
   96     | expr . AND expr
   97     | expr . NOT expr
   98     | expr . LESS expr
   99     | expr . LESS_EQ expr
  100     | expr . EQUAL expr
  101     | expr . GREAT_EQ expr
  101     | expr GREAT_EQ expr .
  102     | expr . GREAT expr
  103     | expr . NOT_EQ expr
  104     | expr . PLUS expr
  105     | expr . MINUS expr
  106     | expr . MULTIPLY expr
  107     | expr . DIVIDE expr
  108     | expr . MOD expr

    NOT       shift, and go to state 105
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    NOT       [reduce using rule 101 (expr)]
    $default  reduce using rule 101 (expr)


state 140

   95 expr: expr . OR expr
   96     | expr . AND expr
   97     | expr . NOT expr
   98     | expr . LESS expr
   99     | expr . LESS_EQ expr
  100     | expr . EQUAL expr
  100     | expr EQUAL expr .
  101     | expr . GREAT_EQ expr
  102     | expr . GREAT expr
  103     | expr . NOT_EQ expr
  104     | expr . PLUS expr
  105     | expr . MINUS expr
  106     | expr . MULTIPLY expr
  107     | expr . DIVIDE expr
  108     | expr . MOD expr

    NOT       shift, and go to state 105
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    NOT       [reduce using rule 100 (expr)]
    $default  reduce using rule 100 (expr)


state 141

   95 expr: expr . OR expr
   96     | expr . AND expr
   97     | expr . NOT expr
   98     | expr . LESS expr
   99     | expr . LESS_EQ expr
   99     | expr LESS_EQ expr .
  100     | expr . EQUAL expr
  101     | expr . GREAT_EQ expr
  102     | expr . GREAT expr
  103     | expr . NOT_EQ expr
  104     | expr . PLUS expr
  105     | expr . MINUS expr
  106     | expr . MULTIPLY expr
  107     | expr . DIVIDE expr
  108     | expr . MOD expr

    NOT       shift, and go to state 105
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    NOT       [reduce using rule 99 (expr)]
    $default  reduce using rule 99 (expr)


state 142

   95 expr: expr . OR expr
   96     | expr . AND expr
   97     | expr . NOT expr
   98     | expr . LESS expr
   98     | expr LESS expr .
   99     | expr . LESS_EQ expr
  100     | expr . EQUAL expr
  101     | expr . GREAT_EQ expr
  102     | expr . GREAT expr
  103     | expr . NOT_EQ expr
  104     | expr . PLUS expr
  105     | expr . MINUS expr
  106     | expr . MULTIPLY expr
  107     | expr . DIVIDE expr
  108     | expr . MOD expr

    NOT       shift, and go to state 105
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    NOT       [reduce using rule 98 (expr)]
    $default  reduce using rule 98 (expr)


state 143

   95 expr: expr . OR expr
   96     | expr . AND expr
   97     | expr . NOT expr
   98     | expr . LESS expr
   99     | expr . LESS_EQ expr
  100     | expr . EQUAL expr
  101     | expr . GREAT_EQ expr
  102     | expr . GREAT expr
  103     | expr . NOT_EQ expr
  104     | expr . PLUS expr
  105     | expr . MINUS expr
  105     | expr MINUS expr .
  106     | expr . MULTIPLY expr
  107     | expr . DIVIDE expr
  108     | expr . MOD expr

    NOT       shift, and go to state 105
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    NOT       [reduce using rule 105 (expr)]
    $default  reduce using rule 105 (expr)


state 144

   95 expr: expr . OR expr
   96     | expr . AND expr
   97     | expr . NOT expr
   98     | expr . LESS expr
   99     | expr . LESS_EQ expr
  100     | expr . EQUAL expr
  101     | expr . GREAT_EQ expr
  102     | expr . GREAT expr
  103     | expr . NOT_EQ expr
  104     | expr . PLUS expr
  104     | expr PLUS expr .
  105     | expr . MINUS expr
  106     | expr . MULTIPLY expr
  107     | expr . DIVIDE expr
  108     | expr . MOD expr

    NOT       shift, and go to state 105
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    NOT       [reduce using rule 104 (expr)]
    $default  reduce using rule 104 (expr)


state 145

   95 expr: expr . OR expr
   96     | expr . AND expr
   97     | expr . NOT expr
   98     | expr . LESS expr
   99     | expr . LESS_EQ expr
  100     | expr . EQUAL expr
  101     | expr . GREAT_EQ expr
  102     | expr . GREAT expr
  103     | expr . NOT_EQ expr
  104     | expr . PLUS expr
  105     | expr . MINUS expr
  106     | expr . MULTIPLY expr
  107     | expr . DIVIDE expr
  108     | expr . MOD expr
  108     | expr MOD expr .

    NOT  shift, and go to state 105

    NOT       [reduce using rule 108 (expr)]
    $default  reduce using rule 108 (expr)


state 146

   95 expr: expr . OR expr
   96     | expr . AND expr
   97     | expr . NOT expr
   98     | expr . LESS expr
   99     | expr . LESS_EQ expr
  100     | expr . EQUAL expr
  101     | expr . GREAT_EQ expr
  102     | expr . GREAT expr
  103     | expr . NOT_EQ expr
  104     | expr . PLUS expr
  105     | expr . MINUS expr
  106     | expr . MULTIPLY expr
  107     | expr . DIVIDE expr
  107     | expr DIVIDE expr .
  108     | expr . MOD expr

    NOT  shift, and go to state 105

    NOT       [reduce using rule 107 (expr)]
    $default  reduce using rule 107 (expr)


state 147

   95 expr: expr . OR expr
   96     | expr . AND expr
   97     | expr . NOT expr
   98     | expr . LESS expr
   99     | expr . LESS_EQ expr
  100     | expr . EQUAL expr
  101     | expr . GREAT_EQ expr
  102     | expr . GREAT expr
  103     | expr . NOT_EQ expr
  104     | expr . PLUS expr
  105     | expr . MINUS expr
  106     | expr . MULTIPLY expr
  106     | expr MULTIPLY expr .
  107     | expr . DIVIDE expr
  108     | expr . MOD expr

    NOT  shift, and go to state 105

    NOT       [reduce using rule 106 (expr)]
    $default  reduce using rule 106 (expr)


state 148

   26 array_indice: array_indice L_BRACKET CONS_INTEGER R_BRACKET .

    $default  reduce using rule 26 (array_indice)


state 149

   34 expr_list: L_BRACE nonEmpty_expr_list .
   36 nonEmpty_expr_list: nonEmpty_expr_list . COMMA expr

    COMMA  shift, and go to state 157

    $default  reduce using rule 34 (expr_list)


state 150

   37 nonEmpty_expr_list: expr .
   95 expr: expr . OR expr
   96     | expr . AND expr
   97     | expr . NOT expr
   98     | expr . LESS expr
   99     | expr . LESS_EQ expr
  100     | expr . EQUAL expr
  101     | expr . GREAT_EQ expr
  102     | expr . GREAT expr
  103     | expr . NOT_EQ expr
  104     | expr . PLUS expr
  105     | expr . MINUS expr
  106     | expr . MULTIPLY expr
  107     | expr . DIVIDE expr
  108     | expr . MOD expr

    OR        shift, and go to state 103
    AND       shift, and go to state 104
    NOT       shift, and go to state 105
    NOT_EQ    shift, and go to state 106
    GREAT     shift, and go to state 107
    GREAT_EQ  shift, and go to state 108
    EQUAL     shift, and go to state 109
    LESS_EQ   shift, and go to state 110
    LESS      shift, and go to state 111
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    $default  reduce using rule 37 (nonEmpty_expr_list)


state 151

   33 init_array: expr_list R_BRACE .

    $default  reduce using rule 33 (init_array)


state 152

   61 compound_list: L_BRACE compound_list . var_const_decl_list
   62              | L_BRACE compound_list . stat_list

    CONST     shift, and go to state 2
    STRING    shift, and go to state 3
    DOUBLE    shift, and go to state 4
    FLOAT     shift, and go to state 5
    BOOL      shift, and go to state 6
    INT       shift, and go to state 7
    BOOLEAN   shift, and go to state 8
    L_BRACE   shift, and go to state 122
    WHILE     shift, and go to state 158
    DO        shift, and go to state 159
    IF        shift, and go to state 160
    FOR       shift, and go to state 161
    PRINT     shift, and go to state 162
    READ      shift, and go to state 163
    CONTINUE  shift, and go to state 164
    BREAK     shift, and go to state 165
    RETURN    shift, and go to state 166
    ID        shift, and go to state 21

    var_decl             go to state 167
    type                 go to state 168
    symbol_id            go to state 79
    const_decl           go to state 169
    compound_st          go to state 170
    compound_list        go to state 124
    var_const_decl_list  go to state 171
    stat_list            go to state 172
    statement            go to state 173
    simple_st            go to state 174
    var_ref              go to state 175
    condition_st         go to state 176
    while_st             go to state 177
    jump_st              go to state 178
    for_st               go to state 179
    funct_invoc          go to state 180


state 153

   60 compound_st: compound_list R_BRACE .

    $default  reduce using rule 60 (compound_st)


state 154

  143 funct_invoc_list: L_PAREN nonEmpty_funct_invoc_list COMMA . expr
  144 nonEmpty_funct_invoc_list: nonEmpty_funct_invoc_list COMMA . expr

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 79
    literal_constant  go to state 80
    var_ref           go to state 81
    expr              go to state 181
    funct_invoc       go to state 83


state 155

   85 arr_ref_index: L_BRACKET expr R_BRACKET .

    $default  reduce using rule 85 (arr_ref_index)


state 156

  141 funct_invoc: symbol_id funct_invoc_list R_PAREN SEMICOLON .

    $default  reduce using rule 141 (funct_invoc)


state 157

   36 nonEmpty_expr_list: nonEmpty_expr_list COMMA . expr

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 79
    literal_constant  go to state 80
    var_ref           go to state 81
    expr              go to state 182
    funct_invoc       go to state 83


state 158

   89 while_st: WHILE . L_PAREN bool_expr R_PAREN compound_st

    L_PAREN  shift, and go to state 183


state 159

   90 while_st: DO . compound_st WHILE L_PAREN bool_expr R_PAREN SEMICOLON

    L_BRACE  shift, and go to state 122

    compound_st    go to state 184
    compound_list  go to state 124


state 160

   86 condition_st: IF . L_PAREN bool_expr R_PAREN compound_st
   87             | IF . L_PAREN bool_expr R_PAREN compound_st ELSE compound_st

    L_PAREN  shift, and go to state 185


state 161

  113 for_st: FOR . for_init for_control for_incre R_PAREN compound_st

    L_PAREN  shift, and go to state 186

    for_init  go to state 187


state 162

   78 simple_st: PRINT . var_ref SEMICOLON
   79          | PRINT . expr SEMICOLON

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 79
    literal_constant  go to state 80
    var_ref           go to state 188
    expr              go to state 189
    funct_invoc       go to state 83


state 163

   80 simple_st: READ . var_ref SEMICOLON

    ID  shift, and go to state 21

    symbol_id  go to state 190
    var_ref    go to state 191


state 164

   93 jump_st: CONTINUE . SEMICOLON

    SEMICOLON  shift, and go to state 192


state 165

   92 jump_st: BREAK . SEMICOLON

    SEMICOLON  shift, and go to state 193


state 166

   91 jump_st: RETURN . expr SEMICOLON

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 79
    literal_constant  go to state 80
    var_ref           go to state 81
    expr              go to state 194
    funct_invoc       go to state 83


state 167

   66 var_const_decl_list: var_decl .

    $default  reduce using rule 66 (var_const_decl_list)


state 168

   16 var_decl: type . @1 var_list @2 SEMICOLON

    $default  reduce using rule 14 (@1)

    @1  go to state 31


state 169

   67 var_const_decl_list: const_decl .

    $default  reduce using rule 67 (var_const_decl_list)


state 170

   70 statement: compound_st .

    $default  reduce using rule 70 (statement)


state 171

   61 compound_list: L_BRACE compound_list var_const_decl_list .
   64 var_const_decl_list: var_const_decl_list . var_decl
   65                    | var_const_decl_list . const_decl

    $default  reduce using rule 61 (compound_list)

    var_decl    go to state 195
    type        go to state 168
    const_decl  go to state 196


state 172

   62 compound_list: L_BRACE compound_list stat_list .
   68 stat_list: stat_list . statement

    WHILE     shift, and go to state 158
    DO        shift, and go to state 159
    IF        shift, and go to state 160
    FOR       shift, and go to state 161
    PRINT     shift, and go to state 162
    READ      shift, and go to state 163
    CONTINUE  shift, and go to state 164
    BREAK     shift, and go to state 165
    RETURN    shift, and go to state 166
    ID        shift, and go to state 21

    L_BRACE  error (nonassociative)

    WHILE     [reduce using rule 62 (compound_list)]
    DO        [reduce using rule 62 (compound_list)]
    IF        [reduce using rule 62 (compound_list)]
    FOR       [reduce using rule 62 (compound_list)]
    PRINT     [reduce using rule 62 (compound_list)]
    READ      [reduce using rule 62 (compound_list)]
    CONTINUE  [reduce using rule 62 (compound_list)]
    BREAK     [reduce using rule 62 (compound_list)]
    RETURN    [reduce using rule 62 (compound_list)]
    ID        [reduce using rule 62 (compound_list)]
    $default  reduce using rule 62 (compound_list)

    symbol_id      go to state 79
    compound_st    go to state 170
    compound_list  go to state 124
    statement      go to state 197
    simple_st      go to state 174
    var_ref        go to state 175
    condition_st   go to state 176
    while_st       go to state 177
    jump_st        go to state 178
    for_st         go to state 179
    funct_invoc    go to state 180


state 173

   69 stat_list: statement .

    $default  reduce using rule 69 (stat_list)


state 174

   71 statement: simple_st .

    $default  reduce using rule 71 (statement)


state 175

   77 simple_st: var_ref . ASSIGN expr SEMICOLON

    ASSIGN  shift, and go to state 198


state 176

   72 statement: condition_st .

    $default  reduce using rule 72 (statement)


state 177

   73 statement: while_st .

    $default  reduce using rule 73 (statement)


state 178

   75 statement: jump_st .

    $default  reduce using rule 75 (statement)


state 179

   74 statement: for_st .

    $default  reduce using rule 74 (statement)


state 180

   76 statement: funct_invoc .

    $default  reduce using rule 76 (statement)


state 181

   95 expr: expr . OR expr
   96     | expr . AND expr
   97     | expr . NOT expr
   98     | expr . LESS expr
   99     | expr . LESS_EQ expr
  100     | expr . EQUAL expr
  101     | expr . GREAT_EQ expr
  102     | expr . GREAT expr
  103     | expr . NOT_EQ expr
  104     | expr . PLUS expr
  105     | expr . MINUS expr
  106     | expr . MULTIPLY expr
  107     | expr . DIVIDE expr
  108     | expr . MOD expr
  143 funct_invoc_list: L_PAREN nonEmpty_funct_invoc_list COMMA expr .
  144 nonEmpty_funct_invoc_list: nonEmpty_funct_invoc_list COMMA expr .

    OR        shift, and go to state 103
    AND       shift, and go to state 104
    NOT       shift, and go to state 105
    NOT_EQ    shift, and go to state 106
    GREAT     shift, and go to state 107
    GREAT_EQ  shift, and go to state 108
    EQUAL     shift, and go to state 109
    LESS_EQ   shift, and go to state 110
    LESS      shift, and go to state 111
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    COMMA     reduce using rule 144 (nonEmpty_funct_invoc_list)
    $default  reduce using rule 143 (funct_invoc_list)


state 182

   36 nonEmpty_expr_list: nonEmpty_expr_list COMMA expr .
   95 expr: expr . OR expr
   96     | expr . AND expr
   97     | expr . NOT expr
   98     | expr . LESS expr
   99     | expr . LESS_EQ expr
  100     | expr . EQUAL expr
  101     | expr . GREAT_EQ expr
  102     | expr . GREAT expr
  103     | expr . NOT_EQ expr
  104     | expr . PLUS expr
  105     | expr . MINUS expr
  106     | expr . MULTIPLY expr
  107     | expr . DIVIDE expr
  108     | expr . MOD expr

    OR        shift, and go to state 103
    AND       shift, and go to state 104
    NOT       shift, and go to state 105
    NOT_EQ    shift, and go to state 106
    GREAT     shift, and go to state 107
    GREAT_EQ  shift, and go to state 108
    EQUAL     shift, and go to state 109
    LESS_EQ   shift, and go to state 110
    LESS      shift, and go to state 111
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    $default  reduce using rule 36 (nonEmpty_expr_list)


state 183

   89 while_st: WHILE L_PAREN . bool_expr R_PAREN compound_st

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 79
    literal_constant  go to state 80
    var_ref           go to state 81
    bool_expr         go to state 199
    expr              go to state 200
    funct_invoc       go to state 83


state 184

   90 while_st: DO compound_st . WHILE L_PAREN bool_expr R_PAREN SEMICOLON

    WHILE  shift, and go to state 201


state 185

   86 condition_st: IF L_PAREN . bool_expr R_PAREN compound_st
   87             | IF L_PAREN . bool_expr R_PAREN compound_st ELSE compound_st

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 79
    literal_constant  go to state 80
    var_ref           go to state 81
    bool_expr         go to state 202
    expr              go to state 200
    funct_invoc       go to state 83


state 186

  114 for_init: L_PAREN . nonEmpty_for_init
  115         | L_PAREN .

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    $default  reduce using rule 115 (for_init)

    symbol_id          go to state 203
    literal_constant   go to state 80
    var_ref            go to state 81
    expr               go to state 204
    nonEmpty_for_init  go to state 205
    for_single_entry   go to state 206
    funct_invoc        go to state 207


state 187

  113 for_st: FOR for_init . for_control for_incre R_PAREN compound_st

    SEMICOLON  shift, and go to state 208

    for_control  go to state 209


state 188

   78 simple_st: PRINT var_ref . SEMICOLON
  111 expr: var_ref .

    SEMICOLON  shift, and go to state 210

    SEMICOLON  [reduce using rule 111 (expr)]
    $default   reduce using rule 111 (expr)


state 189

   79 simple_st: PRINT expr . SEMICOLON
   95 expr: expr . OR expr
   96     | expr . AND expr
   97     | expr . NOT expr
   98     | expr . LESS expr
   99     | expr . LESS_EQ expr
  100     | expr . EQUAL expr
  101     | expr . GREAT_EQ expr
  102     | expr . GREAT expr
  103     | expr . NOT_EQ expr
  104     | expr . PLUS expr
  105     | expr . MINUS expr
  106     | expr . MULTIPLY expr
  107     | expr . DIVIDE expr
  108     | expr . MOD expr

    OR         shift, and go to state 103
    AND        shift, and go to state 104
    NOT        shift, and go to state 105
    NOT_EQ     shift, and go to state 106
    GREAT      shift, and go to state 107
    GREAT_EQ   shift, and go to state 108
    EQUAL      shift, and go to state 109
    LESS_EQ    shift, and go to state 110
    LESS       shift, and go to state 111
    MINUS      shift, and go to state 112
    PLUS       shift, and go to state 113
    MOD        shift, and go to state 114
    DIVIDE     shift, and go to state 115
    MULTIPLY   shift, and go to state 116
    SEMICOLON  shift, and go to state 211


state 190

   81 var_ref: symbol_id .
   82        | symbol_id . arr_ref_indice

    L_BRACKET  shift, and go to state 99

    $default  reduce using rule 81 (var_ref)

    arr_ref_indice  go to state 100
    arr_ref_index   go to state 101


state 191

   80 simple_st: READ var_ref . SEMICOLON

    SEMICOLON  shift, and go to state 212


state 192

   93 jump_st: CONTINUE SEMICOLON .

    $default  reduce using rule 93 (jump_st)


state 193

   92 jump_st: BREAK SEMICOLON .

    $default  reduce using rule 92 (jump_st)


state 194

   91 jump_st: RETURN expr . SEMICOLON
   95 expr: expr . OR expr
   96     | expr . AND expr
   97     | expr . NOT expr
   98     | expr . LESS expr
   99     | expr . LESS_EQ expr
  100     | expr . EQUAL expr
  101     | expr . GREAT_EQ expr
  102     | expr . GREAT expr
  103     | expr . NOT_EQ expr
  104     | expr . PLUS expr
  105     | expr . MINUS expr
  106     | expr . MULTIPLY expr
  107     | expr . DIVIDE expr
  108     | expr . MOD expr

    OR         shift, and go to state 103
    AND        shift, and go to state 104
    NOT        shift, and go to state 105
    NOT_EQ     shift, and go to state 106
    GREAT      shift, and go to state 107
    GREAT_EQ   shift, and go to state 108
    EQUAL      shift, and go to state 109
    LESS_EQ    shift, and go to state 110
    LESS       shift, and go to state 111
    MINUS      shift, and go to state 112
    PLUS       shift, and go to state 113
    MOD        shift, and go to state 114
    DIVIDE     shift, and go to state 115
    MULTIPLY   shift, and go to state 116
    SEMICOLON  shift, and go to state 213


state 195

   64 var_const_decl_list: var_const_decl_list var_decl .

    $default  reduce using rule 64 (var_const_decl_list)


state 196

   65 var_const_decl_list: var_const_decl_list const_decl .

    $default  reduce using rule 65 (var_const_decl_list)


state 197

   68 stat_list: stat_list statement .

    $default  reduce using rule 68 (stat_list)


state 198

   77 simple_st: var_ref ASSIGN . expr SEMICOLON

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 79
    literal_constant  go to state 80
    var_ref           go to state 81
    expr              go to state 214
    funct_invoc       go to state 83


state 199

   89 while_st: WHILE L_PAREN bool_expr . R_PAREN compound_st

    R_PAREN  shift, and go to state 215


state 200

   88 bool_expr: expr .
   95 expr: expr . OR expr
   96     | expr . AND expr
   97     | expr . NOT expr
   98     | expr . LESS expr
   99     | expr . LESS_EQ expr
  100     | expr . EQUAL expr
  101     | expr . GREAT_EQ expr
  102     | expr . GREAT expr
  103     | expr . NOT_EQ expr
  104     | expr . PLUS expr
  105     | expr . MINUS expr
  106     | expr . MULTIPLY expr
  107     | expr . DIVIDE expr
  108     | expr . MOD expr

    OR        shift, and go to state 103
    AND       shift, and go to state 104
    NOT       shift, and go to state 105
    NOT_EQ    shift, and go to state 106
    GREAT     shift, and go to state 107
    GREAT_EQ  shift, and go to state 108
    EQUAL     shift, and go to state 109
    LESS_EQ   shift, and go to state 110
    LESS      shift, and go to state 111
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    $default  reduce using rule 88 (bool_expr)


state 201

   90 while_st: DO compound_st WHILE . L_PAREN bool_expr R_PAREN SEMICOLON

    L_PAREN  shift, and go to state 216


state 202

   86 condition_st: IF L_PAREN bool_expr . R_PAREN compound_st
   87             | IF L_PAREN bool_expr . R_PAREN compound_st ELSE compound_st

    R_PAREN  shift, and go to state 217


state 203

   81 var_ref: symbol_id .
   82        | symbol_id . arr_ref_indice
  137 for_single_entry: symbol_id . ASSIGN expr
  138                 | symbol_id . array_indice ASSIGN init_array
  141 funct_invoc: symbol_id . funct_invoc_list R_PAREN SEMICOLON

    L_PAREN    shift, and go to state 98
    L_BRACKET  shift, and go to state 218
    ASSIGN     shift, and go to state 219

    $default  reduce using rule 81 (var_ref)

    array_indice      go to state 220
    arr_ref_indice    go to state 100
    arr_ref_index     go to state 101
    funct_invoc_list  go to state 102


state 204

   95 expr: expr . OR expr
   96     | expr . AND expr
   97     | expr . NOT expr
   98     | expr . LESS expr
   99     | expr . LESS_EQ expr
  100     | expr . EQUAL expr
  101     | expr . GREAT_EQ expr
  102     | expr . GREAT expr
  103     | expr . NOT_EQ expr
  104     | expr . PLUS expr
  105     | expr . MINUS expr
  106     | expr . MULTIPLY expr
  107     | expr . DIVIDE expr
  108     | expr . MOD expr
  140 for_single_entry: expr .

    OR        shift, and go to state 103
    AND       shift, and go to state 104
    NOT       shift, and go to state 105
    NOT_EQ    shift, and go to state 106
    GREAT     shift, and go to state 107
    GREAT_EQ  shift, and go to state 108
    EQUAL     shift, and go to state 109
    LESS_EQ   shift, and go to state 110
    LESS      shift, and go to state 111
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    $default  reduce using rule 140 (for_single_entry)


state 205

  114 for_init: L_PAREN nonEmpty_for_init .
  116 nonEmpty_for_init: nonEmpty_for_init . COMMA for_single_entry

    COMMA  shift, and go to state 221

    $default  reduce using rule 114 (for_init)


state 206

  117 nonEmpty_for_init: for_single_entry .

    $default  reduce using rule 117 (nonEmpty_for_init)


state 207

  112 expr: funct_invoc .
  139 for_single_entry: funct_invoc .

    R_PAREN    reduce using rule 112 (expr)
    R_PAREN    [reduce using rule 139 (for_single_entry)]
    SEMICOLON  reduce using rule 112 (expr)
    SEMICOLON  [reduce using rule 139 (for_single_entry)]
    COMMA      reduce using rule 112 (expr)
    COMMA      [reduce using rule 139 (for_single_entry)]
    $default   reduce using rule 112 (expr)


state 208

  122 for_control: SEMICOLON . nonEmpty_for_control
  123            | SEMICOLON .

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    $default  reduce using rule 123 (for_control)

    symbol_id             go to state 222
    literal_constant      go to state 80
    var_ref               go to state 81
    expr                  go to state 223
    nonEmpty_for_control  go to state 224
    for_control_entry     go to state 225
    funct_invoc           go to state 83


state 209

  113 for_st: FOR for_init for_control . for_incre R_PAREN compound_st

    SEMICOLON  shift, and go to state 226

    for_incre  go to state 227


state 210

   78 simple_st: PRINT var_ref SEMICOLON .

    $default  reduce using rule 78 (simple_st)


state 211

   79 simple_st: PRINT expr SEMICOLON .

    $default  reduce using rule 79 (simple_st)


state 212

   80 simple_st: READ var_ref SEMICOLON .

    $default  reduce using rule 80 (simple_st)


state 213

   91 jump_st: RETURN expr SEMICOLON .

    $default  reduce using rule 91 (jump_st)


state 214

   77 simple_st: var_ref ASSIGN expr . SEMICOLON
   95 expr: expr . OR expr
   96     | expr . AND expr
   97     | expr . NOT expr
   98     | expr . LESS expr
   99     | expr . LESS_EQ expr
  100     | expr . EQUAL expr
  101     | expr . GREAT_EQ expr
  102     | expr . GREAT expr
  103     | expr . NOT_EQ expr
  104     | expr . PLUS expr
  105     | expr . MINUS expr
  106     | expr . MULTIPLY expr
  107     | expr . DIVIDE expr
  108     | expr . MOD expr

    OR         shift, and go to state 103
    AND        shift, and go to state 104
    NOT        shift, and go to state 105
    NOT_EQ     shift, and go to state 106
    GREAT      shift, and go to state 107
    GREAT_EQ   shift, and go to state 108
    EQUAL      shift, and go to state 109
    LESS_EQ    shift, and go to state 110
    LESS       shift, and go to state 111
    MINUS      shift, and go to state 112
    PLUS       shift, and go to state 113
    MOD        shift, and go to state 114
    DIVIDE     shift, and go to state 115
    MULTIPLY   shift, and go to state 116
    SEMICOLON  shift, and go to state 228


state 215

   89 while_st: WHILE L_PAREN bool_expr R_PAREN . compound_st

    L_BRACE  shift, and go to state 122

    compound_st    go to state 229
    compound_list  go to state 124


state 216

   90 while_st: DO compound_st WHILE L_PAREN . bool_expr R_PAREN SEMICOLON

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 79
    literal_constant  go to state 80
    var_ref           go to state 81
    bool_expr         go to state 230
    expr              go to state 200
    funct_invoc       go to state 83


state 217

   86 condition_st: IF L_PAREN bool_expr R_PAREN . compound_st
   87             | IF L_PAREN bool_expr R_PAREN . compound_st ELSE compound_st

    L_BRACE  shift, and go to state 122

    compound_st    go to state 231
    compound_list  go to state 124


state 218

   27 array_indice: L_BRACKET . CONS_INTEGER R_BRACKET
   85 arr_ref_index: L_BRACKET . expr R_BRACKET

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 232
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 79
    literal_constant  go to state 80
    var_ref           go to state 81
    expr              go to state 131
    funct_invoc       go to state 83


state 219

  137 for_single_entry: symbol_id ASSIGN . expr

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 79
    literal_constant  go to state 80
    var_ref           go to state 81
    expr              go to state 233
    funct_invoc       go to state 83


state 220

   26 array_indice: array_indice . L_BRACKET CONS_INTEGER R_BRACKET
  138 for_single_entry: symbol_id array_indice . ASSIGN init_array

    L_BRACKET  shift, and go to state 84
    ASSIGN     shift, and go to state 234


state 221

  116 nonEmpty_for_init: nonEmpty_for_init COMMA . for_single_entry

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 203
    literal_constant  go to state 80
    var_ref           go to state 81
    expr              go to state 204
    for_single_entry  go to state 235
    funct_invoc       go to state 207


state 222

   81 var_ref: symbol_id .
   82        | symbol_id . arr_ref_indice
  135 for_control_entry: symbol_id . ASSIGN expr
  136                  | symbol_id . array_indice ASSIGN init_array
  141 funct_invoc: symbol_id . funct_invoc_list R_PAREN SEMICOLON

    L_PAREN    shift, and go to state 98
    L_BRACKET  shift, and go to state 218
    ASSIGN     shift, and go to state 236

    $default  reduce using rule 81 (var_ref)

    array_indice      go to state 237
    arr_ref_indice    go to state 100
    arr_ref_index     go to state 101
    funct_invoc_list  go to state 102


state 223

   95 expr: expr . OR expr
   96     | expr . AND expr
   97     | expr . NOT expr
   98     | expr . LESS expr
   99     | expr . LESS_EQ expr
  100     | expr . EQUAL expr
  101     | expr . GREAT_EQ expr
  102     | expr . GREAT expr
  103     | expr . NOT_EQ expr
  104     | expr . PLUS expr
  105     | expr . MINUS expr
  106     | expr . MULTIPLY expr
  107     | expr . DIVIDE expr
  108     | expr . MOD expr
  126 for_control_entry: expr . OR expr
  127                  | expr . AND expr
  128                  | expr . NOT expr
  129                  | expr . LESS expr
  130                  | expr . LESS_EQ expr
  131                  | expr . EQUAL expr
  132                  | expr . GREAT_EQ expr
  133                  | expr . GREAT expr
  134                  | expr . NOT_EQ expr

    OR        shift, and go to state 238
    AND       shift, and go to state 239
    NOT       shift, and go to state 240
    NOT_EQ    shift, and go to state 241
    GREAT     shift, and go to state 242
    GREAT_EQ  shift, and go to state 243
    EQUAL     shift, and go to state 244
    LESS_EQ   shift, and go to state 245
    LESS      shift, and go to state 246
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116


state 224

  122 for_control: SEMICOLON nonEmpty_for_control .
  124 nonEmpty_for_control: nonEmpty_for_control . COMMA for_control_entry

    COMMA  shift, and go to state 247

    $default  reduce using rule 122 (for_control)


state 225

  125 nonEmpty_for_control: for_control_entry .

    $default  reduce using rule 125 (nonEmpty_for_control)


state 226

  118 for_incre: SEMICOLON . nonEmpty_for_incre
  119          | SEMICOLON .

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    $default  reduce using rule 119 (for_incre)

    symbol_id           go to state 203
    literal_constant    go to state 80
    var_ref             go to state 81
    expr                go to state 204
    nonEmpty_for_incre  go to state 248
    for_single_entry    go to state 249
    funct_invoc         go to state 207


state 227

  113 for_st: FOR for_init for_control for_incre . R_PAREN compound_st

    R_PAREN  shift, and go to state 250


state 228

   77 simple_st: var_ref ASSIGN expr SEMICOLON .

    $default  reduce using rule 77 (simple_st)


state 229

   89 while_st: WHILE L_PAREN bool_expr R_PAREN compound_st .

    $default  reduce using rule 89 (while_st)


state 230

   90 while_st: DO compound_st WHILE L_PAREN bool_expr . R_PAREN SEMICOLON

    R_PAREN  shift, and go to state 251


state 231

   86 condition_st: IF L_PAREN bool_expr R_PAREN compound_st .
   87             | IF L_PAREN bool_expr R_PAREN compound_st . ELSE compound_st

    ELSE  shift, and go to state 252

    $default  reduce using rule 86 (condition_st)


state 232

   27 array_indice: L_BRACKET CONS_INTEGER . R_BRACKET
   42 literal_constant: CONS_INTEGER .

    R_BRACKET  shift, and go to state 95

    R_BRACKET  [reduce using rule 42 (literal_constant)]
    $default   reduce using rule 42 (literal_constant)


state 233

   95 expr: expr . OR expr
   96     | expr . AND expr
   97     | expr . NOT expr
   98     | expr . LESS expr
   99     | expr . LESS_EQ expr
  100     | expr . EQUAL expr
  101     | expr . GREAT_EQ expr
  102     | expr . GREAT expr
  103     | expr . NOT_EQ expr
  104     | expr . PLUS expr
  105     | expr . MINUS expr
  106     | expr . MULTIPLY expr
  107     | expr . DIVIDE expr
  108     | expr . MOD expr
  137 for_single_entry: symbol_id ASSIGN expr .

    OR        shift, and go to state 103
    AND       shift, and go to state 104
    NOT       shift, and go to state 105
    NOT_EQ    shift, and go to state 106
    GREAT     shift, and go to state 107
    GREAT_EQ  shift, and go to state 108
    EQUAL     shift, and go to state 109
    LESS_EQ   shift, and go to state 110
    LESS      shift, and go to state 111
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    $default  reduce using rule 137 (for_single_entry)


state 234

  138 for_single_entry: symbol_id array_indice ASSIGN . init_array

    L_BRACE  shift, and go to state 118

    init_array  go to state 253
    expr_list   go to state 120


state 235

  116 nonEmpty_for_init: nonEmpty_for_init COMMA for_single_entry .

    $default  reduce using rule 116 (nonEmpty_for_init)


state 236

  135 for_control_entry: symbol_id ASSIGN . expr

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 79
    literal_constant  go to state 80
    var_ref           go to state 81
    expr              go to state 254
    funct_invoc       go to state 83


state 237

   26 array_indice: array_indice . L_BRACKET CONS_INTEGER R_BRACKET
  136 for_control_entry: symbol_id array_indice . ASSIGN init_array

    L_BRACKET  shift, and go to state 84
    ASSIGN     shift, and go to state 255


state 238

   95 expr: expr OR . expr
  126 for_control_entry: expr OR . expr

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 79
    literal_constant  go to state 80
    var_ref           go to state 81
    expr              go to state 256
    funct_invoc       go to state 83


state 239

   96 expr: expr AND . expr
  127 for_control_entry: expr AND . expr

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 79
    literal_constant  go to state 80
    var_ref           go to state 81
    expr              go to state 257
    funct_invoc       go to state 83


state 240

   97 expr: expr NOT . expr
  128 for_control_entry: expr NOT . expr

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 79
    literal_constant  go to state 80
    var_ref           go to state 81
    expr              go to state 258
    funct_invoc       go to state 83


state 241

  103 expr: expr NOT_EQ . expr
  134 for_control_entry: expr NOT_EQ . expr

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 79
    literal_constant  go to state 80
    var_ref           go to state 81
    expr              go to state 259
    funct_invoc       go to state 83


state 242

  102 expr: expr GREAT . expr
  133 for_control_entry: expr GREAT . expr

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 79
    literal_constant  go to state 80
    var_ref           go to state 81
    expr              go to state 260
    funct_invoc       go to state 83


state 243

  101 expr: expr GREAT_EQ . expr
  132 for_control_entry: expr GREAT_EQ . expr

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 79
    literal_constant  go to state 80
    var_ref           go to state 81
    expr              go to state 261
    funct_invoc       go to state 83


state 244

  100 expr: expr EQUAL . expr
  131 for_control_entry: expr EQUAL . expr

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 79
    literal_constant  go to state 80
    var_ref           go to state 81
    expr              go to state 262
    funct_invoc       go to state 83


state 245

   99 expr: expr LESS_EQ . expr
  130 for_control_entry: expr LESS_EQ . expr

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 79
    literal_constant  go to state 80
    var_ref           go to state 81
    expr              go to state 263
    funct_invoc       go to state 83


state 246

   98 expr: expr LESS . expr
  129 for_control_entry: expr LESS . expr

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 79
    literal_constant  go to state 80
    var_ref           go to state 81
    expr              go to state 264
    funct_invoc       go to state 83


state 247

  124 nonEmpty_for_control: nonEmpty_for_control COMMA . for_control_entry

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id          go to state 222
    literal_constant   go to state 80
    var_ref            go to state 81
    expr               go to state 223
    for_control_entry  go to state 265
    funct_invoc        go to state 83


state 248

  118 for_incre: SEMICOLON nonEmpty_for_incre .
  120 nonEmpty_for_incre: nonEmpty_for_incre . COMMA for_single_entry

    COMMA  shift, and go to state 266

    $default  reduce using rule 118 (for_incre)


state 249

  121 nonEmpty_for_incre: for_single_entry .

    $default  reduce using rule 121 (nonEmpty_for_incre)


state 250

  113 for_st: FOR for_init for_control for_incre R_PAREN . compound_st

    L_BRACE  shift, and go to state 122

    compound_st    go to state 267
    compound_list  go to state 124


state 251

   90 while_st: DO compound_st WHILE L_PAREN bool_expr R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 268


state 252

   87 condition_st: IF L_PAREN bool_expr R_PAREN compound_st ELSE . compound_st

    L_BRACE  shift, and go to state 122

    compound_st    go to state 269
    compound_list  go to state 124


state 253

  138 for_single_entry: symbol_id array_indice ASSIGN init_array .

    $default  reduce using rule 138 (for_single_entry)


state 254

   95 expr: expr . OR expr
   96     | expr . AND expr
   97     | expr . NOT expr
   98     | expr . LESS expr
   99     | expr . LESS_EQ expr
  100     | expr . EQUAL expr
  101     | expr . GREAT_EQ expr
  102     | expr . GREAT expr
  103     | expr . NOT_EQ expr
  104     | expr . PLUS expr
  105     | expr . MINUS expr
  106     | expr . MULTIPLY expr
  107     | expr . DIVIDE expr
  108     | expr . MOD expr
  135 for_control_entry: symbol_id ASSIGN expr .

    OR        shift, and go to state 103
    AND       shift, and go to state 104
    NOT       shift, and go to state 105
    NOT_EQ    shift, and go to state 106
    GREAT     shift, and go to state 107
    GREAT_EQ  shift, and go to state 108
    EQUAL     shift, and go to state 109
    LESS_EQ   shift, and go to state 110
    LESS      shift, and go to state 111
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    $default  reduce using rule 135 (for_control_entry)


state 255

  136 for_control_entry: symbol_id array_indice ASSIGN . init_array

    L_BRACE  shift, and go to state 118

    init_array  go to state 270
    expr_list   go to state 120


state 256

   95 expr: expr . OR expr
   95     | expr OR expr .
   96     | expr . AND expr
   97     | expr . NOT expr
   98     | expr . LESS expr
   99     | expr . LESS_EQ expr
  100     | expr . EQUAL expr
  101     | expr . GREAT_EQ expr
  102     | expr . GREAT expr
  103     | expr . NOT_EQ expr
  104     | expr . PLUS expr
  105     | expr . MINUS expr
  106     | expr . MULTIPLY expr
  107     | expr . DIVIDE expr
  108     | expr . MOD expr
  126 for_control_entry: expr OR expr .

    AND       shift, and go to state 104
    NOT       shift, and go to state 105
    NOT_EQ    shift, and go to state 106
    GREAT     shift, and go to state 107
    GREAT_EQ  shift, and go to state 108
    EQUAL     shift, and go to state 109
    LESS_EQ   shift, and go to state 110
    LESS      shift, and go to state 111
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    OR        reduce using rule 95 (expr)
    NOT       [reduce using rule 95 (expr)]
    $default  reduce using rule 126 (for_control_entry)


state 257

   95 expr: expr . OR expr
   96     | expr . AND expr
   96     | expr AND expr .
   97     | expr . NOT expr
   98     | expr . LESS expr
   99     | expr . LESS_EQ expr
  100     | expr . EQUAL expr
  101     | expr . GREAT_EQ expr
  102     | expr . GREAT expr
  103     | expr . NOT_EQ expr
  104     | expr . PLUS expr
  105     | expr . MINUS expr
  106     | expr . MULTIPLY expr
  107     | expr . DIVIDE expr
  108     | expr . MOD expr
  127 for_control_entry: expr AND expr .

    NOT       shift, and go to state 105
    NOT_EQ    shift, and go to state 106
    GREAT     shift, and go to state 107
    GREAT_EQ  shift, and go to state 108
    EQUAL     shift, and go to state 109
    LESS_EQ   shift, and go to state 110
    LESS      shift, and go to state 111
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    NOT        [reduce using rule 96 (expr)]
    SEMICOLON  reduce using rule 127 (for_control_entry)
    COMMA      reduce using rule 127 (for_control_entry)
    $default   reduce using rule 96 (expr)


state 258

   95 expr: expr . OR expr
   96     | expr . AND expr
   97     | expr . NOT expr
   97     | expr NOT expr .
   98     | expr . LESS expr
   99     | expr . LESS_EQ expr
  100     | expr . EQUAL expr
  101     | expr . GREAT_EQ expr
  102     | expr . GREAT expr
  103     | expr . NOT_EQ expr
  104     | expr . PLUS expr
  105     | expr . MINUS expr
  106     | expr . MULTIPLY expr
  107     | expr . DIVIDE expr
  108     | expr . MOD expr
  128 for_control_entry: expr NOT expr .

    OR        shift, and go to state 103
    AND       shift, and go to state 104
    NOT       shift, and go to state 105
    NOT_EQ    shift, and go to state 106
    GREAT     shift, and go to state 107
    GREAT_EQ  shift, and go to state 108
    EQUAL     shift, and go to state 109
    LESS_EQ   shift, and go to state 110
    LESS      shift, and go to state 111
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    OR        [reduce using rule 97 (expr)]
    AND       [reduce using rule 97 (expr)]
    NOT       [reduce using rule 97 (expr)]
    NOT_EQ    [reduce using rule 97 (expr)]
    GREAT     [reduce using rule 97 (expr)]
    GREAT_EQ  [reduce using rule 97 (expr)]
    EQUAL     [reduce using rule 97 (expr)]
    LESS_EQ   [reduce using rule 97 (expr)]
    LESS      [reduce using rule 97 (expr)]
    MINUS     [reduce using rule 97 (expr)]
    PLUS      [reduce using rule 97 (expr)]
    MOD       [reduce using rule 97 (expr)]
    DIVIDE    [reduce using rule 97 (expr)]
    MULTIPLY  [reduce using rule 97 (expr)]
    $default  reduce using rule 128 (for_control_entry)


state 259

   95 expr: expr . OR expr
   96     | expr . AND expr
   97     | expr . NOT expr
   98     | expr . LESS expr
   99     | expr . LESS_EQ expr
  100     | expr . EQUAL expr
  101     | expr . GREAT_EQ expr
  102     | expr . GREAT expr
  103     | expr . NOT_EQ expr
  103     | expr NOT_EQ expr .
  104     | expr . PLUS expr
  105     | expr . MINUS expr
  106     | expr . MULTIPLY expr
  107     | expr . DIVIDE expr
  108     | expr . MOD expr
  134 for_control_entry: expr NOT_EQ expr .

    NOT       shift, and go to state 105
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    NOT        [reduce using rule 103 (expr)]
    SEMICOLON  reduce using rule 134 (for_control_entry)
    COMMA      reduce using rule 134 (for_control_entry)
    $default   reduce using rule 103 (expr)


state 260

   95 expr: expr . OR expr
   96     | expr . AND expr
   97     | expr . NOT expr
   98     | expr . LESS expr
   99     | expr . LESS_EQ expr
  100     | expr . EQUAL expr
  101     | expr . GREAT_EQ expr
  102     | expr . GREAT expr
  102     | expr GREAT expr .
  103     | expr . NOT_EQ expr
  104     | expr . PLUS expr
  105     | expr . MINUS expr
  106     | expr . MULTIPLY expr
  107     | expr . DIVIDE expr
  108     | expr . MOD expr
  133 for_control_entry: expr GREAT expr .

    NOT       shift, and go to state 105
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    NOT        [reduce using rule 102 (expr)]
    SEMICOLON  reduce using rule 133 (for_control_entry)
    COMMA      reduce using rule 133 (for_control_entry)
    $default   reduce using rule 102 (expr)


state 261

   95 expr: expr . OR expr
   96     | expr . AND expr
   97     | expr . NOT expr
   98     | expr . LESS expr
   99     | expr . LESS_EQ expr
  100     | expr . EQUAL expr
  101     | expr . GREAT_EQ expr
  101     | expr GREAT_EQ expr .
  102     | expr . GREAT expr
  103     | expr . NOT_EQ expr
  104     | expr . PLUS expr
  105     | expr . MINUS expr
  106     | expr . MULTIPLY expr
  107     | expr . DIVIDE expr
  108     | expr . MOD expr
  132 for_control_entry: expr GREAT_EQ expr .

    NOT       shift, and go to state 105
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    NOT        [reduce using rule 101 (expr)]
    SEMICOLON  reduce using rule 132 (for_control_entry)
    COMMA      reduce using rule 132 (for_control_entry)
    $default   reduce using rule 101 (expr)


state 262

   95 expr: expr . OR expr
   96     | expr . AND expr
   97     | expr . NOT expr
   98     | expr . LESS expr
   99     | expr . LESS_EQ expr
  100     | expr . EQUAL expr
  100     | expr EQUAL expr .
  101     | expr . GREAT_EQ expr
  102     | expr . GREAT expr
  103     | expr . NOT_EQ expr
  104     | expr . PLUS expr
  105     | expr . MINUS expr
  106     | expr . MULTIPLY expr
  107     | expr . DIVIDE expr
  108     | expr . MOD expr
  131 for_control_entry: expr EQUAL expr .

    NOT       shift, and go to state 105
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    NOT        [reduce using rule 100 (expr)]
    SEMICOLON  reduce using rule 131 (for_control_entry)
    COMMA      reduce using rule 131 (for_control_entry)
    $default   reduce using rule 100 (expr)


state 263

   95 expr: expr . OR expr
   96     | expr . AND expr
   97     | expr . NOT expr
   98     | expr . LESS expr
   99     | expr . LESS_EQ expr
   99     | expr LESS_EQ expr .
  100     | expr . EQUAL expr
  101     | expr . GREAT_EQ expr
  102     | expr . GREAT expr
  103     | expr . NOT_EQ expr
  104     | expr . PLUS expr
  105     | expr . MINUS expr
  106     | expr . MULTIPLY expr
  107     | expr . DIVIDE expr
  108     | expr . MOD expr
  130 for_control_entry: expr LESS_EQ expr .

    NOT       shift, and go to state 105
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    NOT        [reduce using rule 99 (expr)]
    SEMICOLON  reduce using rule 130 (for_control_entry)
    COMMA      reduce using rule 130 (for_control_entry)
    $default   reduce using rule 99 (expr)


state 264

   95 expr: expr . OR expr
   96     | expr . AND expr
   97     | expr . NOT expr
   98     | expr . LESS expr
   98     | expr LESS expr .
   99     | expr . LESS_EQ expr
  100     | expr . EQUAL expr
  101     | expr . GREAT_EQ expr
  102     | expr . GREAT expr
  103     | expr . NOT_EQ expr
  104     | expr . PLUS expr
  105     | expr . MINUS expr
  106     | expr . MULTIPLY expr
  107     | expr . DIVIDE expr
  108     | expr . MOD expr
  129 for_control_entry: expr LESS expr .

    NOT       shift, and go to state 105
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    NOT        [reduce using rule 98 (expr)]
    SEMICOLON  reduce using rule 129 (for_control_entry)
    COMMA      reduce using rule 129 (for_control_entry)
    $default   reduce using rule 98 (expr)


state 265

  124 nonEmpty_for_control: nonEmpty_for_control COMMA for_control_entry .

    $default  reduce using rule 124 (nonEmpty_for_control)


state 266

  120 nonEmpty_for_incre: nonEmpty_for_incre COMMA . for_single_entry

    L_PAREN          shift, and go to state 77
    MINUS            shift, and go to state 78
    ID               shift, and go to state 21
    CONS_INTEGER     shift, and go to state 69
    CONS_FLOAT       shift, and go to state 70
    CONS_SCIENTIFIC  shift, and go to state 71
    CONS_STRING      shift, and go to state 72
    CONS_BOOL        shift, and go to state 73

    symbol_id         go to state 203
    literal_constant  go to state 80
    var_ref           go to state 81
    expr              go to state 204
    for_single_entry  go to state 271
    funct_invoc       go to state 207


state 267

  113 for_st: FOR for_init for_control for_incre R_PAREN compound_st .

    $default  reduce using rule 113 (for_st)


state 268

   90 while_st: DO compound_st WHILE L_PAREN bool_expr R_PAREN SEMICOLON .

    $default  reduce using rule 90 (while_st)


state 269

   87 condition_st: IF L_PAREN bool_expr R_PAREN compound_st ELSE compound_st .

    $default  reduce using rule 87 (condition_st)


state 270

  136 for_control_entry: symbol_id array_indice ASSIGN init_array .

    $default  reduce using rule 136 (for_control_entry)


state 271

  120 nonEmpty_for_incre: nonEmpty_for_incre COMMA for_single_entry .

    $default  reduce using rule 120 (nonEmpty_for_incre)
