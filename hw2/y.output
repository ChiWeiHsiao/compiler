State 12 conflicts: 8 shift/reduce
State 14 conflicts: 8 shift/reduce
State 15 conflicts: 8 shift/reduce
State 16 conflicts: 8 shift/reduce
State 17 conflicts: 8 shift/reduce
State 25 conflicts: 8 shift/reduce
State 34 conflicts: 8 shift/reduce
State 89 conflicts: 13 shift/reduce
State 173 conflicts: 1 shift/reduce
State 231 conflicts: 1 shift/reduce
State 234 conflicts: 3 reduce/reduce


Grammar

    0 $accept: program $end

    1 program: decl_and_def_list

    2 decl_and_def_list: decl_and_def_list declaration_list
    3                  | declaration_list decl_and_def_list
    4                  | definition_list
    5                  | definition_list decl_and_def_list

    6 declaration_list: const_decl declaration_list
    7                 | var_decl declaration_list
    8                 | funct_decl declaration_list
    9                 | proc_decl declaration_list
   10                 | const_decl
   11                 | var_decl
   12                 | funct_decl
   13                 | proc_decl

   14 var_decl: type var_list SEMICOLON

   15 type: INT
   16     | DOUBLE
   17     | FLOAT
   18     | STRING
   19     | BOOL
   20     | BOOLEAN

   21 identifier: symbol_id
   22           | symbol_id array_indice

   23 symbol_id: ID

   24 array_indice: array_indice L_BRACKET CONS_INTEGER R_BRACKET
   25             | L_BRACKET CONS_INTEGER R_BRACKET

   26 var_list: var_list COMMA var_single
   27         | var_single

   28 var_single: identifier
   29           | symbol_id ASSIGN expr
   30           | symbol_id array_indice ASSIGN init_array

   31 init_array: init_arr_list R_BRACE

   32 init_arr_list: L_BRACE nonEmpty_init_arr_list
   33              | L_BRACE

   34 nonEmpty_init_arr_list: nonEmpty_init_arr_list COMMA expr
   35                       | expr

   36 const_decl: CONST type const_list SEMICOLON

   37 const_list: const_init COMMA const_list
   38           | const_init

   39 const_init: symbol_id ASSIGN literal_constant

   40 literal_constant: CONS_INTEGER
   41                 | CONS_FLOAT
   42                 | CONS_SCIENTIFIC
   43                 | CONS_STRING
   44                 | CONS_BOOL

   45 funct_decl: type symbol_id arg_list R_PAREN SEMICOLON

   46 proc_decl: VOID symbol_id arg_list R_PAREN SEMICOLON

   47 definition_list: type symbol_id arg_list R_PAREN compound_st definition_list
   48                | VOID symbol_id arg_list R_PAREN compound_st definition_list
   49                | type symbol_id arg_list R_PAREN compound_st
   50                | VOID symbol_id arg_list R_PAREN compound_st

   51 arg_list: L_PAREN nonEmpty_arg_list
   52         | L_PAREN

   53 nonEmpty_arg_list: arg COMMA nonEmpty_arg_list
   54                  | arg

   55 arg: type identifier

   56 compound_st: compound_list R_BRACE

   57 compound_list: L_BRACE nonEmpty_compound_list
   58              | L_BRACE

   59 nonEmpty_compound_list: var_decl nonEmpty_compound_list
   60                       | const_decl nonEmpty_compound_list
   61                       | statement nonEmpty_compound_list
   62                       | var_decl
   63                       | const_decl
   64                       | statement

   65 statement: compound_st
   66          | simple_st
   67          | condition_st
   68          | while_st
   69          | for_st
   70          | jump_st
   71          | funct_invoc_st

   72 simple_st: var_ref ASSIGN expr SEMICOLON
   73          | PRINT var_ref SEMICOLON
   74          | PRINT expr SEMICOLON
   75          | READ var_ref SEMICOLON

   76 var_ref: symbol_id
   77        | symbol_id arr_ref_indice

   78 arr_ref_indice: arr_ref_index arr_ref_indice
   79               | arr_ref_index

   80 arr_ref_index: L_BRACKET expr R_BRACKET

   81 condition_st: IF L_PAREN bool_expr R_PAREN compound_st
   82             | IF L_PAREN bool_expr R_PAREN compound_st ELSE compound_st

   83 bool_expr: expr

   84 while_st: WHILE L_PAREN bool_expr R_PAREN compound_st
   85         | DO compound_st WHILE L_PAREN bool_expr R_PAREN SEMICOLON

   86 jump_st: RETURN expr SEMICOLON
   87        | BREAK SEMICOLON
   88        | CONTINUE SEMICOLON

   89 expr: L_PAREN expr R_PAREN
   90     | expr OR expr
   91     | expr AND expr
   92     | NOT expr
   93     | expr LESS expr
   94     | expr LESS_EQ expr
   95     | expr EQUAL expr
   96     | expr GREAT_EQ expr
   97     | expr GREAT expr
   98     | expr NOT_EQ expr
   99     | expr PLUS expr
  100     | expr MINUS expr
  101     | expr MULTIPLY expr
  102     | expr DIVIDE expr
  103     | expr MOD expr
  104     | MINUS expr
  105     | literal_constant
  106     | var_ref
  107     | funct_invoc_ref

  108 for_st: FOR for_init for_control for_incre R_PAREN compound_st

  109 for_init: L_PAREN nonEmpty_for_init
  110         | L_PAREN

  111 nonEmpty_for_init: nonEmpty_for_init COMMA for_single_entry
  112                  | for_single_entry

  113 for_incre: SEMICOLON nonEmpty_for_incre
  114          | SEMICOLON

  115 nonEmpty_for_incre: nonEmpty_for_incre COMMA for_single_entry
  116                   | for_single_entry

  117 for_control: SEMICOLON nonEmpty_for_control
  118            | SEMICOLON

  119 nonEmpty_for_control: nonEmpty_for_control COMMA for_control_entry
  120                     | for_control_entry

  121 for_control_entry: expr
  122                  | symbol_id ASSIGN expr
  123                  | symbol_id array_indice ASSIGN init_array

  124 for_single_entry: symbol_id ASSIGN expr
  125                 | symbol_id array_indice ASSIGN init_array
  126                 | expr
  127                 | symbol_id funct_invoc_list R_PAREN

  128 funct_invoc_ref: symbol_id funct_invoc_list R_PAREN

  129 funct_invoc_st: symbol_id funct_invoc_list R_PAREN SEMICOLON

  130 funct_invoc_list: L_PAREN
  131                 | L_PAREN nonEmpty_funct_invoc_list

  132 nonEmpty_funct_invoc_list: nonEmpty_funct_invoc_list COMMA expr
  133                          | expr


Terminals, with rules where they appear

$end (0) 0
error (256)
VOID (258) 46 48 50
CONST (259) 36
STRING (260) 18
DOUBLE (261) 16
FLOAT (262) 17
BOOL (263) 19
INT (264) 15
BOOLEAN (265) 20
L_PAREN (266) 51 52 81 82 84 85 89 109 110 130 131
R_PAREN (267) 45 46 47 48 49 50 81 82 84 85 89 108 127 128 129
L_BRACKET (268) 24 25 80
R_BRACKET (269) 24 25 80
L_BRACE (270) 32 33 57 58
R_BRACE (271) 31 56
OR (272) 90
AND (273) 91
NOT (274) 92
NOT_EQ (275) 98
GREAT (276) 97
GREAT_EQ (277) 96
EQUAL (278) 95
LESS_EQ (279) 94
LESS (280) 93
MINUS (281) 100 104
PLUS (282) 99
MOD (283) 103
DIVIDE (284) 102
MULTIPLY (285) 101
ASSIGN (286) 29 30 39 72 122 123 124 125
WHILE (287) 84 85
DO (288) 85
IF (289) 81 82
ELSE (290) 82
FOR (291) 108
PRINT (292) 73 74
READ (293) 75
CONTINUE (294) 88
BREAK (295) 87
RETURN (296) 86
ID (297) 23
SEMICOLON (298) 14 36 45 46 72 73 74 75 85 86 87 88 113 114 117 118
    129
COMMA (299) 26 34 37 53 111 115 119 132
CONS_INTEGER (300) 24 25 40
CONS_FLOAT (301) 41
CONS_SCIENTIFIC (302) 42
CONS_STRING (303) 43
CONS_BOOL (304) 44


Nonterminals, with rules where they appear

$accept (50)
    on left: 0
program (51)
    on left: 1, on right: 0
decl_and_def_list (52)
    on left: 2 3 4 5, on right: 1 2 3 5
declaration_list (53)
    on left: 6 7 8 9 10 11 12 13, on right: 2 3 6 7 8 9
var_decl (54)
    on left: 14, on right: 7 11 59 62
type (55)
    on left: 15 16 17 18 19 20, on right: 14 36 45 47 49 55
identifier (56)
    on left: 21 22, on right: 28 55
symbol_id (57)
    on left: 23, on right: 21 22 29 30 39 45 46 47 48 49 50 76 77 122
    123 124 125 127 128 129
array_indice (58)
    on left: 24 25, on right: 22 24 30 123 125
var_list (59)
    on left: 26 27, on right: 14 26
var_single (60)
    on left: 28 29 30, on right: 26 27
init_array (61)
    on left: 31, on right: 30 123 125
init_arr_list (62)
    on left: 32 33, on right: 31
nonEmpty_init_arr_list (63)
    on left: 34 35, on right: 32 34
const_decl (64)
    on left: 36, on right: 6 10 60 63
const_list (65)
    on left: 37 38, on right: 36 37
const_init (66)
    on left: 39, on right: 37 38
literal_constant (67)
    on left: 40 41 42 43 44, on right: 39 105
funct_decl (68)
    on left: 45, on right: 8 12
proc_decl (69)
    on left: 46, on right: 9 13
definition_list (70)
    on left: 47 48 49 50, on right: 4 5 47 48
arg_list (71)
    on left: 51 52, on right: 45 46 47 48 49 50
nonEmpty_arg_list (72)
    on left: 53 54, on right: 51 53
arg (73)
    on left: 55, on right: 53 54
compound_st (74)
    on left: 56, on right: 47 48 49 50 65 81 82 84 85 108
compound_list (75)
    on left: 57 58, on right: 56
nonEmpty_compound_list (76)
    on left: 59 60 61 62 63 64, on right: 57 59 60 61
statement (77)
    on left: 65 66 67 68 69 70 71, on right: 61 64
simple_st (78)
    on left: 72 73 74 75, on right: 66
var_ref (79)
    on left: 76 77, on right: 72 73 75 106
arr_ref_indice (80)
    on left: 78 79, on right: 77 78
arr_ref_index (81)
    on left: 80, on right: 78 79
condition_st (82)
    on left: 81 82, on right: 67
bool_expr (83)
    on left: 83, on right: 81 82 84 85
while_st (84)
    on left: 84 85, on right: 68
jump_st (85)
    on left: 86 87 88, on right: 70
expr (86)
    on left: 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105
    106 107, on right: 29 34 35 72 74 80 83 86 89 90 91 92 93 94 95
    96 97 98 99 100 101 102 103 104 121 122 124 126 132 133
for_st (87)
    on left: 108, on right: 69
for_init (88)
    on left: 109 110, on right: 108
nonEmpty_for_init (89)
    on left: 111 112, on right: 109 111
for_incre (90)
    on left: 113 114, on right: 108
nonEmpty_for_incre (91)
    on left: 115 116, on right: 113 115
for_control (92)
    on left: 117 118, on right: 108
nonEmpty_for_control (93)
    on left: 119 120, on right: 117 119
for_control_entry (94)
    on left: 121 122 123, on right: 119 120
for_single_entry (95)
    on left: 124 125 126 127, on right: 111 112 115 116
funct_invoc_ref (96)
    on left: 128, on right: 107
funct_invoc_st (97)
    on left: 129, on right: 71
funct_invoc_list (98)
    on left: 130 131, on right: 127 128 129
nonEmpty_funct_invoc_list (99)
    on left: 132 133, on right: 131 132


state 0

    0 $accept: . program $end

    VOID     shift, and go to state 1
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    program            go to state 9
    decl_and_def_list  go to state 10
    declaration_list   go to state 11
    var_decl           go to state 12
    type               go to state 13
    const_decl         go to state 14
    funct_decl         go to state 15
    proc_decl          go to state 16
    definition_list    go to state 17


state 1

   46 proc_decl: VOID . symbol_id arg_list R_PAREN SEMICOLON
   48 definition_list: VOID . symbol_id arg_list R_PAREN compound_st definition_list
   50                | VOID . symbol_id arg_list R_PAREN compound_st

    ID  shift, and go to state 18

    symbol_id  go to state 19


state 2

   36 const_decl: CONST . type const_list SEMICOLON

    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    type  go to state 20


state 3

   18 type: STRING .

    $default  reduce using rule 18 (type)


state 4

   16 type: DOUBLE .

    $default  reduce using rule 16 (type)


state 5

   17 type: FLOAT .

    $default  reduce using rule 17 (type)


state 6

   19 type: BOOL .

    $default  reduce using rule 19 (type)


state 7

   15 type: INT .

    $default  reduce using rule 15 (type)


state 8

   20 type: BOOLEAN .

    $default  reduce using rule 20 (type)


state 9

    0 $accept: program . $end

    $end  shift, and go to state 21


state 10

    1 program: decl_and_def_list .
    2 decl_and_def_list: decl_and_def_list . declaration_list

    VOID     shift, and go to state 22
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    $default  reduce using rule 1 (program)

    declaration_list  go to state 23
    var_decl          go to state 12
    type              go to state 24
    const_decl        go to state 14
    funct_decl        go to state 15
    proc_decl         go to state 16


state 11

    3 decl_and_def_list: declaration_list . decl_and_def_list

    VOID     shift, and go to state 1
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    decl_and_def_list  go to state 25
    declaration_list   go to state 11
    var_decl           go to state 12
    type               go to state 13
    const_decl         go to state 14
    funct_decl         go to state 15
    proc_decl          go to state 16
    definition_list    go to state 17


state 12

    7 declaration_list: var_decl . declaration_list
   11                 | var_decl .

    VOID     shift, and go to state 22
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    VOID      [reduce using rule 11 (declaration_list)]
    CONST     [reduce using rule 11 (declaration_list)]
    STRING    [reduce using rule 11 (declaration_list)]
    DOUBLE    [reduce using rule 11 (declaration_list)]
    FLOAT     [reduce using rule 11 (declaration_list)]
    BOOL      [reduce using rule 11 (declaration_list)]
    INT       [reduce using rule 11 (declaration_list)]
    BOOLEAN   [reduce using rule 11 (declaration_list)]
    $default  reduce using rule 11 (declaration_list)

    declaration_list  go to state 26
    var_decl          go to state 12
    type              go to state 24
    const_decl        go to state 14
    funct_decl        go to state 15
    proc_decl         go to state 16


state 13

   14 var_decl: type . var_list SEMICOLON
   45 funct_decl: type . symbol_id arg_list R_PAREN SEMICOLON
   47 definition_list: type . symbol_id arg_list R_PAREN compound_st definition_list
   49                | type . symbol_id arg_list R_PAREN compound_st

    ID  shift, and go to state 18

    identifier  go to state 27
    symbol_id   go to state 28
    var_list    go to state 29
    var_single  go to state 30


state 14

    6 declaration_list: const_decl . declaration_list
   10                 | const_decl .

    VOID     shift, and go to state 22
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    VOID      [reduce using rule 10 (declaration_list)]
    CONST     [reduce using rule 10 (declaration_list)]
    STRING    [reduce using rule 10 (declaration_list)]
    DOUBLE    [reduce using rule 10 (declaration_list)]
    FLOAT     [reduce using rule 10 (declaration_list)]
    BOOL      [reduce using rule 10 (declaration_list)]
    INT       [reduce using rule 10 (declaration_list)]
    BOOLEAN   [reduce using rule 10 (declaration_list)]
    $default  reduce using rule 10 (declaration_list)

    declaration_list  go to state 31
    var_decl          go to state 12
    type              go to state 24
    const_decl        go to state 14
    funct_decl        go to state 15
    proc_decl         go to state 16


state 15

    8 declaration_list: funct_decl . declaration_list
   12                 | funct_decl .

    VOID     shift, and go to state 22
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    VOID      [reduce using rule 12 (declaration_list)]
    CONST     [reduce using rule 12 (declaration_list)]
    STRING    [reduce using rule 12 (declaration_list)]
    DOUBLE    [reduce using rule 12 (declaration_list)]
    FLOAT     [reduce using rule 12 (declaration_list)]
    BOOL      [reduce using rule 12 (declaration_list)]
    INT       [reduce using rule 12 (declaration_list)]
    BOOLEAN   [reduce using rule 12 (declaration_list)]
    $default  reduce using rule 12 (declaration_list)

    declaration_list  go to state 32
    var_decl          go to state 12
    type              go to state 24
    const_decl        go to state 14
    funct_decl        go to state 15
    proc_decl         go to state 16


state 16

    9 declaration_list: proc_decl . declaration_list
   13                 | proc_decl .

    VOID     shift, and go to state 22
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    VOID      [reduce using rule 13 (declaration_list)]
    CONST     [reduce using rule 13 (declaration_list)]
    STRING    [reduce using rule 13 (declaration_list)]
    DOUBLE    [reduce using rule 13 (declaration_list)]
    FLOAT     [reduce using rule 13 (declaration_list)]
    BOOL      [reduce using rule 13 (declaration_list)]
    INT       [reduce using rule 13 (declaration_list)]
    BOOLEAN   [reduce using rule 13 (declaration_list)]
    $default  reduce using rule 13 (declaration_list)

    declaration_list  go to state 33
    var_decl          go to state 12
    type              go to state 24
    const_decl        go to state 14
    funct_decl        go to state 15
    proc_decl         go to state 16


state 17

    4 decl_and_def_list: definition_list .
    5                  | definition_list . decl_and_def_list

    VOID     shift, and go to state 1
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    VOID      [reduce using rule 4 (decl_and_def_list)]
    CONST     [reduce using rule 4 (decl_and_def_list)]
    STRING    [reduce using rule 4 (decl_and_def_list)]
    DOUBLE    [reduce using rule 4 (decl_and_def_list)]
    FLOAT     [reduce using rule 4 (decl_and_def_list)]
    BOOL      [reduce using rule 4 (decl_and_def_list)]
    INT       [reduce using rule 4 (decl_and_def_list)]
    BOOLEAN   [reduce using rule 4 (decl_and_def_list)]
    $default  reduce using rule 4 (decl_and_def_list)

    decl_and_def_list  go to state 34
    declaration_list   go to state 11
    var_decl           go to state 12
    type               go to state 13
    const_decl         go to state 14
    funct_decl         go to state 15
    proc_decl          go to state 16
    definition_list    go to state 17


state 18

   23 symbol_id: ID .

    $default  reduce using rule 23 (symbol_id)


state 19

   46 proc_decl: VOID symbol_id . arg_list R_PAREN SEMICOLON
   48 definition_list: VOID symbol_id . arg_list R_PAREN compound_st definition_list
   50                | VOID symbol_id . arg_list R_PAREN compound_st

    L_PAREN  shift, and go to state 35

    arg_list  go to state 36


state 20

   36 const_decl: CONST type . const_list SEMICOLON

    ID  shift, and go to state 18

    symbol_id   go to state 37
    const_list  go to state 38
    const_init  go to state 39


state 21

    0 $accept: program $end .

    $default  accept


state 22

   46 proc_decl: VOID . symbol_id arg_list R_PAREN SEMICOLON

    ID  shift, and go to state 18

    symbol_id  go to state 40


state 23

    2 decl_and_def_list: decl_and_def_list declaration_list .

    $default  reduce using rule 2 (decl_and_def_list)


state 24

   14 var_decl: type . var_list SEMICOLON
   45 funct_decl: type . symbol_id arg_list R_PAREN SEMICOLON

    ID  shift, and go to state 18

    identifier  go to state 27
    symbol_id   go to state 41
    var_list    go to state 29
    var_single  go to state 30


state 25

    2 decl_and_def_list: decl_and_def_list . declaration_list
    3                  | declaration_list decl_and_def_list .

    VOID     shift, and go to state 22
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    VOID      [reduce using rule 3 (decl_and_def_list)]
    CONST     [reduce using rule 3 (decl_and_def_list)]
    STRING    [reduce using rule 3 (decl_and_def_list)]
    DOUBLE    [reduce using rule 3 (decl_and_def_list)]
    FLOAT     [reduce using rule 3 (decl_and_def_list)]
    BOOL      [reduce using rule 3 (decl_and_def_list)]
    INT       [reduce using rule 3 (decl_and_def_list)]
    BOOLEAN   [reduce using rule 3 (decl_and_def_list)]
    $default  reduce using rule 3 (decl_and_def_list)

    declaration_list  go to state 23
    var_decl          go to state 12
    type              go to state 24
    const_decl        go to state 14
    funct_decl        go to state 15
    proc_decl         go to state 16


state 26

    7 declaration_list: var_decl declaration_list .

    $default  reduce using rule 7 (declaration_list)


state 27

   28 var_single: identifier .

    $default  reduce using rule 28 (var_single)


state 28

   21 identifier: symbol_id .
   22           | symbol_id . array_indice
   29 var_single: symbol_id . ASSIGN expr
   30           | symbol_id . array_indice ASSIGN init_array
   45 funct_decl: type symbol_id . arg_list R_PAREN SEMICOLON
   47 definition_list: type symbol_id . arg_list R_PAREN compound_st definition_list
   49                | type symbol_id . arg_list R_PAREN compound_st

    L_PAREN    shift, and go to state 35
    L_BRACKET  shift, and go to state 42
    ASSIGN     shift, and go to state 43

    $default  reduce using rule 21 (identifier)

    array_indice  go to state 44
    arg_list      go to state 45


state 29

   14 var_decl: type var_list . SEMICOLON
   26 var_list: var_list . COMMA var_single

    SEMICOLON  shift, and go to state 46
    COMMA      shift, and go to state 47


state 30

   27 var_list: var_single .

    $default  reduce using rule 27 (var_list)


state 31

    6 declaration_list: const_decl declaration_list .

    $default  reduce using rule 6 (declaration_list)


state 32

    8 declaration_list: funct_decl declaration_list .

    $default  reduce using rule 8 (declaration_list)


state 33

    9 declaration_list: proc_decl declaration_list .

    $default  reduce using rule 9 (declaration_list)


state 34

    2 decl_and_def_list: decl_and_def_list . declaration_list
    5                  | definition_list decl_and_def_list .

    VOID     shift, and go to state 22
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    VOID      [reduce using rule 5 (decl_and_def_list)]
    CONST     [reduce using rule 5 (decl_and_def_list)]
    STRING    [reduce using rule 5 (decl_and_def_list)]
    DOUBLE    [reduce using rule 5 (decl_and_def_list)]
    FLOAT     [reduce using rule 5 (decl_and_def_list)]
    BOOL      [reduce using rule 5 (decl_and_def_list)]
    INT       [reduce using rule 5 (decl_and_def_list)]
    BOOLEAN   [reduce using rule 5 (decl_and_def_list)]
    $default  reduce using rule 5 (decl_and_def_list)

    declaration_list  go to state 23
    var_decl          go to state 12
    type              go to state 24
    const_decl        go to state 14
    funct_decl        go to state 15
    proc_decl         go to state 16


state 35

   51 arg_list: L_PAREN . nonEmpty_arg_list
   52         | L_PAREN .

    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    $default  reduce using rule 52 (arg_list)

    type               go to state 48
    nonEmpty_arg_list  go to state 49
    arg                go to state 50


state 36

   46 proc_decl: VOID symbol_id arg_list . R_PAREN SEMICOLON
   48 definition_list: VOID symbol_id arg_list . R_PAREN compound_st definition_list
   50                | VOID symbol_id arg_list . R_PAREN compound_st

    R_PAREN  shift, and go to state 51


state 37

   39 const_init: symbol_id . ASSIGN literal_constant

    ASSIGN  shift, and go to state 52


state 38

   36 const_decl: CONST type const_list . SEMICOLON

    SEMICOLON  shift, and go to state 53


state 39

   37 const_list: const_init . COMMA const_list
   38           | const_init .

    COMMA  shift, and go to state 54

    $default  reduce using rule 38 (const_list)


state 40

   46 proc_decl: VOID symbol_id . arg_list R_PAREN SEMICOLON

    L_PAREN  shift, and go to state 35

    arg_list  go to state 55


state 41

   21 identifier: symbol_id .
   22           | symbol_id . array_indice
   29 var_single: symbol_id . ASSIGN expr
   30           | symbol_id . array_indice ASSIGN init_array
   45 funct_decl: type symbol_id . arg_list R_PAREN SEMICOLON

    L_PAREN    shift, and go to state 35
    L_BRACKET  shift, and go to state 42
    ASSIGN     shift, and go to state 43

    $default  reduce using rule 21 (identifier)

    array_indice  go to state 44
    arg_list      go to state 56


state 42

   25 array_indice: L_BRACKET . CONS_INTEGER R_BRACKET

    CONS_INTEGER  shift, and go to state 57


state 43

   29 var_single: symbol_id ASSIGN . expr

    L_PAREN          shift, and go to state 58
    NOT              shift, and go to state 59
    MINUS            shift, and go to state 60
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 61
    CONS_FLOAT       shift, and go to state 62
    CONS_SCIENTIFIC  shift, and go to state 63
    CONS_STRING      shift, and go to state 64
    CONS_BOOL        shift, and go to state 65

    symbol_id         go to state 66
    literal_constant  go to state 67
    var_ref           go to state 68
    expr              go to state 69
    funct_invoc_ref   go to state 70


state 44

   22 identifier: symbol_id array_indice .
   24 array_indice: array_indice . L_BRACKET CONS_INTEGER R_BRACKET
   30 var_single: symbol_id array_indice . ASSIGN init_array

    L_BRACKET  shift, and go to state 71
    ASSIGN     shift, and go to state 72

    $default  reduce using rule 22 (identifier)


state 45

   45 funct_decl: type symbol_id arg_list . R_PAREN SEMICOLON
   47 definition_list: type symbol_id arg_list . R_PAREN compound_st definition_list
   49                | type symbol_id arg_list . R_PAREN compound_st

    R_PAREN  shift, and go to state 73


state 46

   14 var_decl: type var_list SEMICOLON .

    $default  reduce using rule 14 (var_decl)


state 47

   26 var_list: var_list COMMA . var_single

    ID  shift, and go to state 18

    identifier  go to state 27
    symbol_id   go to state 74
    var_single  go to state 75


state 48

   55 arg: type . identifier

    ID  shift, and go to state 18

    identifier  go to state 76
    symbol_id   go to state 77


state 49

   51 arg_list: L_PAREN nonEmpty_arg_list .

    $default  reduce using rule 51 (arg_list)


state 50

   53 nonEmpty_arg_list: arg . COMMA nonEmpty_arg_list
   54                  | arg .

    COMMA  shift, and go to state 78

    $default  reduce using rule 54 (nonEmpty_arg_list)


state 51

   46 proc_decl: VOID symbol_id arg_list R_PAREN . SEMICOLON
   48 definition_list: VOID symbol_id arg_list R_PAREN . compound_st definition_list
   50                | VOID symbol_id arg_list R_PAREN . compound_st

    L_BRACE    shift, and go to state 79
    SEMICOLON  shift, and go to state 80

    compound_st    go to state 81
    compound_list  go to state 82


state 52

   39 const_init: symbol_id ASSIGN . literal_constant

    CONS_INTEGER     shift, and go to state 61
    CONS_FLOAT       shift, and go to state 62
    CONS_SCIENTIFIC  shift, and go to state 63
    CONS_STRING      shift, and go to state 64
    CONS_BOOL        shift, and go to state 65

    literal_constant  go to state 83


state 53

   36 const_decl: CONST type const_list SEMICOLON .

    $default  reduce using rule 36 (const_decl)


state 54

   37 const_list: const_init COMMA . const_list

    ID  shift, and go to state 18

    symbol_id   go to state 37
    const_list  go to state 84
    const_init  go to state 39


state 55

   46 proc_decl: VOID symbol_id arg_list . R_PAREN SEMICOLON

    R_PAREN  shift, and go to state 85


state 56

   45 funct_decl: type symbol_id arg_list . R_PAREN SEMICOLON

    R_PAREN  shift, and go to state 86


state 57

   25 array_indice: L_BRACKET CONS_INTEGER . R_BRACKET

    R_BRACKET  shift, and go to state 87


state 58

   89 expr: L_PAREN . expr R_PAREN

    L_PAREN          shift, and go to state 58
    NOT              shift, and go to state 59
    MINUS            shift, and go to state 60
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 61
    CONS_FLOAT       shift, and go to state 62
    CONS_SCIENTIFIC  shift, and go to state 63
    CONS_STRING      shift, and go to state 64
    CONS_BOOL        shift, and go to state 65

    symbol_id         go to state 66
    literal_constant  go to state 67
    var_ref           go to state 68
    expr              go to state 88
    funct_invoc_ref   go to state 70


state 59

   92 expr: NOT . expr

    L_PAREN          shift, and go to state 58
    NOT              shift, and go to state 59
    MINUS            shift, and go to state 60
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 61
    CONS_FLOAT       shift, and go to state 62
    CONS_SCIENTIFIC  shift, and go to state 63
    CONS_STRING      shift, and go to state 64
    CONS_BOOL        shift, and go to state 65

    symbol_id         go to state 66
    literal_constant  go to state 67
    var_ref           go to state 68
    expr              go to state 89
    funct_invoc_ref   go to state 70


state 60

  104 expr: MINUS . expr

    L_PAREN          shift, and go to state 58
    NOT              shift, and go to state 59
    MINUS            shift, and go to state 60
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 61
    CONS_FLOAT       shift, and go to state 62
    CONS_SCIENTIFIC  shift, and go to state 63
    CONS_STRING      shift, and go to state 64
    CONS_BOOL        shift, and go to state 65

    symbol_id         go to state 66
    literal_constant  go to state 67
    var_ref           go to state 68
    expr              go to state 90
    funct_invoc_ref   go to state 70


state 61

   40 literal_constant: CONS_INTEGER .

    $default  reduce using rule 40 (literal_constant)


state 62

   41 literal_constant: CONS_FLOAT .

    $default  reduce using rule 41 (literal_constant)


state 63

   42 literal_constant: CONS_SCIENTIFIC .

    $default  reduce using rule 42 (literal_constant)


state 64

   43 literal_constant: CONS_STRING .

    $default  reduce using rule 43 (literal_constant)


state 65

   44 literal_constant: CONS_BOOL .

    $default  reduce using rule 44 (literal_constant)


state 66

   76 var_ref: symbol_id .
   77        | symbol_id . arr_ref_indice
  128 funct_invoc_ref: symbol_id . funct_invoc_list R_PAREN

    L_PAREN    shift, and go to state 91
    L_BRACKET  shift, and go to state 92

    $default  reduce using rule 76 (var_ref)

    arr_ref_indice    go to state 93
    arr_ref_index     go to state 94
    funct_invoc_list  go to state 95


state 67

  105 expr: literal_constant .

    $default  reduce using rule 105 (expr)


state 68

  106 expr: var_ref .

    $default  reduce using rule 106 (expr)


state 69

   29 var_single: symbol_id ASSIGN expr .
   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    OR        shift, and go to state 96
    AND       shift, and go to state 97
    NOT_EQ    shift, and go to state 98
    GREAT     shift, and go to state 99
    GREAT_EQ  shift, and go to state 100
    EQUAL     shift, and go to state 101
    LESS_EQ   shift, and go to state 102
    LESS      shift, and go to state 103
    MINUS     shift, and go to state 104
    PLUS      shift, and go to state 105
    MOD       shift, and go to state 106
    DIVIDE    shift, and go to state 107
    MULTIPLY  shift, and go to state 108

    $default  reduce using rule 29 (var_single)


state 70

  107 expr: funct_invoc_ref .

    $default  reduce using rule 107 (expr)


state 71

   24 array_indice: array_indice L_BRACKET . CONS_INTEGER R_BRACKET

    CONS_INTEGER  shift, and go to state 109


state 72

   30 var_single: symbol_id array_indice ASSIGN . init_array

    L_BRACE  shift, and go to state 110

    init_array     go to state 111
    init_arr_list  go to state 112


state 73

   45 funct_decl: type symbol_id arg_list R_PAREN . SEMICOLON
   47 definition_list: type symbol_id arg_list R_PAREN . compound_st definition_list
   49                | type symbol_id arg_list R_PAREN . compound_st

    L_BRACE    shift, and go to state 79
    SEMICOLON  shift, and go to state 113

    compound_st    go to state 114
    compound_list  go to state 82


state 74

   21 identifier: symbol_id .
   22           | symbol_id . array_indice
   29 var_single: symbol_id . ASSIGN expr
   30           | symbol_id . array_indice ASSIGN init_array

    L_BRACKET  shift, and go to state 42
    ASSIGN     shift, and go to state 43

    $default  reduce using rule 21 (identifier)

    array_indice  go to state 44


state 75

   26 var_list: var_list COMMA var_single .

    $default  reduce using rule 26 (var_list)


state 76

   55 arg: type identifier .

    $default  reduce using rule 55 (arg)


state 77

   21 identifier: symbol_id .
   22           | symbol_id . array_indice

    L_BRACKET  shift, and go to state 42

    $default  reduce using rule 21 (identifier)

    array_indice  go to state 115


state 78

   53 nonEmpty_arg_list: arg COMMA . nonEmpty_arg_list

    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    type               go to state 48
    nonEmpty_arg_list  go to state 116
    arg                go to state 50


state 79

   57 compound_list: L_BRACE . nonEmpty_compound_list
   58              | L_BRACE .

    CONST     shift, and go to state 2
    STRING    shift, and go to state 3
    DOUBLE    shift, and go to state 4
    FLOAT     shift, and go to state 5
    BOOL      shift, and go to state 6
    INT       shift, and go to state 7
    BOOLEAN   shift, and go to state 8
    L_BRACE   shift, and go to state 79
    WHILE     shift, and go to state 117
    DO        shift, and go to state 118
    IF        shift, and go to state 119
    FOR       shift, and go to state 120
    PRINT     shift, and go to state 121
    READ      shift, and go to state 122
    CONTINUE  shift, and go to state 123
    BREAK     shift, and go to state 124
    RETURN    shift, and go to state 125
    ID        shift, and go to state 18

    $default  reduce using rule 58 (compound_list)

    var_decl                go to state 126
    type                    go to state 127
    symbol_id               go to state 128
    const_decl              go to state 129
    compound_st             go to state 130
    compound_list           go to state 82
    nonEmpty_compound_list  go to state 131
    statement               go to state 132
    simple_st               go to state 133
    var_ref                 go to state 134
    condition_st            go to state 135
    while_st                go to state 136
    jump_st                 go to state 137
    for_st                  go to state 138
    funct_invoc_st          go to state 139


state 80

   46 proc_decl: VOID symbol_id arg_list R_PAREN SEMICOLON .

    $default  reduce using rule 46 (proc_decl)


state 81

   48 definition_list: VOID symbol_id arg_list R_PAREN compound_st . definition_list
   50                | VOID symbol_id arg_list R_PAREN compound_st .

    $default  reduce using rule 50 (definition_list)

    type             go to state 141
    definition_list  go to state 142


state 82

   56 compound_st: compound_list . R_BRACE

    R_BRACE  shift, and go to state 143


state 83

   39 const_init: symbol_id ASSIGN literal_constant .

    $default  reduce using rule 39 (const_init)


state 84

   37 const_list: const_init COMMA const_list .

    $default  reduce using rule 37 (const_list)


state 85

   46 proc_decl: VOID symbol_id arg_list R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 80


state 86

   45 funct_decl: type symbol_id arg_list R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 113


state 87

   25 array_indice: L_BRACKET CONS_INTEGER R_BRACKET .

    $default  reduce using rule 25 (array_indice)


state 88

   89 expr: L_PAREN expr . R_PAREN
   90     | expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    R_PAREN   shift, and go to state 144
    OR        shift, and go to state 96
    AND       shift, and go to state 97
    NOT_EQ    shift, and go to state 98
    GREAT     shift, and go to state 99
    GREAT_EQ  shift, and go to state 100
    EQUAL     shift, and go to state 101
    LESS_EQ   shift, and go to state 102
    LESS      shift, and go to state 103
    MINUS     shift, and go to state 104
    PLUS      shift, and go to state 105
    MOD       shift, and go to state 106
    DIVIDE    shift, and go to state 107
    MULTIPLY  shift, and go to state 108


state 89

   90 expr: expr . OR expr
   91     | expr . AND expr
   92     | NOT expr .
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    OR        shift, and go to state 96
    AND       shift, and go to state 97
    NOT_EQ    shift, and go to state 98
    GREAT     shift, and go to state 99
    GREAT_EQ  shift, and go to state 100
    EQUAL     shift, and go to state 101
    LESS_EQ   shift, and go to state 102
    LESS      shift, and go to state 103
    MINUS     shift, and go to state 104
    PLUS      shift, and go to state 105
    MOD       shift, and go to state 106
    DIVIDE    shift, and go to state 107
    MULTIPLY  shift, and go to state 108

    OR        [reduce using rule 92 (expr)]
    AND       [reduce using rule 92 (expr)]
    NOT_EQ    [reduce using rule 92 (expr)]
    GREAT     [reduce using rule 92 (expr)]
    GREAT_EQ  [reduce using rule 92 (expr)]
    EQUAL     [reduce using rule 92 (expr)]
    LESS_EQ   [reduce using rule 92 (expr)]
    LESS      [reduce using rule 92 (expr)]
    MINUS     [reduce using rule 92 (expr)]
    PLUS      [reduce using rule 92 (expr)]
    MOD       [reduce using rule 92 (expr)]
    DIVIDE    [reduce using rule 92 (expr)]
    MULTIPLY  [reduce using rule 92 (expr)]
    $default  reduce using rule 92 (expr)


state 90

   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr
  104     | MINUS expr .

    $default  reduce using rule 104 (expr)


state 91

  130 funct_invoc_list: L_PAREN .
  131                 | L_PAREN . nonEmpty_funct_invoc_list

    L_PAREN          shift, and go to state 58
    NOT              shift, and go to state 59
    MINUS            shift, and go to state 60
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 61
    CONS_FLOAT       shift, and go to state 62
    CONS_SCIENTIFIC  shift, and go to state 63
    CONS_STRING      shift, and go to state 64
    CONS_BOOL        shift, and go to state 65

    $default  reduce using rule 130 (funct_invoc_list)

    symbol_id                  go to state 66
    literal_constant           go to state 67
    var_ref                    go to state 68
    expr                       go to state 145
    funct_invoc_ref            go to state 70
    nonEmpty_funct_invoc_list  go to state 146


state 92

   80 arr_ref_index: L_BRACKET . expr R_BRACKET

    L_PAREN          shift, and go to state 58
    NOT              shift, and go to state 59
    MINUS            shift, and go to state 60
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 61
    CONS_FLOAT       shift, and go to state 62
    CONS_SCIENTIFIC  shift, and go to state 63
    CONS_STRING      shift, and go to state 64
    CONS_BOOL        shift, and go to state 65

    symbol_id         go to state 66
    literal_constant  go to state 67
    var_ref           go to state 68
    expr              go to state 147
    funct_invoc_ref   go to state 70


state 93

   77 var_ref: symbol_id arr_ref_indice .

    $default  reduce using rule 77 (var_ref)


state 94

   78 arr_ref_indice: arr_ref_index . arr_ref_indice
   79               | arr_ref_index .

    L_BRACKET  shift, and go to state 92

    $default  reduce using rule 79 (arr_ref_indice)

    arr_ref_indice  go to state 148
    arr_ref_index   go to state 94


state 95

  128 funct_invoc_ref: symbol_id funct_invoc_list . R_PAREN

    R_PAREN  shift, and go to state 149


state 96

   90 expr: expr OR . expr

    L_PAREN          shift, and go to state 58
    NOT              shift, and go to state 59
    MINUS            shift, and go to state 60
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 61
    CONS_FLOAT       shift, and go to state 62
    CONS_SCIENTIFIC  shift, and go to state 63
    CONS_STRING      shift, and go to state 64
    CONS_BOOL        shift, and go to state 65

    symbol_id         go to state 66
    literal_constant  go to state 67
    var_ref           go to state 68
    expr              go to state 150
    funct_invoc_ref   go to state 70


state 97

   91 expr: expr AND . expr

    L_PAREN          shift, and go to state 58
    NOT              shift, and go to state 59
    MINUS            shift, and go to state 60
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 61
    CONS_FLOAT       shift, and go to state 62
    CONS_SCIENTIFIC  shift, and go to state 63
    CONS_STRING      shift, and go to state 64
    CONS_BOOL        shift, and go to state 65

    symbol_id         go to state 66
    literal_constant  go to state 67
    var_ref           go to state 68
    expr              go to state 151
    funct_invoc_ref   go to state 70


state 98

   98 expr: expr NOT_EQ . expr

    L_PAREN          shift, and go to state 58
    NOT              shift, and go to state 59
    MINUS            shift, and go to state 60
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 61
    CONS_FLOAT       shift, and go to state 62
    CONS_SCIENTIFIC  shift, and go to state 63
    CONS_STRING      shift, and go to state 64
    CONS_BOOL        shift, and go to state 65

    symbol_id         go to state 66
    literal_constant  go to state 67
    var_ref           go to state 68
    expr              go to state 152
    funct_invoc_ref   go to state 70


state 99

   97 expr: expr GREAT . expr

    L_PAREN          shift, and go to state 58
    NOT              shift, and go to state 59
    MINUS            shift, and go to state 60
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 61
    CONS_FLOAT       shift, and go to state 62
    CONS_SCIENTIFIC  shift, and go to state 63
    CONS_STRING      shift, and go to state 64
    CONS_BOOL        shift, and go to state 65

    symbol_id         go to state 66
    literal_constant  go to state 67
    var_ref           go to state 68
    expr              go to state 153
    funct_invoc_ref   go to state 70


state 100

   96 expr: expr GREAT_EQ . expr

    L_PAREN          shift, and go to state 58
    NOT              shift, and go to state 59
    MINUS            shift, and go to state 60
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 61
    CONS_FLOAT       shift, and go to state 62
    CONS_SCIENTIFIC  shift, and go to state 63
    CONS_STRING      shift, and go to state 64
    CONS_BOOL        shift, and go to state 65

    symbol_id         go to state 66
    literal_constant  go to state 67
    var_ref           go to state 68
    expr              go to state 154
    funct_invoc_ref   go to state 70


state 101

   95 expr: expr EQUAL . expr

    L_PAREN          shift, and go to state 58
    NOT              shift, and go to state 59
    MINUS            shift, and go to state 60
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 61
    CONS_FLOAT       shift, and go to state 62
    CONS_SCIENTIFIC  shift, and go to state 63
    CONS_STRING      shift, and go to state 64
    CONS_BOOL        shift, and go to state 65

    symbol_id         go to state 66
    literal_constant  go to state 67
    var_ref           go to state 68
    expr              go to state 155
    funct_invoc_ref   go to state 70


state 102

   94 expr: expr LESS_EQ . expr

    L_PAREN          shift, and go to state 58
    NOT              shift, and go to state 59
    MINUS            shift, and go to state 60
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 61
    CONS_FLOAT       shift, and go to state 62
    CONS_SCIENTIFIC  shift, and go to state 63
    CONS_STRING      shift, and go to state 64
    CONS_BOOL        shift, and go to state 65

    symbol_id         go to state 66
    literal_constant  go to state 67
    var_ref           go to state 68
    expr              go to state 156
    funct_invoc_ref   go to state 70


state 103

   93 expr: expr LESS . expr

    L_PAREN          shift, and go to state 58
    NOT              shift, and go to state 59
    MINUS            shift, and go to state 60
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 61
    CONS_FLOAT       shift, and go to state 62
    CONS_SCIENTIFIC  shift, and go to state 63
    CONS_STRING      shift, and go to state 64
    CONS_BOOL        shift, and go to state 65

    symbol_id         go to state 66
    literal_constant  go to state 67
    var_ref           go to state 68
    expr              go to state 157
    funct_invoc_ref   go to state 70


state 104

  100 expr: expr MINUS . expr

    L_PAREN          shift, and go to state 58
    NOT              shift, and go to state 59
    MINUS            shift, and go to state 60
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 61
    CONS_FLOAT       shift, and go to state 62
    CONS_SCIENTIFIC  shift, and go to state 63
    CONS_STRING      shift, and go to state 64
    CONS_BOOL        shift, and go to state 65

    symbol_id         go to state 66
    literal_constant  go to state 67
    var_ref           go to state 68
    expr              go to state 158
    funct_invoc_ref   go to state 70


state 105

   99 expr: expr PLUS . expr

    L_PAREN          shift, and go to state 58
    NOT              shift, and go to state 59
    MINUS            shift, and go to state 60
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 61
    CONS_FLOAT       shift, and go to state 62
    CONS_SCIENTIFIC  shift, and go to state 63
    CONS_STRING      shift, and go to state 64
    CONS_BOOL        shift, and go to state 65

    symbol_id         go to state 66
    literal_constant  go to state 67
    var_ref           go to state 68
    expr              go to state 159
    funct_invoc_ref   go to state 70


state 106

  103 expr: expr MOD . expr

    L_PAREN          shift, and go to state 58
    NOT              shift, and go to state 59
    MINUS            shift, and go to state 60
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 61
    CONS_FLOAT       shift, and go to state 62
    CONS_SCIENTIFIC  shift, and go to state 63
    CONS_STRING      shift, and go to state 64
    CONS_BOOL        shift, and go to state 65

    symbol_id         go to state 66
    literal_constant  go to state 67
    var_ref           go to state 68
    expr              go to state 160
    funct_invoc_ref   go to state 70


state 107

  102 expr: expr DIVIDE . expr

    L_PAREN          shift, and go to state 58
    NOT              shift, and go to state 59
    MINUS            shift, and go to state 60
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 61
    CONS_FLOAT       shift, and go to state 62
    CONS_SCIENTIFIC  shift, and go to state 63
    CONS_STRING      shift, and go to state 64
    CONS_BOOL        shift, and go to state 65

    symbol_id         go to state 66
    literal_constant  go to state 67
    var_ref           go to state 68
    expr              go to state 161
    funct_invoc_ref   go to state 70


state 108

  101 expr: expr MULTIPLY . expr

    L_PAREN          shift, and go to state 58
    NOT              shift, and go to state 59
    MINUS            shift, and go to state 60
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 61
    CONS_FLOAT       shift, and go to state 62
    CONS_SCIENTIFIC  shift, and go to state 63
    CONS_STRING      shift, and go to state 64
    CONS_BOOL        shift, and go to state 65

    symbol_id         go to state 66
    literal_constant  go to state 67
    var_ref           go to state 68
    expr              go to state 162
    funct_invoc_ref   go to state 70


state 109

   24 array_indice: array_indice L_BRACKET CONS_INTEGER . R_BRACKET

    R_BRACKET  shift, and go to state 163


state 110

   32 init_arr_list: L_BRACE . nonEmpty_init_arr_list
   33              | L_BRACE .

    L_PAREN          shift, and go to state 58
    NOT              shift, and go to state 59
    MINUS            shift, and go to state 60
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 61
    CONS_FLOAT       shift, and go to state 62
    CONS_SCIENTIFIC  shift, and go to state 63
    CONS_STRING      shift, and go to state 64
    CONS_BOOL        shift, and go to state 65

    $default  reduce using rule 33 (init_arr_list)

    symbol_id               go to state 66
    nonEmpty_init_arr_list  go to state 164
    literal_constant        go to state 67
    var_ref                 go to state 68
    expr                    go to state 165
    funct_invoc_ref         go to state 70


state 111

   30 var_single: symbol_id array_indice ASSIGN init_array .

    $default  reduce using rule 30 (var_single)


state 112

   31 init_array: init_arr_list . R_BRACE

    R_BRACE  shift, and go to state 166


state 113

   45 funct_decl: type symbol_id arg_list R_PAREN SEMICOLON .

    $default  reduce using rule 45 (funct_decl)


state 114

   47 definition_list: type symbol_id arg_list R_PAREN compound_st . definition_list
   49                | type symbol_id arg_list R_PAREN compound_st .

    $default  reduce using rule 49 (definition_list)

    type             go to state 141
    definition_list  go to state 167


state 115

   22 identifier: symbol_id array_indice .
   24 array_indice: array_indice . L_BRACKET CONS_INTEGER R_BRACKET

    L_BRACKET  shift, and go to state 71

    $default  reduce using rule 22 (identifier)


state 116

   53 nonEmpty_arg_list: arg COMMA nonEmpty_arg_list .

    $default  reduce using rule 53 (nonEmpty_arg_list)


state 117

   84 while_st: WHILE . L_PAREN bool_expr R_PAREN compound_st

    L_PAREN  shift, and go to state 168


state 118

   85 while_st: DO . compound_st WHILE L_PAREN bool_expr R_PAREN SEMICOLON

    L_BRACE  shift, and go to state 79

    compound_st    go to state 169
    compound_list  go to state 82


state 119

   81 condition_st: IF . L_PAREN bool_expr R_PAREN compound_st
   82             | IF . L_PAREN bool_expr R_PAREN compound_st ELSE compound_st

    L_PAREN  shift, and go to state 170


state 120

  108 for_st: FOR . for_init for_control for_incre R_PAREN compound_st

    L_PAREN  shift, and go to state 171

    for_init  go to state 172


state 121

   73 simple_st: PRINT . var_ref SEMICOLON
   74          | PRINT . expr SEMICOLON

    L_PAREN          shift, and go to state 58
    NOT              shift, and go to state 59
    MINUS            shift, and go to state 60
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 61
    CONS_FLOAT       shift, and go to state 62
    CONS_SCIENTIFIC  shift, and go to state 63
    CONS_STRING      shift, and go to state 64
    CONS_BOOL        shift, and go to state 65

    symbol_id         go to state 66
    literal_constant  go to state 67
    var_ref           go to state 173
    expr              go to state 174
    funct_invoc_ref   go to state 70


state 122

   75 simple_st: READ . var_ref SEMICOLON

    ID  shift, and go to state 18

    symbol_id  go to state 175
    var_ref    go to state 176


state 123

   88 jump_st: CONTINUE . SEMICOLON

    SEMICOLON  shift, and go to state 177


state 124

   87 jump_st: BREAK . SEMICOLON

    SEMICOLON  shift, and go to state 178


state 125

   86 jump_st: RETURN . expr SEMICOLON

    L_PAREN          shift, and go to state 58
    NOT              shift, and go to state 59
    MINUS            shift, and go to state 60
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 61
    CONS_FLOAT       shift, and go to state 62
    CONS_SCIENTIFIC  shift, and go to state 63
    CONS_STRING      shift, and go to state 64
    CONS_BOOL        shift, and go to state 65

    symbol_id         go to state 66
    literal_constant  go to state 67
    var_ref           go to state 68
    expr              go to state 179
    funct_invoc_ref   go to state 70


state 126

   59 nonEmpty_compound_list: var_decl . nonEmpty_compound_list
   62                       | var_decl .

    CONST     shift, and go to state 2
    STRING    shift, and go to state 3
    DOUBLE    shift, and go to state 4
    FLOAT     shift, and go to state 5
    BOOL      shift, and go to state 6
    INT       shift, and go to state 7
    BOOLEAN   shift, and go to state 8
    L_BRACE   shift, and go to state 79
    WHILE     shift, and go to state 117
    DO        shift, and go to state 118
    IF        shift, and go to state 119
    FOR       shift, and go to state 120
    PRINT     shift, and go to state 121
    READ      shift, and go to state 122
    CONTINUE  shift, and go to state 123
    BREAK     shift, and go to state 124
    RETURN    shift, and go to state 125
    ID        shift, and go to state 18

    $default  reduce using rule 62 (nonEmpty_compound_list)

    var_decl                go to state 126
    type                    go to state 127
    symbol_id               go to state 128
    const_decl              go to state 129
    compound_st             go to state 130
    compound_list           go to state 82
    nonEmpty_compound_list  go to state 180
    statement               go to state 132
    simple_st               go to state 133
    var_ref                 go to state 134
    condition_st            go to state 135
    while_st                go to state 136
    jump_st                 go to state 137
    for_st                  go to state 138
    funct_invoc_st          go to state 139


state 127

   14 var_decl: type . var_list SEMICOLON

    ID  shift, and go to state 18

    identifier  go to state 27
    symbol_id   go to state 74
    var_list    go to state 29
    var_single  go to state 30


state 128

   76 var_ref: symbol_id .
   77        | symbol_id . arr_ref_indice
  129 funct_invoc_st: symbol_id . funct_invoc_list R_PAREN SEMICOLON

    L_PAREN    shift, and go to state 91
    L_BRACKET  shift, and go to state 92

    $default  reduce using rule 76 (var_ref)

    arr_ref_indice    go to state 93
    arr_ref_index     go to state 94
    funct_invoc_list  go to state 181


state 129

   60 nonEmpty_compound_list: const_decl . nonEmpty_compound_list
   63                       | const_decl .

    CONST     shift, and go to state 2
    STRING    shift, and go to state 3
    DOUBLE    shift, and go to state 4
    FLOAT     shift, and go to state 5
    BOOL      shift, and go to state 6
    INT       shift, and go to state 7
    BOOLEAN   shift, and go to state 8
    L_BRACE   shift, and go to state 79
    WHILE     shift, and go to state 117
    DO        shift, and go to state 118
    IF        shift, and go to state 119
    FOR       shift, and go to state 120
    PRINT     shift, and go to state 121
    READ      shift, and go to state 122
    CONTINUE  shift, and go to state 123
    BREAK     shift, and go to state 124
    RETURN    shift, and go to state 125
    ID        shift, and go to state 18

    $default  reduce using rule 63 (nonEmpty_compound_list)

    var_decl                go to state 126
    type                    go to state 127
    symbol_id               go to state 128
    const_decl              go to state 129
    compound_st             go to state 130
    compound_list           go to state 82
    nonEmpty_compound_list  go to state 182
    statement               go to state 132
    simple_st               go to state 133
    var_ref                 go to state 134
    condition_st            go to state 135
    while_st                go to state 136
    jump_st                 go to state 137
    for_st                  go to state 138
    funct_invoc_st          go to state 139


state 130

   65 statement: compound_st .

    $default  reduce using rule 65 (statement)


state 131

   57 compound_list: L_BRACE nonEmpty_compound_list .

    $default  reduce using rule 57 (compound_list)


state 132

   61 nonEmpty_compound_list: statement . nonEmpty_compound_list
   64                       | statement .

    CONST     shift, and go to state 2
    STRING    shift, and go to state 3
    DOUBLE    shift, and go to state 4
    FLOAT     shift, and go to state 5
    BOOL      shift, and go to state 6
    INT       shift, and go to state 7
    BOOLEAN   shift, and go to state 8
    L_BRACE   shift, and go to state 79
    WHILE     shift, and go to state 117
    DO        shift, and go to state 118
    IF        shift, and go to state 119
    FOR       shift, and go to state 120
    PRINT     shift, and go to state 121
    READ      shift, and go to state 122
    CONTINUE  shift, and go to state 123
    BREAK     shift, and go to state 124
    RETURN    shift, and go to state 125
    ID        shift, and go to state 18

    $default  reduce using rule 64 (nonEmpty_compound_list)

    var_decl                go to state 126
    type                    go to state 127
    symbol_id               go to state 128
    const_decl              go to state 129
    compound_st             go to state 130
    compound_list           go to state 82
    nonEmpty_compound_list  go to state 183
    statement               go to state 132
    simple_st               go to state 133
    var_ref                 go to state 134
    condition_st            go to state 135
    while_st                go to state 136
    jump_st                 go to state 137
    for_st                  go to state 138
    funct_invoc_st          go to state 139


state 133

   66 statement: simple_st .

    $default  reduce using rule 66 (statement)


state 134

   72 simple_st: var_ref . ASSIGN expr SEMICOLON

    ASSIGN  shift, and go to state 184


state 135

   67 statement: condition_st .

    $default  reduce using rule 67 (statement)


state 136

   68 statement: while_st .

    $default  reduce using rule 68 (statement)


state 137

   70 statement: jump_st .

    $default  reduce using rule 70 (statement)


state 138

   69 statement: for_st .

    $default  reduce using rule 69 (statement)


state 139

   71 statement: funct_invoc_st .

    $default  reduce using rule 71 (statement)


state 140

   48 definition_list: VOID . symbol_id arg_list R_PAREN compound_st definition_list
   50                | VOID . symbol_id arg_list R_PAREN compound_st

    ID  shift, and go to state 18

    symbol_id  go to state 185


state 141

   47 definition_list: type . symbol_id arg_list R_PAREN compound_st definition_list
   49                | type . symbol_id arg_list R_PAREN compound_st

    ID  shift, and go to state 18

    symbol_id  go to state 186


state 142

   48 definition_list: VOID symbol_id arg_list R_PAREN compound_st definition_list .

    $default  reduce using rule 48 (definition_list)


state 143

   56 compound_st: compound_list R_BRACE .

    $default  reduce using rule 56 (compound_st)


state 144

   89 expr: L_PAREN expr R_PAREN .

    $default  reduce using rule 89 (expr)


state 145

   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr
  133 nonEmpty_funct_invoc_list: expr .

    OR        shift, and go to state 96
    AND       shift, and go to state 97
    NOT_EQ    shift, and go to state 98
    GREAT     shift, and go to state 99
    GREAT_EQ  shift, and go to state 100
    EQUAL     shift, and go to state 101
    LESS_EQ   shift, and go to state 102
    LESS      shift, and go to state 103
    MINUS     shift, and go to state 104
    PLUS      shift, and go to state 105
    MOD       shift, and go to state 106
    DIVIDE    shift, and go to state 107
    MULTIPLY  shift, and go to state 108

    $default  reduce using rule 133 (nonEmpty_funct_invoc_list)


state 146

  131 funct_invoc_list: L_PAREN nonEmpty_funct_invoc_list .
  132 nonEmpty_funct_invoc_list: nonEmpty_funct_invoc_list . COMMA expr

    COMMA  shift, and go to state 187

    $default  reduce using rule 131 (funct_invoc_list)


state 147

   80 arr_ref_index: L_BRACKET expr . R_BRACKET
   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    R_BRACKET  shift, and go to state 188
    OR         shift, and go to state 96
    AND        shift, and go to state 97
    NOT_EQ     shift, and go to state 98
    GREAT      shift, and go to state 99
    GREAT_EQ   shift, and go to state 100
    EQUAL      shift, and go to state 101
    LESS_EQ    shift, and go to state 102
    LESS       shift, and go to state 103
    MINUS      shift, and go to state 104
    PLUS       shift, and go to state 105
    MOD        shift, and go to state 106
    DIVIDE     shift, and go to state 107
    MULTIPLY   shift, and go to state 108


state 148

   78 arr_ref_indice: arr_ref_index arr_ref_indice .

    $default  reduce using rule 78 (arr_ref_indice)


state 149

  128 funct_invoc_ref: symbol_id funct_invoc_list R_PAREN .

    $default  reduce using rule 128 (funct_invoc_ref)


state 150

   90 expr: expr . OR expr
   90     | expr OR expr .
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    AND       shift, and go to state 97
    NOT_EQ    shift, and go to state 98
    GREAT     shift, and go to state 99
    GREAT_EQ  shift, and go to state 100
    EQUAL     shift, and go to state 101
    LESS_EQ   shift, and go to state 102
    LESS      shift, and go to state 103
    MINUS     shift, and go to state 104
    PLUS      shift, and go to state 105
    MOD       shift, and go to state 106
    DIVIDE    shift, and go to state 107
    MULTIPLY  shift, and go to state 108

    $default  reduce using rule 90 (expr)


state 151

   90 expr: expr . OR expr
   91     | expr . AND expr
   91     | expr AND expr .
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    NOT_EQ    shift, and go to state 98
    GREAT     shift, and go to state 99
    GREAT_EQ  shift, and go to state 100
    EQUAL     shift, and go to state 101
    LESS_EQ   shift, and go to state 102
    LESS      shift, and go to state 103
    MINUS     shift, and go to state 104
    PLUS      shift, and go to state 105
    MOD       shift, and go to state 106
    DIVIDE    shift, and go to state 107
    MULTIPLY  shift, and go to state 108

    $default  reduce using rule 91 (expr)


state 152

   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   98     | expr NOT_EQ expr .
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    MINUS     shift, and go to state 104
    PLUS      shift, and go to state 105
    MOD       shift, and go to state 106
    DIVIDE    shift, and go to state 107
    MULTIPLY  shift, and go to state 108

    $default  reduce using rule 98 (expr)


state 153

   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   97     | expr GREAT expr .
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    MINUS     shift, and go to state 104
    PLUS      shift, and go to state 105
    MOD       shift, and go to state 106
    DIVIDE    shift, and go to state 107
    MULTIPLY  shift, and go to state 108

    $default  reduce using rule 97 (expr)


state 154

   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   96     | expr GREAT_EQ expr .
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    MINUS     shift, and go to state 104
    PLUS      shift, and go to state 105
    MOD       shift, and go to state 106
    DIVIDE    shift, and go to state 107
    MULTIPLY  shift, and go to state 108

    $default  reduce using rule 96 (expr)


state 155

   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   95     | expr EQUAL expr .
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    MINUS     shift, and go to state 104
    PLUS      shift, and go to state 105
    MOD       shift, and go to state 106
    DIVIDE    shift, and go to state 107
    MULTIPLY  shift, and go to state 108

    $default  reduce using rule 95 (expr)


state 156

   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   94     | expr LESS_EQ expr .
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    MINUS     shift, and go to state 104
    PLUS      shift, and go to state 105
    MOD       shift, and go to state 106
    DIVIDE    shift, and go to state 107
    MULTIPLY  shift, and go to state 108

    $default  reduce using rule 94 (expr)


state 157

   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   93     | expr LESS expr .
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    MINUS     shift, and go to state 104
    PLUS      shift, and go to state 105
    MOD       shift, and go to state 106
    DIVIDE    shift, and go to state 107
    MULTIPLY  shift, and go to state 108

    $default  reduce using rule 93 (expr)


state 158

   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  100     | expr MINUS expr .
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    MOD       shift, and go to state 106
    DIVIDE    shift, and go to state 107
    MULTIPLY  shift, and go to state 108

    $default  reduce using rule 100 (expr)


state 159

   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
   99     | expr PLUS expr .
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    MOD       shift, and go to state 106
    DIVIDE    shift, and go to state 107
    MULTIPLY  shift, and go to state 108

    $default  reduce using rule 99 (expr)


state 160

   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr
  103     | expr MOD expr .

    $default  reduce using rule 103 (expr)


state 161

   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  102     | expr DIVIDE expr .
  103     | expr . MOD expr

    $default  reduce using rule 102 (expr)


state 162

   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  101     | expr MULTIPLY expr .
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    $default  reduce using rule 101 (expr)


state 163

   24 array_indice: array_indice L_BRACKET CONS_INTEGER R_BRACKET .

    $default  reduce using rule 24 (array_indice)


state 164

   32 init_arr_list: L_BRACE nonEmpty_init_arr_list .
   34 nonEmpty_init_arr_list: nonEmpty_init_arr_list . COMMA expr

    COMMA  shift, and go to state 189

    $default  reduce using rule 32 (init_arr_list)


state 165

   35 nonEmpty_init_arr_list: expr .
   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    OR        shift, and go to state 96
    AND       shift, and go to state 97
    NOT_EQ    shift, and go to state 98
    GREAT     shift, and go to state 99
    GREAT_EQ  shift, and go to state 100
    EQUAL     shift, and go to state 101
    LESS_EQ   shift, and go to state 102
    LESS      shift, and go to state 103
    MINUS     shift, and go to state 104
    PLUS      shift, and go to state 105
    MOD       shift, and go to state 106
    DIVIDE    shift, and go to state 107
    MULTIPLY  shift, and go to state 108

    $default  reduce using rule 35 (nonEmpty_init_arr_list)


state 166

   31 init_array: init_arr_list R_BRACE .

    $default  reduce using rule 31 (init_array)


state 167

   47 definition_list: type symbol_id arg_list R_PAREN compound_st definition_list .

    $default  reduce using rule 47 (definition_list)


state 168

   84 while_st: WHILE L_PAREN . bool_expr R_PAREN compound_st

    L_PAREN          shift, and go to state 58
    NOT              shift, and go to state 59
    MINUS            shift, and go to state 60
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 61
    CONS_FLOAT       shift, and go to state 62
    CONS_SCIENTIFIC  shift, and go to state 63
    CONS_STRING      shift, and go to state 64
    CONS_BOOL        shift, and go to state 65

    symbol_id         go to state 66
    literal_constant  go to state 67
    var_ref           go to state 68
    bool_expr         go to state 190
    expr              go to state 191
    funct_invoc_ref   go to state 70


state 169

   85 while_st: DO compound_st . WHILE L_PAREN bool_expr R_PAREN SEMICOLON

    WHILE  shift, and go to state 192


state 170

   81 condition_st: IF L_PAREN . bool_expr R_PAREN compound_st
   82             | IF L_PAREN . bool_expr R_PAREN compound_st ELSE compound_st

    L_PAREN          shift, and go to state 58
    NOT              shift, and go to state 59
    MINUS            shift, and go to state 60
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 61
    CONS_FLOAT       shift, and go to state 62
    CONS_SCIENTIFIC  shift, and go to state 63
    CONS_STRING      shift, and go to state 64
    CONS_BOOL        shift, and go to state 65

    symbol_id         go to state 66
    literal_constant  go to state 67
    var_ref           go to state 68
    bool_expr         go to state 193
    expr              go to state 191
    funct_invoc_ref   go to state 70


state 171

  109 for_init: L_PAREN . nonEmpty_for_init
  110         | L_PAREN .

    L_PAREN          shift, and go to state 58
    NOT              shift, and go to state 59
    MINUS            shift, and go to state 60
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 61
    CONS_FLOAT       shift, and go to state 62
    CONS_SCIENTIFIC  shift, and go to state 63
    CONS_STRING      shift, and go to state 64
    CONS_BOOL        shift, and go to state 65

    $default  reduce using rule 110 (for_init)

    symbol_id          go to state 194
    literal_constant   go to state 67
    var_ref            go to state 68
    expr               go to state 195
    nonEmpty_for_init  go to state 196
    for_single_entry   go to state 197
    funct_invoc_ref    go to state 70


state 172

  108 for_st: FOR for_init . for_control for_incre R_PAREN compound_st

    SEMICOLON  shift, and go to state 198

    for_control  go to state 199


state 173

   73 simple_st: PRINT var_ref . SEMICOLON
  106 expr: var_ref .

    SEMICOLON  shift, and go to state 200

    SEMICOLON  [reduce using rule 106 (expr)]
    $default   reduce using rule 106 (expr)


state 174

   74 simple_st: PRINT expr . SEMICOLON
   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    OR         shift, and go to state 96
    AND        shift, and go to state 97
    NOT_EQ     shift, and go to state 98
    GREAT      shift, and go to state 99
    GREAT_EQ   shift, and go to state 100
    EQUAL      shift, and go to state 101
    LESS_EQ    shift, and go to state 102
    LESS       shift, and go to state 103
    MINUS      shift, and go to state 104
    PLUS       shift, and go to state 105
    MOD        shift, and go to state 106
    DIVIDE     shift, and go to state 107
    MULTIPLY   shift, and go to state 108
    SEMICOLON  shift, and go to state 201


state 175

   76 var_ref: symbol_id .
   77        | symbol_id . arr_ref_indice

    L_BRACKET  shift, and go to state 92

    $default  reduce using rule 76 (var_ref)

    arr_ref_indice  go to state 93
    arr_ref_index   go to state 94


state 176

   75 simple_st: READ var_ref . SEMICOLON

    SEMICOLON  shift, and go to state 202


state 177

   88 jump_st: CONTINUE SEMICOLON .

    $default  reduce using rule 88 (jump_st)


state 178

   87 jump_st: BREAK SEMICOLON .

    $default  reduce using rule 87 (jump_st)


state 179

   86 jump_st: RETURN expr . SEMICOLON
   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    OR         shift, and go to state 96
    AND        shift, and go to state 97
    NOT_EQ     shift, and go to state 98
    GREAT      shift, and go to state 99
    GREAT_EQ   shift, and go to state 100
    EQUAL      shift, and go to state 101
    LESS_EQ    shift, and go to state 102
    LESS       shift, and go to state 103
    MINUS      shift, and go to state 104
    PLUS       shift, and go to state 105
    MOD        shift, and go to state 106
    DIVIDE     shift, and go to state 107
    MULTIPLY   shift, and go to state 108
    SEMICOLON  shift, and go to state 203


state 180

   59 nonEmpty_compound_list: var_decl nonEmpty_compound_list .

    $default  reduce using rule 59 (nonEmpty_compound_list)


state 181

  129 funct_invoc_st: symbol_id funct_invoc_list . R_PAREN SEMICOLON

    R_PAREN  shift, and go to state 204


state 182

   60 nonEmpty_compound_list: const_decl nonEmpty_compound_list .

    $default  reduce using rule 60 (nonEmpty_compound_list)


state 183

   61 nonEmpty_compound_list: statement nonEmpty_compound_list .

    $default  reduce using rule 61 (nonEmpty_compound_list)


state 184

   72 simple_st: var_ref ASSIGN . expr SEMICOLON

    L_PAREN          shift, and go to state 58
    NOT              shift, and go to state 59
    MINUS            shift, and go to state 60
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 61
    CONS_FLOAT       shift, and go to state 62
    CONS_SCIENTIFIC  shift, and go to state 63
    CONS_STRING      shift, and go to state 64
    CONS_BOOL        shift, and go to state 65

    symbol_id         go to state 66
    literal_constant  go to state 67
    var_ref           go to state 68
    expr              go to state 205
    funct_invoc_ref   go to state 70


state 185

   48 definition_list: VOID symbol_id . arg_list R_PAREN compound_st definition_list
   50                | VOID symbol_id . arg_list R_PAREN compound_st

    L_PAREN  shift, and go to state 35

    arg_list  go to state 206


state 186

   47 definition_list: type symbol_id . arg_list R_PAREN compound_st definition_list
   49                | type symbol_id . arg_list R_PAREN compound_st

    L_PAREN  shift, and go to state 35

    arg_list  go to state 207


state 187

  132 nonEmpty_funct_invoc_list: nonEmpty_funct_invoc_list COMMA . expr

    L_PAREN          shift, and go to state 58
    NOT              shift, and go to state 59
    MINUS            shift, and go to state 60
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 61
    CONS_FLOAT       shift, and go to state 62
    CONS_SCIENTIFIC  shift, and go to state 63
    CONS_STRING      shift, and go to state 64
    CONS_BOOL        shift, and go to state 65

    symbol_id         go to state 66
    literal_constant  go to state 67
    var_ref           go to state 68
    expr              go to state 208
    funct_invoc_ref   go to state 70


state 188

   80 arr_ref_index: L_BRACKET expr R_BRACKET .

    $default  reduce using rule 80 (arr_ref_index)


state 189

   34 nonEmpty_init_arr_list: nonEmpty_init_arr_list COMMA . expr

    L_PAREN          shift, and go to state 58
    NOT              shift, and go to state 59
    MINUS            shift, and go to state 60
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 61
    CONS_FLOAT       shift, and go to state 62
    CONS_SCIENTIFIC  shift, and go to state 63
    CONS_STRING      shift, and go to state 64
    CONS_BOOL        shift, and go to state 65

    symbol_id         go to state 66
    literal_constant  go to state 67
    var_ref           go to state 68
    expr              go to state 209
    funct_invoc_ref   go to state 70


state 190

   84 while_st: WHILE L_PAREN bool_expr . R_PAREN compound_st

    R_PAREN  shift, and go to state 210


state 191

   83 bool_expr: expr .
   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    OR        shift, and go to state 96
    AND       shift, and go to state 97
    NOT_EQ    shift, and go to state 98
    GREAT     shift, and go to state 99
    GREAT_EQ  shift, and go to state 100
    EQUAL     shift, and go to state 101
    LESS_EQ   shift, and go to state 102
    LESS      shift, and go to state 103
    MINUS     shift, and go to state 104
    PLUS      shift, and go to state 105
    MOD       shift, and go to state 106
    DIVIDE    shift, and go to state 107
    MULTIPLY  shift, and go to state 108

    $default  reduce using rule 83 (bool_expr)


state 192

   85 while_st: DO compound_st WHILE . L_PAREN bool_expr R_PAREN SEMICOLON

    L_PAREN  shift, and go to state 211


state 193

   81 condition_st: IF L_PAREN bool_expr . R_PAREN compound_st
   82             | IF L_PAREN bool_expr . R_PAREN compound_st ELSE compound_st

    R_PAREN  shift, and go to state 212


state 194

   76 var_ref: symbol_id .
   77        | symbol_id . arr_ref_indice
  124 for_single_entry: symbol_id . ASSIGN expr
  125                 | symbol_id . array_indice ASSIGN init_array
  127                 | symbol_id . funct_invoc_list R_PAREN
  128 funct_invoc_ref: symbol_id . funct_invoc_list R_PAREN

    L_PAREN    shift, and go to state 91
    L_BRACKET  shift, and go to state 213
    ASSIGN     shift, and go to state 214

    $default  reduce using rule 76 (var_ref)

    array_indice      go to state 215
    arr_ref_indice    go to state 93
    arr_ref_index     go to state 94
    funct_invoc_list  go to state 216


state 195

   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr
  126 for_single_entry: expr .

    OR        shift, and go to state 96
    AND       shift, and go to state 97
    NOT_EQ    shift, and go to state 98
    GREAT     shift, and go to state 99
    GREAT_EQ  shift, and go to state 100
    EQUAL     shift, and go to state 101
    LESS_EQ   shift, and go to state 102
    LESS      shift, and go to state 103
    MINUS     shift, and go to state 104
    PLUS      shift, and go to state 105
    MOD       shift, and go to state 106
    DIVIDE    shift, and go to state 107
    MULTIPLY  shift, and go to state 108

    $default  reduce using rule 126 (for_single_entry)


state 196

  109 for_init: L_PAREN nonEmpty_for_init .
  111 nonEmpty_for_init: nonEmpty_for_init . COMMA for_single_entry

    COMMA  shift, and go to state 217

    $default  reduce using rule 109 (for_init)


state 197

  112 nonEmpty_for_init: for_single_entry .

    $default  reduce using rule 112 (nonEmpty_for_init)


state 198

  117 for_control: SEMICOLON . nonEmpty_for_control
  118            | SEMICOLON .

    L_PAREN          shift, and go to state 58
    NOT              shift, and go to state 59
    MINUS            shift, and go to state 60
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 61
    CONS_FLOAT       shift, and go to state 62
    CONS_SCIENTIFIC  shift, and go to state 63
    CONS_STRING      shift, and go to state 64
    CONS_BOOL        shift, and go to state 65

    $default  reduce using rule 118 (for_control)

    symbol_id             go to state 218
    literal_constant      go to state 67
    var_ref               go to state 68
    expr                  go to state 219
    nonEmpty_for_control  go to state 220
    for_control_entry     go to state 221
    funct_invoc_ref       go to state 70


state 199

  108 for_st: FOR for_init for_control . for_incre R_PAREN compound_st

    SEMICOLON  shift, and go to state 222

    for_incre  go to state 223


state 200

   73 simple_st: PRINT var_ref SEMICOLON .

    $default  reduce using rule 73 (simple_st)


state 201

   74 simple_st: PRINT expr SEMICOLON .

    $default  reduce using rule 74 (simple_st)


state 202

   75 simple_st: READ var_ref SEMICOLON .

    $default  reduce using rule 75 (simple_st)


state 203

   86 jump_st: RETURN expr SEMICOLON .

    $default  reduce using rule 86 (jump_st)


state 204

  129 funct_invoc_st: symbol_id funct_invoc_list R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 224


state 205

   72 simple_st: var_ref ASSIGN expr . SEMICOLON
   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    OR         shift, and go to state 96
    AND        shift, and go to state 97
    NOT_EQ     shift, and go to state 98
    GREAT      shift, and go to state 99
    GREAT_EQ   shift, and go to state 100
    EQUAL      shift, and go to state 101
    LESS_EQ    shift, and go to state 102
    LESS       shift, and go to state 103
    MINUS      shift, and go to state 104
    PLUS       shift, and go to state 105
    MOD        shift, and go to state 106
    DIVIDE     shift, and go to state 107
    MULTIPLY   shift, and go to state 108
    SEMICOLON  shift, and go to state 225


state 206

   48 definition_list: VOID symbol_id arg_list . R_PAREN compound_st definition_list
   50                | VOID symbol_id arg_list . R_PAREN compound_st

    R_PAREN  shift, and go to state 226


state 207

   47 definition_list: type symbol_id arg_list . R_PAREN compound_st definition_list
   49                | type symbol_id arg_list . R_PAREN compound_st

    R_PAREN  shift, and go to state 227


state 208

   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr
  132 nonEmpty_funct_invoc_list: nonEmpty_funct_invoc_list COMMA expr .

    OR        shift, and go to state 96
    AND       shift, and go to state 97
    NOT_EQ    shift, and go to state 98
    GREAT     shift, and go to state 99
    GREAT_EQ  shift, and go to state 100
    EQUAL     shift, and go to state 101
    LESS_EQ   shift, and go to state 102
    LESS      shift, and go to state 103
    MINUS     shift, and go to state 104
    PLUS      shift, and go to state 105
    MOD       shift, and go to state 106
    DIVIDE    shift, and go to state 107
    MULTIPLY  shift, and go to state 108

    $default  reduce using rule 132 (nonEmpty_funct_invoc_list)


state 209

   34 nonEmpty_init_arr_list: nonEmpty_init_arr_list COMMA expr .
   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    OR        shift, and go to state 96
    AND       shift, and go to state 97
    NOT_EQ    shift, and go to state 98
    GREAT     shift, and go to state 99
    GREAT_EQ  shift, and go to state 100
    EQUAL     shift, and go to state 101
    LESS_EQ   shift, and go to state 102
    LESS      shift, and go to state 103
    MINUS     shift, and go to state 104
    PLUS      shift, and go to state 105
    MOD       shift, and go to state 106
    DIVIDE    shift, and go to state 107
    MULTIPLY  shift, and go to state 108

    $default  reduce using rule 34 (nonEmpty_init_arr_list)


state 210

   84 while_st: WHILE L_PAREN bool_expr R_PAREN . compound_st

    L_BRACE  shift, and go to state 79

    compound_st    go to state 228
    compound_list  go to state 82


state 211

   85 while_st: DO compound_st WHILE L_PAREN . bool_expr R_PAREN SEMICOLON

    L_PAREN          shift, and go to state 58
    NOT              shift, and go to state 59
    MINUS            shift, and go to state 60
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 61
    CONS_FLOAT       shift, and go to state 62
    CONS_SCIENTIFIC  shift, and go to state 63
    CONS_STRING      shift, and go to state 64
    CONS_BOOL        shift, and go to state 65

    symbol_id         go to state 66
    literal_constant  go to state 67
    var_ref           go to state 68
    bool_expr         go to state 229
    expr              go to state 191
    funct_invoc_ref   go to state 70


state 212

   81 condition_st: IF L_PAREN bool_expr R_PAREN . compound_st
   82             | IF L_PAREN bool_expr R_PAREN . compound_st ELSE compound_st

    L_BRACE  shift, and go to state 79

    compound_st    go to state 230
    compound_list  go to state 82


state 213

   25 array_indice: L_BRACKET . CONS_INTEGER R_BRACKET
   80 arr_ref_index: L_BRACKET . expr R_BRACKET

    L_PAREN          shift, and go to state 58
    NOT              shift, and go to state 59
    MINUS            shift, and go to state 60
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 231
    CONS_FLOAT       shift, and go to state 62
    CONS_SCIENTIFIC  shift, and go to state 63
    CONS_STRING      shift, and go to state 64
    CONS_BOOL        shift, and go to state 65

    symbol_id         go to state 66
    literal_constant  go to state 67
    var_ref           go to state 68
    expr              go to state 147
    funct_invoc_ref   go to state 70


state 214

  124 for_single_entry: symbol_id ASSIGN . expr

    L_PAREN          shift, and go to state 58
    NOT              shift, and go to state 59
    MINUS            shift, and go to state 60
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 61
    CONS_FLOAT       shift, and go to state 62
    CONS_SCIENTIFIC  shift, and go to state 63
    CONS_STRING      shift, and go to state 64
    CONS_BOOL        shift, and go to state 65

    symbol_id         go to state 66
    literal_constant  go to state 67
    var_ref           go to state 68
    expr              go to state 232
    funct_invoc_ref   go to state 70


state 215

   24 array_indice: array_indice . L_BRACKET CONS_INTEGER R_BRACKET
  125 for_single_entry: symbol_id array_indice . ASSIGN init_array

    L_BRACKET  shift, and go to state 71
    ASSIGN     shift, and go to state 233


state 216

  127 for_single_entry: symbol_id funct_invoc_list . R_PAREN
  128 funct_invoc_ref: symbol_id funct_invoc_list . R_PAREN

    R_PAREN  shift, and go to state 234


state 217

  111 nonEmpty_for_init: nonEmpty_for_init COMMA . for_single_entry

    L_PAREN          shift, and go to state 58
    NOT              shift, and go to state 59
    MINUS            shift, and go to state 60
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 61
    CONS_FLOAT       shift, and go to state 62
    CONS_SCIENTIFIC  shift, and go to state 63
    CONS_STRING      shift, and go to state 64
    CONS_BOOL        shift, and go to state 65

    symbol_id         go to state 194
    literal_constant  go to state 67
    var_ref           go to state 68
    expr              go to state 195
    for_single_entry  go to state 235
    funct_invoc_ref   go to state 70


state 218

   76 var_ref: symbol_id .
   77        | symbol_id . arr_ref_indice
  122 for_control_entry: symbol_id . ASSIGN expr
  123                  | symbol_id . array_indice ASSIGN init_array
  128 funct_invoc_ref: symbol_id . funct_invoc_list R_PAREN

    L_PAREN    shift, and go to state 91
    L_BRACKET  shift, and go to state 213
    ASSIGN     shift, and go to state 236

    $default  reduce using rule 76 (var_ref)

    array_indice      go to state 237
    arr_ref_indice    go to state 93
    arr_ref_index     go to state 94
    funct_invoc_list  go to state 95


state 219

   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr
  121 for_control_entry: expr .

    OR        shift, and go to state 96
    AND       shift, and go to state 97
    NOT_EQ    shift, and go to state 98
    GREAT     shift, and go to state 99
    GREAT_EQ  shift, and go to state 100
    EQUAL     shift, and go to state 101
    LESS_EQ   shift, and go to state 102
    LESS      shift, and go to state 103
    MINUS     shift, and go to state 104
    PLUS      shift, and go to state 105
    MOD       shift, and go to state 106
    DIVIDE    shift, and go to state 107
    MULTIPLY  shift, and go to state 108

    $default  reduce using rule 121 (for_control_entry)


state 220

  117 for_control: SEMICOLON nonEmpty_for_control .
  119 nonEmpty_for_control: nonEmpty_for_control . COMMA for_control_entry

    COMMA  shift, and go to state 238

    $default  reduce using rule 117 (for_control)


state 221

  120 nonEmpty_for_control: for_control_entry .

    $default  reduce using rule 120 (nonEmpty_for_control)


state 222

  113 for_incre: SEMICOLON . nonEmpty_for_incre
  114          | SEMICOLON .

    L_PAREN          shift, and go to state 58
    NOT              shift, and go to state 59
    MINUS            shift, and go to state 60
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 61
    CONS_FLOAT       shift, and go to state 62
    CONS_SCIENTIFIC  shift, and go to state 63
    CONS_STRING      shift, and go to state 64
    CONS_BOOL        shift, and go to state 65

    $default  reduce using rule 114 (for_incre)

    symbol_id           go to state 194
    literal_constant    go to state 67
    var_ref             go to state 68
    expr                go to state 195
    nonEmpty_for_incre  go to state 239
    for_single_entry    go to state 240
    funct_invoc_ref     go to state 70


state 223

  108 for_st: FOR for_init for_control for_incre . R_PAREN compound_st

    R_PAREN  shift, and go to state 241


state 224

  129 funct_invoc_st: symbol_id funct_invoc_list R_PAREN SEMICOLON .

    $default  reduce using rule 129 (funct_invoc_st)


state 225

   72 simple_st: var_ref ASSIGN expr SEMICOLON .

    $default  reduce using rule 72 (simple_st)


state 226

   48 definition_list: VOID symbol_id arg_list R_PAREN . compound_st definition_list
   50                | VOID symbol_id arg_list R_PAREN . compound_st

    L_BRACE  shift, and go to state 79

    compound_st    go to state 81
    compound_list  go to state 82


state 227

   47 definition_list: type symbol_id arg_list R_PAREN . compound_st definition_list
   49                | type symbol_id arg_list R_PAREN . compound_st

    L_BRACE  shift, and go to state 79

    compound_st    go to state 114
    compound_list  go to state 82


state 228

   84 while_st: WHILE L_PAREN bool_expr R_PAREN compound_st .

    $default  reduce using rule 84 (while_st)


state 229

   85 while_st: DO compound_st WHILE L_PAREN bool_expr . R_PAREN SEMICOLON

    R_PAREN  shift, and go to state 242


state 230

   81 condition_st: IF L_PAREN bool_expr R_PAREN compound_st .
   82             | IF L_PAREN bool_expr R_PAREN compound_st . ELSE compound_st

    ELSE  shift, and go to state 243

    $default  reduce using rule 81 (condition_st)


state 231

   25 array_indice: L_BRACKET CONS_INTEGER . R_BRACKET
   40 literal_constant: CONS_INTEGER .

    R_BRACKET  shift, and go to state 87

    R_BRACKET  [reduce using rule 40 (literal_constant)]
    $default   reduce using rule 40 (literal_constant)


state 232

   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr
  124 for_single_entry: symbol_id ASSIGN expr .

    OR        shift, and go to state 96
    AND       shift, and go to state 97
    NOT_EQ    shift, and go to state 98
    GREAT     shift, and go to state 99
    GREAT_EQ  shift, and go to state 100
    EQUAL     shift, and go to state 101
    LESS_EQ   shift, and go to state 102
    LESS      shift, and go to state 103
    MINUS     shift, and go to state 104
    PLUS      shift, and go to state 105
    MOD       shift, and go to state 106
    DIVIDE    shift, and go to state 107
    MULTIPLY  shift, and go to state 108

    $default  reduce using rule 124 (for_single_entry)


state 233

  125 for_single_entry: symbol_id array_indice ASSIGN . init_array

    L_BRACE  shift, and go to state 110

    init_array     go to state 244
    init_arr_list  go to state 112


state 234

  127 for_single_entry: symbol_id funct_invoc_list R_PAREN .
  128 funct_invoc_ref: symbol_id funct_invoc_list R_PAREN .

    R_PAREN    reduce using rule 127 (for_single_entry)
    R_PAREN    [reduce using rule 128 (funct_invoc_ref)]
    SEMICOLON  reduce using rule 127 (for_single_entry)
    SEMICOLON  [reduce using rule 128 (funct_invoc_ref)]
    COMMA      reduce using rule 127 (for_single_entry)
    COMMA      [reduce using rule 128 (funct_invoc_ref)]
    $default   reduce using rule 128 (funct_invoc_ref)


state 235

  111 nonEmpty_for_init: nonEmpty_for_init COMMA for_single_entry .

    $default  reduce using rule 111 (nonEmpty_for_init)


state 236

  122 for_control_entry: symbol_id ASSIGN . expr

    L_PAREN          shift, and go to state 58
    NOT              shift, and go to state 59
    MINUS            shift, and go to state 60
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 61
    CONS_FLOAT       shift, and go to state 62
    CONS_SCIENTIFIC  shift, and go to state 63
    CONS_STRING      shift, and go to state 64
    CONS_BOOL        shift, and go to state 65

    symbol_id         go to state 66
    literal_constant  go to state 67
    var_ref           go to state 68
    expr              go to state 245
    funct_invoc_ref   go to state 70


state 237

   24 array_indice: array_indice . L_BRACKET CONS_INTEGER R_BRACKET
  123 for_control_entry: symbol_id array_indice . ASSIGN init_array

    L_BRACKET  shift, and go to state 71
    ASSIGN     shift, and go to state 246


state 238

  119 nonEmpty_for_control: nonEmpty_for_control COMMA . for_control_entry

    L_PAREN          shift, and go to state 58
    NOT              shift, and go to state 59
    MINUS            shift, and go to state 60
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 61
    CONS_FLOAT       shift, and go to state 62
    CONS_SCIENTIFIC  shift, and go to state 63
    CONS_STRING      shift, and go to state 64
    CONS_BOOL        shift, and go to state 65

    symbol_id          go to state 218
    literal_constant   go to state 67
    var_ref            go to state 68
    expr               go to state 219
    for_control_entry  go to state 247
    funct_invoc_ref    go to state 70


state 239

  113 for_incre: SEMICOLON nonEmpty_for_incre .
  115 nonEmpty_for_incre: nonEmpty_for_incre . COMMA for_single_entry

    COMMA  shift, and go to state 248

    $default  reduce using rule 113 (for_incre)


state 240

  116 nonEmpty_for_incre: for_single_entry .

    $default  reduce using rule 116 (nonEmpty_for_incre)


state 241

  108 for_st: FOR for_init for_control for_incre R_PAREN . compound_st

    L_BRACE  shift, and go to state 79

    compound_st    go to state 249
    compound_list  go to state 82


state 242

   85 while_st: DO compound_st WHILE L_PAREN bool_expr R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 250


state 243

   82 condition_st: IF L_PAREN bool_expr R_PAREN compound_st ELSE . compound_st

    L_BRACE  shift, and go to state 79

    compound_st    go to state 251
    compound_list  go to state 82


state 244

  125 for_single_entry: symbol_id array_indice ASSIGN init_array .

    $default  reduce using rule 125 (for_single_entry)


state 245

   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr
  122 for_control_entry: symbol_id ASSIGN expr .

    OR        shift, and go to state 96
    AND       shift, and go to state 97
    NOT_EQ    shift, and go to state 98
    GREAT     shift, and go to state 99
    GREAT_EQ  shift, and go to state 100
    EQUAL     shift, and go to state 101
    LESS_EQ   shift, and go to state 102
    LESS      shift, and go to state 103
    MINUS     shift, and go to state 104
    PLUS      shift, and go to state 105
    MOD       shift, and go to state 106
    DIVIDE    shift, and go to state 107
    MULTIPLY  shift, and go to state 108

    $default  reduce using rule 122 (for_control_entry)


state 246

  123 for_control_entry: symbol_id array_indice ASSIGN . init_array

    L_BRACE  shift, and go to state 110

    init_array     go to state 252
    init_arr_list  go to state 112


state 247

  119 nonEmpty_for_control: nonEmpty_for_control COMMA for_control_entry .

    $default  reduce using rule 119 (nonEmpty_for_control)


state 248

  115 nonEmpty_for_incre: nonEmpty_for_incre COMMA . for_single_entry

    L_PAREN          shift, and go to state 58
    NOT              shift, and go to state 59
    MINUS            shift, and go to state 60
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 61
    CONS_FLOAT       shift, and go to state 62
    CONS_SCIENTIFIC  shift, and go to state 63
    CONS_STRING      shift, and go to state 64
    CONS_BOOL        shift, and go to state 65

    symbol_id         go to state 194
    literal_constant  go to state 67
    var_ref           go to state 68
    expr              go to state 195
    for_single_entry  go to state 253
    funct_invoc_ref   go to state 70


state 249

  108 for_st: FOR for_init for_control for_incre R_PAREN compound_st .

    $default  reduce using rule 108 (for_st)


state 250

   85 while_st: DO compound_st WHILE L_PAREN bool_expr R_PAREN SEMICOLON .

    $default  reduce using rule 85 (while_st)


state 251

   82 condition_st: IF L_PAREN bool_expr R_PAREN compound_st ELSE compound_st .

    $default  reduce using rule 82 (condition_st)


state 252

  123 for_control_entry: symbol_id array_indice ASSIGN init_array .

    $default  reduce using rule 123 (for_control_entry)


state 253

  115 nonEmpty_for_incre: nonEmpty_for_incre COMMA for_single_entry .

    $default  reduce using rule 115 (nonEmpty_for_incre)
