State 17 conflicts: 8 shift/reduce
State 23 conflicts: 8 shift/reduce
State 25 conflicts: 8 shift/reduce
State 26 conflicts: 8 reduce/reduce
State 27 conflicts: 8 reduce/reduce
State 28 conflicts: 8 reduce/reduce
State 29 conflicts: 8 reduce/reduce
State 34 conflicts: 8 shift/reduce
State 93 conflicts: 13 shift/reduce
State 179 conflicts: 1 shift/reduce
State 187 conflicts: 19 reduce/reduce
State 188 conflicts: 19 reduce/reduce
State 191 conflicts: 19 reduce/reduce
State 239 conflicts: 1 shift/reduce
State 242 conflicts: 3 reduce/reduce


Grammar

    0 $accept: program $end

    1 program: decl_and_def_list

    2 decl_and_def_list: decl_and_def_list declaration_list
    3                  | declaration_list decl_and_def_list
    4                  | definition_list
    5                  | definition_list decl_and_def_list

    6 declaration_list: declaration_list const_decl
    7                 | declaration_list var_decl
    8                 | declaration_list funct_decl
    9                 | declaration_list proc_decl
   10                 | const_decl
   11                 | var_decl
   12                 | funct_decl
   13                 | proc_decl

   14 var_decl: type var_list SEMICOLON

   15 type: INT
   16     | DOUBLE
   17     | FLOAT
   18     | STRING
   19     | BOOL
   20     | BOOLEAN

   21 identifier: symbol_id
   22           | symbol_id array_indice

   23 symbol_id: ID

   24 array_indice: array_indice L_BRACKET CONS_INTEGER R_BRACKET
   25             | L_BRACKET CONS_INTEGER R_BRACKET

   26 var_list: var_list COMMA var_single
   27         | var_single

   28 var_single: identifier
   29           | symbol_id ASSIGN expr
   30           | symbol_id array_indice ASSIGN init_array

   31 init_array: init_arr_list R_BRACE

   32 init_arr_list: L_BRACE nonEmpty_init_arr_list
   33              | L_BRACE

   34 nonEmpty_init_arr_list: nonEmpty_init_arr_list COMMA expr
   35                       | expr

   36 const_decl: CONST type const_list SEMICOLON

   37 const_list: const_init COMMA const_list
   38           | const_init

   39 const_init: symbol_id ASSIGN literal_constant

   40 literal_constant: CONS_INTEGER
   41                 | CONS_FLOAT
   42                 | CONS_SCIENTIFIC
   43                 | CONS_STRING
   44                 | CONS_BOOL

   45 funct_decl: type symbol_id arg_list R_PAREN SEMICOLON

   46 proc_decl: VOID symbol_id arg_list R_PAREN SEMICOLON

   47 definition_list: type symbol_id arg_list R_PAREN compound_st definition_list
   48                | VOID symbol_id arg_list R_PAREN compound_st definition_list
   49                | type symbol_id arg_list R_PAREN compound_st
   50                | VOID symbol_id arg_list R_PAREN compound_st

   51 arg_list: L_PAREN nonEmpty_arg_list
   52         | L_PAREN

   53 nonEmpty_arg_list: arg COMMA nonEmpty_arg_list
   54                  | arg

   55 arg: type identifier

   56 compound_st: compound_list R_BRACE

   57 compound_list: L_BRACE nonEmpty_compound_list
   58              | L_BRACE

   59 nonEmpty_compound_list: var_const_decl_list nonEmpty_compound_list
   60                       | stat_list nonEmpty_compound_list
   61                       | var_const_decl_list
   62                       | stat_list

   63 var_const_decl_list: var_const_decl_list var_decl
   64                    | var_const_decl_list const_decl
   65                    | var_decl
   66                    | const_decl

   67 stat_list: stat_list statement
   68          | statement

   69 statement: compound_st
   70          | simple_st
   71          | condition_st
   72          | while_st
   73          | for_st
   74          | jump_st
   75          | funct_invoc_st

   76 simple_st: var_ref ASSIGN expr SEMICOLON
   77          | PRINT var_ref SEMICOLON
   78          | PRINT expr SEMICOLON
   79          | READ var_ref SEMICOLON

   80 var_ref: symbol_id
   81        | symbol_id arr_ref_indice

   82 arr_ref_indice: arr_ref_index arr_ref_indice
   83               | arr_ref_index

   84 arr_ref_index: L_BRACKET expr R_BRACKET

   85 condition_st: IF L_PAREN bool_expr R_PAREN compound_st
   86             | IF L_PAREN bool_expr R_PAREN compound_st ELSE compound_st

   87 bool_expr: expr

   88 while_st: WHILE L_PAREN bool_expr R_PAREN compound_st
   89         | DO compound_st WHILE L_PAREN bool_expr R_PAREN SEMICOLON

   90 jump_st: RETURN expr SEMICOLON
   91        | BREAK SEMICOLON
   92        | CONTINUE SEMICOLON

   93 expr: L_PAREN expr R_PAREN
   94     | expr OR expr
   95     | expr AND expr
   96     | NOT expr
   97     | expr LESS expr
   98     | expr LESS_EQ expr
   99     | expr EQUAL expr
  100     | expr GREAT_EQ expr
  101     | expr GREAT expr
  102     | expr NOT_EQ expr
  103     | expr PLUS expr
  104     | expr MINUS expr
  105     | expr MULTIPLY expr
  106     | expr DIVIDE expr
  107     | expr MOD expr
  108     | MINUS expr
  109     | literal_constant
  110     | var_ref
  111     | funct_invoc_ref

  112 for_st: FOR for_init for_control for_incre R_PAREN compound_st

  113 for_init: L_PAREN nonEmpty_for_init
  114         | L_PAREN

  115 nonEmpty_for_init: nonEmpty_for_init COMMA for_single_entry
  116                  | for_single_entry

  117 for_incre: SEMICOLON nonEmpty_for_incre
  118          | SEMICOLON

  119 nonEmpty_for_incre: nonEmpty_for_incre COMMA for_single_entry
  120                   | for_single_entry

  121 for_control: SEMICOLON nonEmpty_for_control
  122            | SEMICOLON

  123 nonEmpty_for_control: nonEmpty_for_control COMMA for_control_entry
  124                     | for_control_entry

  125 for_control_entry: expr
  126                  | symbol_id ASSIGN expr
  127                  | symbol_id array_indice ASSIGN init_array

  128 for_single_entry: symbol_id ASSIGN expr
  129                 | symbol_id array_indice ASSIGN init_array
  130                 | expr
  131                 | symbol_id funct_invoc_list R_PAREN

  132 funct_invoc_ref: symbol_id funct_invoc_list R_PAREN

  133 funct_invoc_st: symbol_id funct_invoc_list R_PAREN SEMICOLON

  134 funct_invoc_list: L_PAREN
  135                 | L_PAREN nonEmpty_funct_invoc_list

  136 nonEmpty_funct_invoc_list: nonEmpty_funct_invoc_list COMMA expr
  137                          | expr


Terminals, with rules where they appear

$end (0) 0
error (256)
VOID (258) 46 48 50
CONST (259) 36
STRING (260) 18
DOUBLE (261) 16
FLOAT (262) 17
BOOL (263) 19
INT (264) 15
BOOLEAN (265) 20
L_PAREN (266) 51 52 85 86 88 89 93 113 114 134 135
R_PAREN (267) 45 46 47 48 49 50 85 86 88 89 93 112 131 132 133
L_BRACKET (268) 24 25 84
R_BRACKET (269) 24 25 84
L_BRACE (270) 32 33 57 58
R_BRACE (271) 31 56
OR (272) 94
AND (273) 95
NOT (274) 96
NOT_EQ (275) 102
GREAT (276) 101
GREAT_EQ (277) 100
EQUAL (278) 99
LESS_EQ (279) 98
LESS (280) 97
MINUS (281) 104 108
PLUS (282) 103
MOD (283) 107
DIVIDE (284) 106
MULTIPLY (285) 105
ASSIGN (286) 29 30 39 76 126 127 128 129
WHILE (287) 88 89
DO (288) 89
IF (289) 85 86
ELSE (290) 86
FOR (291) 112
PRINT (292) 77 78
READ (293) 79
CONTINUE (294) 92
BREAK (295) 91
RETURN (296) 90
ID (297) 23
SEMICOLON (298) 14 36 45 46 76 77 78 79 89 90 91 92 117 118 121 122
    133
COMMA (299) 26 34 37 53 115 119 123 136
CONS_INTEGER (300) 24 25 40
CONS_FLOAT (301) 41
CONS_SCIENTIFIC (302) 42
CONS_STRING (303) 43
CONS_BOOL (304) 44


Nonterminals, with rules where they appear

$accept (50)
    on left: 0
program (51)
    on left: 1, on right: 0
decl_and_def_list (52)
    on left: 2 3 4 5, on right: 1 2 3 5
declaration_list (53)
    on left: 6 7 8 9 10 11 12 13, on right: 2 3 6 7 8 9
var_decl (54)
    on left: 14, on right: 7 11 63 65
type (55)
    on left: 15 16 17 18 19 20, on right: 14 36 45 47 49 55
identifier (56)
    on left: 21 22, on right: 28 55
symbol_id (57)
    on left: 23, on right: 21 22 29 30 39 45 46 47 48 49 50 80 81 126
    127 128 129 131 132 133
array_indice (58)
    on left: 24 25, on right: 22 24 30 127 129
var_list (59)
    on left: 26 27, on right: 14 26
var_single (60)
    on left: 28 29 30, on right: 26 27
init_array (61)
    on left: 31, on right: 30 127 129
init_arr_list (62)
    on left: 32 33, on right: 31
nonEmpty_init_arr_list (63)
    on left: 34 35, on right: 32 34
const_decl (64)
    on left: 36, on right: 6 10 64 66
const_list (65)
    on left: 37 38, on right: 36 37
const_init (66)
    on left: 39, on right: 37 38
literal_constant (67)
    on left: 40 41 42 43 44, on right: 39 109
funct_decl (68)
    on left: 45, on right: 8 12
proc_decl (69)
    on left: 46, on right: 9 13
definition_list (70)
    on left: 47 48 49 50, on right: 4 5 47 48
arg_list (71)
    on left: 51 52, on right: 45 46 47 48 49 50
nonEmpty_arg_list (72)
    on left: 53 54, on right: 51 53
arg (73)
    on left: 55, on right: 53 54
compound_st (74)
    on left: 56, on right: 47 48 49 50 69 85 86 88 89 112
compound_list (75)
    on left: 57 58, on right: 56
nonEmpty_compound_list (76)
    on left: 59 60 61 62, on right: 57 59 60
var_const_decl_list (77)
    on left: 63 64 65 66, on right: 59 61 63 64
stat_list (78)
    on left: 67 68, on right: 60 62 67
statement (79)
    on left: 69 70 71 72 73 74 75, on right: 67 68
simple_st (80)
    on left: 76 77 78 79, on right: 70
var_ref (81)
    on left: 80 81, on right: 76 77 79 110
arr_ref_indice (82)
    on left: 82 83, on right: 81 82
arr_ref_index (83)
    on left: 84, on right: 82 83
condition_st (84)
    on left: 85 86, on right: 71
bool_expr (85)
    on left: 87, on right: 85 86 88 89
while_st (86)
    on left: 88 89, on right: 72
jump_st (87)
    on left: 90 91 92, on right: 74
expr (88)
    on left: 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108
    109 110 111, on right: 29 34 35 76 78 84 87 90 93 94 95 96 97 98
    99 100 101 102 103 104 105 106 107 108 125 126 128 130 136 137
for_st (89)
    on left: 112, on right: 73
for_init (90)
    on left: 113 114, on right: 112
nonEmpty_for_init (91)
    on left: 115 116, on right: 113 115
for_incre (92)
    on left: 117 118, on right: 112
nonEmpty_for_incre (93)
    on left: 119 120, on right: 117 119
for_control (94)
    on left: 121 122, on right: 112
nonEmpty_for_control (95)
    on left: 123 124, on right: 121 123
for_control_entry (96)
    on left: 125 126 127, on right: 123 124
for_single_entry (97)
    on left: 128 129 130 131, on right: 115 116 119 120
funct_invoc_ref (98)
    on left: 132, on right: 111
funct_invoc_st (99)
    on left: 133, on right: 75
funct_invoc_list (100)
    on left: 134 135, on right: 131 132 133
nonEmpty_funct_invoc_list (101)
    on left: 136 137, on right: 135 136


state 0

    0 $accept: . program $end

    VOID     shift, and go to state 1
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    program            go to state 9
    decl_and_def_list  go to state 10
    declaration_list   go to state 11
    var_decl           go to state 12
    type               go to state 13
    const_decl         go to state 14
    funct_decl         go to state 15
    proc_decl          go to state 16
    definition_list    go to state 17


state 1

   46 proc_decl: VOID . symbol_id arg_list R_PAREN SEMICOLON
   48 definition_list: VOID . symbol_id arg_list R_PAREN compound_st definition_list
   50                | VOID . symbol_id arg_list R_PAREN compound_st

    ID  shift, and go to state 18

    symbol_id  go to state 19


state 2

   36 const_decl: CONST . type const_list SEMICOLON

    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    type  go to state 20


state 3

   18 type: STRING .

    $default  reduce using rule 18 (type)


state 4

   16 type: DOUBLE .

    $default  reduce using rule 16 (type)


state 5

   17 type: FLOAT .

    $default  reduce using rule 17 (type)


state 6

   19 type: BOOL .

    $default  reduce using rule 19 (type)


state 7

   15 type: INT .

    $default  reduce using rule 15 (type)


state 8

   20 type: BOOLEAN .

    $default  reduce using rule 20 (type)


state 9

    0 $accept: program . $end

    $end  shift, and go to state 21


state 10

    1 program: decl_and_def_list .
    2 decl_and_def_list: decl_and_def_list . declaration_list

    VOID     shift, and go to state 22
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    $default  reduce using rule 1 (program)

    declaration_list  go to state 23
    var_decl          go to state 12
    type              go to state 24
    const_decl        go to state 14
    funct_decl        go to state 15
    proc_decl         go to state 16


state 11

    3 decl_and_def_list: declaration_list . decl_and_def_list
    6 declaration_list: declaration_list . const_decl
    7                 | declaration_list . var_decl
    8                 | declaration_list . funct_decl
    9                 | declaration_list . proc_decl

    VOID     shift, and go to state 1
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    decl_and_def_list  go to state 25
    declaration_list   go to state 11
    var_decl           go to state 26
    type               go to state 13
    const_decl         go to state 27
    funct_decl         go to state 28
    proc_decl          go to state 29
    definition_list    go to state 17


state 12

   11 declaration_list: var_decl .

    $default  reduce using rule 11 (declaration_list)


state 13

   14 var_decl: type . var_list SEMICOLON
   45 funct_decl: type . symbol_id arg_list R_PAREN SEMICOLON
   47 definition_list: type . symbol_id arg_list R_PAREN compound_st definition_list
   49                | type . symbol_id arg_list R_PAREN compound_st

    ID  shift, and go to state 18

    identifier  go to state 30
    symbol_id   go to state 31
    var_list    go to state 32
    var_single  go to state 33


state 14

   10 declaration_list: const_decl .

    $default  reduce using rule 10 (declaration_list)


state 15

   12 declaration_list: funct_decl .

    $default  reduce using rule 12 (declaration_list)


state 16

   13 declaration_list: proc_decl .

    $default  reduce using rule 13 (declaration_list)


state 17

    4 decl_and_def_list: definition_list .
    5                  | definition_list . decl_and_def_list

    VOID     shift, and go to state 1
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    VOID      [reduce using rule 4 (decl_and_def_list)]
    CONST     [reduce using rule 4 (decl_and_def_list)]
    STRING    [reduce using rule 4 (decl_and_def_list)]
    DOUBLE    [reduce using rule 4 (decl_and_def_list)]
    FLOAT     [reduce using rule 4 (decl_and_def_list)]
    BOOL      [reduce using rule 4 (decl_and_def_list)]
    INT       [reduce using rule 4 (decl_and_def_list)]
    BOOLEAN   [reduce using rule 4 (decl_and_def_list)]
    $default  reduce using rule 4 (decl_and_def_list)

    decl_and_def_list  go to state 34
    declaration_list   go to state 11
    var_decl           go to state 12
    type               go to state 13
    const_decl         go to state 14
    funct_decl         go to state 15
    proc_decl          go to state 16
    definition_list    go to state 17


state 18

   23 symbol_id: ID .

    $default  reduce using rule 23 (symbol_id)


state 19

   46 proc_decl: VOID symbol_id . arg_list R_PAREN SEMICOLON
   48 definition_list: VOID symbol_id . arg_list R_PAREN compound_st definition_list
   50                | VOID symbol_id . arg_list R_PAREN compound_st

    L_PAREN  shift, and go to state 35

    arg_list  go to state 36


state 20

   36 const_decl: CONST type . const_list SEMICOLON

    ID  shift, and go to state 18

    symbol_id   go to state 37
    const_list  go to state 38
    const_init  go to state 39


state 21

    0 $accept: program $end .

    $default  accept


state 22

   46 proc_decl: VOID . symbol_id arg_list R_PAREN SEMICOLON

    ID  shift, and go to state 18

    symbol_id  go to state 40


state 23

    2 decl_and_def_list: decl_and_def_list declaration_list .
    6 declaration_list: declaration_list . const_decl
    7                 | declaration_list . var_decl
    8                 | declaration_list . funct_decl
    9                 | declaration_list . proc_decl

    VOID     shift, and go to state 22
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    VOID      [reduce using rule 2 (decl_and_def_list)]
    CONST     [reduce using rule 2 (decl_and_def_list)]
    STRING    [reduce using rule 2 (decl_and_def_list)]
    DOUBLE    [reduce using rule 2 (decl_and_def_list)]
    FLOAT     [reduce using rule 2 (decl_and_def_list)]
    BOOL      [reduce using rule 2 (decl_and_def_list)]
    INT       [reduce using rule 2 (decl_and_def_list)]
    BOOLEAN   [reduce using rule 2 (decl_and_def_list)]
    $default  reduce using rule 2 (decl_and_def_list)

    var_decl    go to state 41
    type        go to state 24
    const_decl  go to state 42
    funct_decl  go to state 43
    proc_decl   go to state 44


state 24

   14 var_decl: type . var_list SEMICOLON
   45 funct_decl: type . symbol_id arg_list R_PAREN SEMICOLON

    ID  shift, and go to state 18

    identifier  go to state 30
    symbol_id   go to state 45
    var_list    go to state 32
    var_single  go to state 33


state 25

    2 decl_and_def_list: decl_and_def_list . declaration_list
    3                  | declaration_list decl_and_def_list .

    VOID     shift, and go to state 22
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    VOID      [reduce using rule 3 (decl_and_def_list)]
    CONST     [reduce using rule 3 (decl_and_def_list)]
    STRING    [reduce using rule 3 (decl_and_def_list)]
    DOUBLE    [reduce using rule 3 (decl_and_def_list)]
    FLOAT     [reduce using rule 3 (decl_and_def_list)]
    BOOL      [reduce using rule 3 (decl_and_def_list)]
    INT       [reduce using rule 3 (decl_and_def_list)]
    BOOLEAN   [reduce using rule 3 (decl_and_def_list)]
    $default  reduce using rule 3 (decl_and_def_list)

    declaration_list  go to state 23
    var_decl          go to state 12
    type              go to state 24
    const_decl        go to state 14
    funct_decl        go to state 15
    proc_decl         go to state 16


state 26

    7 declaration_list: declaration_list var_decl .
   11                 | var_decl .

    VOID      reduce using rule 7 (declaration_list)
    VOID      [reduce using rule 11 (declaration_list)]
    CONST     reduce using rule 7 (declaration_list)
    CONST     [reduce using rule 11 (declaration_list)]
    STRING    reduce using rule 7 (declaration_list)
    STRING    [reduce using rule 11 (declaration_list)]
    DOUBLE    reduce using rule 7 (declaration_list)
    DOUBLE    [reduce using rule 11 (declaration_list)]
    FLOAT     reduce using rule 7 (declaration_list)
    FLOAT     [reduce using rule 11 (declaration_list)]
    BOOL      reduce using rule 7 (declaration_list)
    BOOL      [reduce using rule 11 (declaration_list)]
    INT       reduce using rule 7 (declaration_list)
    INT       [reduce using rule 11 (declaration_list)]
    BOOLEAN   reduce using rule 7 (declaration_list)
    BOOLEAN   [reduce using rule 11 (declaration_list)]
    $default  reduce using rule 7 (declaration_list)


state 27

    6 declaration_list: declaration_list const_decl .
   10                 | const_decl .

    VOID      reduce using rule 6 (declaration_list)
    VOID      [reduce using rule 10 (declaration_list)]
    CONST     reduce using rule 6 (declaration_list)
    CONST     [reduce using rule 10 (declaration_list)]
    STRING    reduce using rule 6 (declaration_list)
    STRING    [reduce using rule 10 (declaration_list)]
    DOUBLE    reduce using rule 6 (declaration_list)
    DOUBLE    [reduce using rule 10 (declaration_list)]
    FLOAT     reduce using rule 6 (declaration_list)
    FLOAT     [reduce using rule 10 (declaration_list)]
    BOOL      reduce using rule 6 (declaration_list)
    BOOL      [reduce using rule 10 (declaration_list)]
    INT       reduce using rule 6 (declaration_list)
    INT       [reduce using rule 10 (declaration_list)]
    BOOLEAN   reduce using rule 6 (declaration_list)
    BOOLEAN   [reduce using rule 10 (declaration_list)]
    $default  reduce using rule 6 (declaration_list)


state 28

    8 declaration_list: declaration_list funct_decl .
   12                 | funct_decl .

    VOID      reduce using rule 8 (declaration_list)
    VOID      [reduce using rule 12 (declaration_list)]
    CONST     reduce using rule 8 (declaration_list)
    CONST     [reduce using rule 12 (declaration_list)]
    STRING    reduce using rule 8 (declaration_list)
    STRING    [reduce using rule 12 (declaration_list)]
    DOUBLE    reduce using rule 8 (declaration_list)
    DOUBLE    [reduce using rule 12 (declaration_list)]
    FLOAT     reduce using rule 8 (declaration_list)
    FLOAT     [reduce using rule 12 (declaration_list)]
    BOOL      reduce using rule 8 (declaration_list)
    BOOL      [reduce using rule 12 (declaration_list)]
    INT       reduce using rule 8 (declaration_list)
    INT       [reduce using rule 12 (declaration_list)]
    BOOLEAN   reduce using rule 8 (declaration_list)
    BOOLEAN   [reduce using rule 12 (declaration_list)]
    $default  reduce using rule 8 (declaration_list)


state 29

    9 declaration_list: declaration_list proc_decl .
   13                 | proc_decl .

    VOID      reduce using rule 9 (declaration_list)
    VOID      [reduce using rule 13 (declaration_list)]
    CONST     reduce using rule 9 (declaration_list)
    CONST     [reduce using rule 13 (declaration_list)]
    STRING    reduce using rule 9 (declaration_list)
    STRING    [reduce using rule 13 (declaration_list)]
    DOUBLE    reduce using rule 9 (declaration_list)
    DOUBLE    [reduce using rule 13 (declaration_list)]
    FLOAT     reduce using rule 9 (declaration_list)
    FLOAT     [reduce using rule 13 (declaration_list)]
    BOOL      reduce using rule 9 (declaration_list)
    BOOL      [reduce using rule 13 (declaration_list)]
    INT       reduce using rule 9 (declaration_list)
    INT       [reduce using rule 13 (declaration_list)]
    BOOLEAN   reduce using rule 9 (declaration_list)
    BOOLEAN   [reduce using rule 13 (declaration_list)]
    $default  reduce using rule 9 (declaration_list)


state 30

   28 var_single: identifier .

    $default  reduce using rule 28 (var_single)


state 31

   21 identifier: symbol_id .
   22           | symbol_id . array_indice
   29 var_single: symbol_id . ASSIGN expr
   30           | symbol_id . array_indice ASSIGN init_array
   45 funct_decl: type symbol_id . arg_list R_PAREN SEMICOLON
   47 definition_list: type symbol_id . arg_list R_PAREN compound_st definition_list
   49                | type symbol_id . arg_list R_PAREN compound_st

    L_PAREN    shift, and go to state 35
    L_BRACKET  shift, and go to state 46
    ASSIGN     shift, and go to state 47

    $default  reduce using rule 21 (identifier)

    array_indice  go to state 48
    arg_list      go to state 49


state 32

   14 var_decl: type var_list . SEMICOLON
   26 var_list: var_list . COMMA var_single

    SEMICOLON  shift, and go to state 50
    COMMA      shift, and go to state 51


state 33

   27 var_list: var_single .

    $default  reduce using rule 27 (var_list)


state 34

    2 decl_and_def_list: decl_and_def_list . declaration_list
    5                  | definition_list decl_and_def_list .

    VOID     shift, and go to state 22
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    VOID      [reduce using rule 5 (decl_and_def_list)]
    CONST     [reduce using rule 5 (decl_and_def_list)]
    STRING    [reduce using rule 5 (decl_and_def_list)]
    DOUBLE    [reduce using rule 5 (decl_and_def_list)]
    FLOAT     [reduce using rule 5 (decl_and_def_list)]
    BOOL      [reduce using rule 5 (decl_and_def_list)]
    INT       [reduce using rule 5 (decl_and_def_list)]
    BOOLEAN   [reduce using rule 5 (decl_and_def_list)]
    $default  reduce using rule 5 (decl_and_def_list)

    declaration_list  go to state 23
    var_decl          go to state 12
    type              go to state 24
    const_decl        go to state 14
    funct_decl        go to state 15
    proc_decl         go to state 16


state 35

   51 arg_list: L_PAREN . nonEmpty_arg_list
   52         | L_PAREN .

    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    $default  reduce using rule 52 (arg_list)

    type               go to state 52
    nonEmpty_arg_list  go to state 53
    arg                go to state 54


state 36

   46 proc_decl: VOID symbol_id arg_list . R_PAREN SEMICOLON
   48 definition_list: VOID symbol_id arg_list . R_PAREN compound_st definition_list
   50                | VOID symbol_id arg_list . R_PAREN compound_st

    R_PAREN  shift, and go to state 55


state 37

   39 const_init: symbol_id . ASSIGN literal_constant

    ASSIGN  shift, and go to state 56


state 38

   36 const_decl: CONST type const_list . SEMICOLON

    SEMICOLON  shift, and go to state 57


state 39

   37 const_list: const_init . COMMA const_list
   38           | const_init .

    COMMA  shift, and go to state 58

    $default  reduce using rule 38 (const_list)


state 40

   46 proc_decl: VOID symbol_id . arg_list R_PAREN SEMICOLON

    L_PAREN  shift, and go to state 35

    arg_list  go to state 59


state 41

    7 declaration_list: declaration_list var_decl .

    $default  reduce using rule 7 (declaration_list)


state 42

    6 declaration_list: declaration_list const_decl .

    $default  reduce using rule 6 (declaration_list)


state 43

    8 declaration_list: declaration_list funct_decl .

    $default  reduce using rule 8 (declaration_list)


state 44

    9 declaration_list: declaration_list proc_decl .

    $default  reduce using rule 9 (declaration_list)


state 45

   21 identifier: symbol_id .
   22           | symbol_id . array_indice
   29 var_single: symbol_id . ASSIGN expr
   30           | symbol_id . array_indice ASSIGN init_array
   45 funct_decl: type symbol_id . arg_list R_PAREN SEMICOLON

    L_PAREN    shift, and go to state 35
    L_BRACKET  shift, and go to state 46
    ASSIGN     shift, and go to state 47

    $default  reduce using rule 21 (identifier)

    array_indice  go to state 48
    arg_list      go to state 60


state 46

   25 array_indice: L_BRACKET . CONS_INTEGER R_BRACKET

    CONS_INTEGER  shift, and go to state 61


state 47

   29 var_single: symbol_id ASSIGN . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 73
    funct_invoc_ref   go to state 74


state 48

   22 identifier: symbol_id array_indice .
   24 array_indice: array_indice . L_BRACKET CONS_INTEGER R_BRACKET
   30 var_single: symbol_id array_indice . ASSIGN init_array

    L_BRACKET  shift, and go to state 75
    ASSIGN     shift, and go to state 76

    $default  reduce using rule 22 (identifier)


state 49

   45 funct_decl: type symbol_id arg_list . R_PAREN SEMICOLON
   47 definition_list: type symbol_id arg_list . R_PAREN compound_st definition_list
   49                | type symbol_id arg_list . R_PAREN compound_st

    R_PAREN  shift, and go to state 77


state 50

   14 var_decl: type var_list SEMICOLON .

    $default  reduce using rule 14 (var_decl)


state 51

   26 var_list: var_list COMMA . var_single

    ID  shift, and go to state 18

    identifier  go to state 30
    symbol_id   go to state 78
    var_single  go to state 79


state 52

   55 arg: type . identifier

    ID  shift, and go to state 18

    identifier  go to state 80
    symbol_id   go to state 81


state 53

   51 arg_list: L_PAREN nonEmpty_arg_list .

    $default  reduce using rule 51 (arg_list)


state 54

   53 nonEmpty_arg_list: arg . COMMA nonEmpty_arg_list
   54                  | arg .

    COMMA  shift, and go to state 82

    $default  reduce using rule 54 (nonEmpty_arg_list)


state 55

   46 proc_decl: VOID symbol_id arg_list R_PAREN . SEMICOLON
   48 definition_list: VOID symbol_id arg_list R_PAREN . compound_st definition_list
   50                | VOID symbol_id arg_list R_PAREN . compound_st

    L_BRACE    shift, and go to state 83
    SEMICOLON  shift, and go to state 84

    compound_st    go to state 85
    compound_list  go to state 86


state 56

   39 const_init: symbol_id ASSIGN . literal_constant

    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    literal_constant  go to state 87


state 57

   36 const_decl: CONST type const_list SEMICOLON .

    $default  reduce using rule 36 (const_decl)


state 58

   37 const_list: const_init COMMA . const_list

    ID  shift, and go to state 18

    symbol_id   go to state 37
    const_list  go to state 88
    const_init  go to state 39


state 59

   46 proc_decl: VOID symbol_id arg_list . R_PAREN SEMICOLON

    R_PAREN  shift, and go to state 89


state 60

   45 funct_decl: type symbol_id arg_list . R_PAREN SEMICOLON

    R_PAREN  shift, and go to state 90


state 61

   25 array_indice: L_BRACKET CONS_INTEGER . R_BRACKET

    R_BRACKET  shift, and go to state 91


state 62

   93 expr: L_PAREN . expr R_PAREN

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 92
    funct_invoc_ref   go to state 74


state 63

   96 expr: NOT . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 93
    funct_invoc_ref   go to state 74


state 64

  108 expr: MINUS . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 94
    funct_invoc_ref   go to state 74


state 65

   40 literal_constant: CONS_INTEGER .

    $default  reduce using rule 40 (literal_constant)


state 66

   41 literal_constant: CONS_FLOAT .

    $default  reduce using rule 41 (literal_constant)


state 67

   42 literal_constant: CONS_SCIENTIFIC .

    $default  reduce using rule 42 (literal_constant)


state 68

   43 literal_constant: CONS_STRING .

    $default  reduce using rule 43 (literal_constant)


state 69

   44 literal_constant: CONS_BOOL .

    $default  reduce using rule 44 (literal_constant)


state 70

   80 var_ref: symbol_id .
   81        | symbol_id . arr_ref_indice
  132 funct_invoc_ref: symbol_id . funct_invoc_list R_PAREN

    L_PAREN    shift, and go to state 95
    L_BRACKET  shift, and go to state 96

    $default  reduce using rule 80 (var_ref)

    arr_ref_indice    go to state 97
    arr_ref_index     go to state 98
    funct_invoc_list  go to state 99


state 71

  109 expr: literal_constant .

    $default  reduce using rule 109 (expr)


state 72

  110 expr: var_ref .

    $default  reduce using rule 110 (expr)


state 73

   29 var_single: symbol_id ASSIGN expr .
   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    OR        shift, and go to state 100
    AND       shift, and go to state 101
    NOT_EQ    shift, and go to state 102
    GREAT     shift, and go to state 103
    GREAT_EQ  shift, and go to state 104
    EQUAL     shift, and go to state 105
    LESS_EQ   shift, and go to state 106
    LESS      shift, and go to state 107
    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 29 (var_single)


state 74

  111 expr: funct_invoc_ref .

    $default  reduce using rule 111 (expr)


state 75

   24 array_indice: array_indice L_BRACKET . CONS_INTEGER R_BRACKET

    CONS_INTEGER  shift, and go to state 113


state 76

   30 var_single: symbol_id array_indice ASSIGN . init_array

    L_BRACE  shift, and go to state 114

    init_array     go to state 115
    init_arr_list  go to state 116


state 77

   45 funct_decl: type symbol_id arg_list R_PAREN . SEMICOLON
   47 definition_list: type symbol_id arg_list R_PAREN . compound_st definition_list
   49                | type symbol_id arg_list R_PAREN . compound_st

    L_BRACE    shift, and go to state 83
    SEMICOLON  shift, and go to state 117

    compound_st    go to state 118
    compound_list  go to state 86


state 78

   21 identifier: symbol_id .
   22           | symbol_id . array_indice
   29 var_single: symbol_id . ASSIGN expr
   30           | symbol_id . array_indice ASSIGN init_array

    L_BRACKET  shift, and go to state 46
    ASSIGN     shift, and go to state 47

    $default  reduce using rule 21 (identifier)

    array_indice  go to state 48


state 79

   26 var_list: var_list COMMA var_single .

    $default  reduce using rule 26 (var_list)


state 80

   55 arg: type identifier .

    $default  reduce using rule 55 (arg)


state 81

   21 identifier: symbol_id .
   22           | symbol_id . array_indice

    L_BRACKET  shift, and go to state 46

    $default  reduce using rule 21 (identifier)

    array_indice  go to state 119


state 82

   53 nonEmpty_arg_list: arg COMMA . nonEmpty_arg_list

    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    type               go to state 52
    nonEmpty_arg_list  go to state 120
    arg                go to state 54


state 83

   57 compound_list: L_BRACE . nonEmpty_compound_list
   58              | L_BRACE .

    CONST     shift, and go to state 2
    STRING    shift, and go to state 3
    DOUBLE    shift, and go to state 4
    FLOAT     shift, and go to state 5
    BOOL      shift, and go to state 6
    INT       shift, and go to state 7
    BOOLEAN   shift, and go to state 8
    L_BRACE   shift, and go to state 83
    WHILE     shift, and go to state 121
    DO        shift, and go to state 122
    IF        shift, and go to state 123
    FOR       shift, and go to state 124
    PRINT     shift, and go to state 125
    READ      shift, and go to state 126
    CONTINUE  shift, and go to state 127
    BREAK     shift, and go to state 128
    RETURN    shift, and go to state 129
    ID        shift, and go to state 18

    $default  reduce using rule 58 (compound_list)

    var_decl                go to state 130
    type                    go to state 131
    symbol_id               go to state 132
    const_decl              go to state 133
    compound_st             go to state 134
    compound_list           go to state 86
    nonEmpty_compound_list  go to state 135
    var_const_decl_list     go to state 136
    stat_list               go to state 137
    statement               go to state 138
    simple_st               go to state 139
    var_ref                 go to state 140
    condition_st            go to state 141
    while_st                go to state 142
    jump_st                 go to state 143
    for_st                  go to state 144
    funct_invoc_st          go to state 145


state 84

   46 proc_decl: VOID symbol_id arg_list R_PAREN SEMICOLON .

    $default  reduce using rule 46 (proc_decl)


state 85

   48 definition_list: VOID symbol_id arg_list R_PAREN compound_st . definition_list
   50                | VOID symbol_id arg_list R_PAREN compound_st .

    $default  reduce using rule 50 (definition_list)

    type             go to state 147
    definition_list  go to state 148


state 86

   56 compound_st: compound_list . R_BRACE

    R_BRACE  shift, and go to state 149


state 87

   39 const_init: symbol_id ASSIGN literal_constant .

    $default  reduce using rule 39 (const_init)


state 88

   37 const_list: const_init COMMA const_list .

    $default  reduce using rule 37 (const_list)


state 89

   46 proc_decl: VOID symbol_id arg_list R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 84


state 90

   45 funct_decl: type symbol_id arg_list R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 117


state 91

   25 array_indice: L_BRACKET CONS_INTEGER R_BRACKET .

    $default  reduce using rule 25 (array_indice)


state 92

   93 expr: L_PAREN expr . R_PAREN
   94     | expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    R_PAREN   shift, and go to state 150
    OR        shift, and go to state 100
    AND       shift, and go to state 101
    NOT_EQ    shift, and go to state 102
    GREAT     shift, and go to state 103
    GREAT_EQ  shift, and go to state 104
    EQUAL     shift, and go to state 105
    LESS_EQ   shift, and go to state 106
    LESS      shift, and go to state 107
    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112


state 93

   94 expr: expr . OR expr
   95     | expr . AND expr
   96     | NOT expr .
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    OR        shift, and go to state 100
    AND       shift, and go to state 101
    NOT_EQ    shift, and go to state 102
    GREAT     shift, and go to state 103
    GREAT_EQ  shift, and go to state 104
    EQUAL     shift, and go to state 105
    LESS_EQ   shift, and go to state 106
    LESS      shift, and go to state 107
    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    OR        [reduce using rule 96 (expr)]
    AND       [reduce using rule 96 (expr)]
    NOT_EQ    [reduce using rule 96 (expr)]
    GREAT     [reduce using rule 96 (expr)]
    GREAT_EQ  [reduce using rule 96 (expr)]
    EQUAL     [reduce using rule 96 (expr)]
    LESS_EQ   [reduce using rule 96 (expr)]
    LESS      [reduce using rule 96 (expr)]
    MINUS     [reduce using rule 96 (expr)]
    PLUS      [reduce using rule 96 (expr)]
    MOD       [reduce using rule 96 (expr)]
    DIVIDE    [reduce using rule 96 (expr)]
    MULTIPLY  [reduce using rule 96 (expr)]
    $default  reduce using rule 96 (expr)


state 94

   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr
  108     | MINUS expr .

    $default  reduce using rule 108 (expr)


state 95

  134 funct_invoc_list: L_PAREN .
  135                 | L_PAREN . nonEmpty_funct_invoc_list

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    $default  reduce using rule 134 (funct_invoc_list)

    symbol_id                  go to state 70
    literal_constant           go to state 71
    var_ref                    go to state 72
    expr                       go to state 151
    funct_invoc_ref            go to state 74
    nonEmpty_funct_invoc_list  go to state 152


state 96

   84 arr_ref_index: L_BRACKET . expr R_BRACKET

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 153
    funct_invoc_ref   go to state 74


state 97

   81 var_ref: symbol_id arr_ref_indice .

    $default  reduce using rule 81 (var_ref)


state 98

   82 arr_ref_indice: arr_ref_index . arr_ref_indice
   83               | arr_ref_index .

    L_BRACKET  shift, and go to state 96

    $default  reduce using rule 83 (arr_ref_indice)

    arr_ref_indice  go to state 154
    arr_ref_index   go to state 98


state 99

  132 funct_invoc_ref: symbol_id funct_invoc_list . R_PAREN

    R_PAREN  shift, and go to state 155


state 100

   94 expr: expr OR . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 156
    funct_invoc_ref   go to state 74


state 101

   95 expr: expr AND . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 157
    funct_invoc_ref   go to state 74


state 102

  102 expr: expr NOT_EQ . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 158
    funct_invoc_ref   go to state 74


state 103

  101 expr: expr GREAT . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 159
    funct_invoc_ref   go to state 74


state 104

  100 expr: expr GREAT_EQ . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 160
    funct_invoc_ref   go to state 74


state 105

   99 expr: expr EQUAL . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 161
    funct_invoc_ref   go to state 74


state 106

   98 expr: expr LESS_EQ . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 162
    funct_invoc_ref   go to state 74


state 107

   97 expr: expr LESS . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 163
    funct_invoc_ref   go to state 74


state 108

  104 expr: expr MINUS . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 164
    funct_invoc_ref   go to state 74


state 109

  103 expr: expr PLUS . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 165
    funct_invoc_ref   go to state 74


state 110

  107 expr: expr MOD . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 166
    funct_invoc_ref   go to state 74


state 111

  106 expr: expr DIVIDE . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 167
    funct_invoc_ref   go to state 74


state 112

  105 expr: expr MULTIPLY . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 168
    funct_invoc_ref   go to state 74


state 113

   24 array_indice: array_indice L_BRACKET CONS_INTEGER . R_BRACKET

    R_BRACKET  shift, and go to state 169


state 114

   32 init_arr_list: L_BRACE . nonEmpty_init_arr_list
   33              | L_BRACE .

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    $default  reduce using rule 33 (init_arr_list)

    symbol_id               go to state 70
    nonEmpty_init_arr_list  go to state 170
    literal_constant        go to state 71
    var_ref                 go to state 72
    expr                    go to state 171
    funct_invoc_ref         go to state 74


state 115

   30 var_single: symbol_id array_indice ASSIGN init_array .

    $default  reduce using rule 30 (var_single)


state 116

   31 init_array: init_arr_list . R_BRACE

    R_BRACE  shift, and go to state 172


state 117

   45 funct_decl: type symbol_id arg_list R_PAREN SEMICOLON .

    $default  reduce using rule 45 (funct_decl)


state 118

   47 definition_list: type symbol_id arg_list R_PAREN compound_st . definition_list
   49                | type symbol_id arg_list R_PAREN compound_st .

    $default  reduce using rule 49 (definition_list)

    type             go to state 147
    definition_list  go to state 173


state 119

   22 identifier: symbol_id array_indice .
   24 array_indice: array_indice . L_BRACKET CONS_INTEGER R_BRACKET

    L_BRACKET  shift, and go to state 75

    $default  reduce using rule 22 (identifier)


state 120

   53 nonEmpty_arg_list: arg COMMA nonEmpty_arg_list .

    $default  reduce using rule 53 (nonEmpty_arg_list)


state 121

   88 while_st: WHILE . L_PAREN bool_expr R_PAREN compound_st

    L_PAREN  shift, and go to state 174


state 122

   89 while_st: DO . compound_st WHILE L_PAREN bool_expr R_PAREN SEMICOLON

    L_BRACE  shift, and go to state 83

    compound_st    go to state 175
    compound_list  go to state 86


state 123

   85 condition_st: IF . L_PAREN bool_expr R_PAREN compound_st
   86             | IF . L_PAREN bool_expr R_PAREN compound_st ELSE compound_st

    L_PAREN  shift, and go to state 176


state 124

  112 for_st: FOR . for_init for_control for_incre R_PAREN compound_st

    L_PAREN  shift, and go to state 177

    for_init  go to state 178


state 125

   77 simple_st: PRINT . var_ref SEMICOLON
   78          | PRINT . expr SEMICOLON

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 179
    expr              go to state 180
    funct_invoc_ref   go to state 74


state 126

   79 simple_st: READ . var_ref SEMICOLON

    ID  shift, and go to state 18

    symbol_id  go to state 181
    var_ref    go to state 182


state 127

   92 jump_st: CONTINUE . SEMICOLON

    SEMICOLON  shift, and go to state 183


state 128

   91 jump_st: BREAK . SEMICOLON

    SEMICOLON  shift, and go to state 184


state 129

   90 jump_st: RETURN . expr SEMICOLON

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 185
    funct_invoc_ref   go to state 74


state 130

   65 var_const_decl_list: var_decl .

    $default  reduce using rule 65 (var_const_decl_list)


state 131

   14 var_decl: type . var_list SEMICOLON

    ID  shift, and go to state 18

    identifier  go to state 30
    symbol_id   go to state 78
    var_list    go to state 32
    var_single  go to state 33


state 132

   80 var_ref: symbol_id .
   81        | symbol_id . arr_ref_indice
  133 funct_invoc_st: symbol_id . funct_invoc_list R_PAREN SEMICOLON

    L_PAREN    shift, and go to state 95
    L_BRACKET  shift, and go to state 96

    $default  reduce using rule 80 (var_ref)

    arr_ref_indice    go to state 97
    arr_ref_index     go to state 98
    funct_invoc_list  go to state 186


state 133

   66 var_const_decl_list: const_decl .

    $default  reduce using rule 66 (var_const_decl_list)


state 134

   69 statement: compound_st .

    $default  reduce using rule 69 (statement)


state 135

   57 compound_list: L_BRACE nonEmpty_compound_list .

    $default  reduce using rule 57 (compound_list)


state 136

   59 nonEmpty_compound_list: var_const_decl_list . nonEmpty_compound_list
   61                       | var_const_decl_list .
   63 var_const_decl_list: var_const_decl_list . var_decl
   64                    | var_const_decl_list . const_decl

    CONST     shift, and go to state 2
    STRING    shift, and go to state 3
    DOUBLE    shift, and go to state 4
    FLOAT     shift, and go to state 5
    BOOL      shift, and go to state 6
    INT       shift, and go to state 7
    BOOLEAN   shift, and go to state 8
    L_BRACE   shift, and go to state 83
    WHILE     shift, and go to state 121
    DO        shift, and go to state 122
    IF        shift, and go to state 123
    FOR       shift, and go to state 124
    PRINT     shift, and go to state 125
    READ      shift, and go to state 126
    CONTINUE  shift, and go to state 127
    BREAK     shift, and go to state 128
    RETURN    shift, and go to state 129
    ID        shift, and go to state 18

    $default  reduce using rule 61 (nonEmpty_compound_list)

    var_decl                go to state 187
    type                    go to state 131
    symbol_id               go to state 132
    const_decl              go to state 188
    compound_st             go to state 134
    compound_list           go to state 86
    nonEmpty_compound_list  go to state 189
    var_const_decl_list     go to state 136
    stat_list               go to state 137
    statement               go to state 138
    simple_st               go to state 139
    var_ref                 go to state 140
    condition_st            go to state 141
    while_st                go to state 142
    jump_st                 go to state 143
    for_st                  go to state 144
    funct_invoc_st          go to state 145


state 137

   60 nonEmpty_compound_list: stat_list . nonEmpty_compound_list
   62                       | stat_list .
   67 stat_list: stat_list . statement

    CONST     shift, and go to state 2
    STRING    shift, and go to state 3
    DOUBLE    shift, and go to state 4
    FLOAT     shift, and go to state 5
    BOOL      shift, and go to state 6
    INT       shift, and go to state 7
    BOOLEAN   shift, and go to state 8
    L_BRACE   shift, and go to state 83
    WHILE     shift, and go to state 121
    DO        shift, and go to state 122
    IF        shift, and go to state 123
    FOR       shift, and go to state 124
    PRINT     shift, and go to state 125
    READ      shift, and go to state 126
    CONTINUE  shift, and go to state 127
    BREAK     shift, and go to state 128
    RETURN    shift, and go to state 129
    ID        shift, and go to state 18

    $default  reduce using rule 62 (nonEmpty_compound_list)

    var_decl                go to state 130
    type                    go to state 131
    symbol_id               go to state 132
    const_decl              go to state 133
    compound_st             go to state 134
    compound_list           go to state 86
    nonEmpty_compound_list  go to state 190
    var_const_decl_list     go to state 136
    stat_list               go to state 137
    statement               go to state 191
    simple_st               go to state 139
    var_ref                 go to state 140
    condition_st            go to state 141
    while_st                go to state 142
    jump_st                 go to state 143
    for_st                  go to state 144
    funct_invoc_st          go to state 145


state 138

   68 stat_list: statement .

    $default  reduce using rule 68 (stat_list)


state 139

   70 statement: simple_st .

    $default  reduce using rule 70 (statement)


state 140

   76 simple_st: var_ref . ASSIGN expr SEMICOLON

    ASSIGN  shift, and go to state 192


state 141

   71 statement: condition_st .

    $default  reduce using rule 71 (statement)


state 142

   72 statement: while_st .

    $default  reduce using rule 72 (statement)


state 143

   74 statement: jump_st .

    $default  reduce using rule 74 (statement)


state 144

   73 statement: for_st .

    $default  reduce using rule 73 (statement)


state 145

   75 statement: funct_invoc_st .

    $default  reduce using rule 75 (statement)


state 146

   48 definition_list: VOID . symbol_id arg_list R_PAREN compound_st definition_list
   50                | VOID . symbol_id arg_list R_PAREN compound_st

    ID  shift, and go to state 18

    symbol_id  go to state 193


state 147

   47 definition_list: type . symbol_id arg_list R_PAREN compound_st definition_list
   49                | type . symbol_id arg_list R_PAREN compound_st

    ID  shift, and go to state 18

    symbol_id  go to state 194


state 148

   48 definition_list: VOID symbol_id arg_list R_PAREN compound_st definition_list .

    $default  reduce using rule 48 (definition_list)


state 149

   56 compound_st: compound_list R_BRACE .

    $default  reduce using rule 56 (compound_st)


state 150

   93 expr: L_PAREN expr R_PAREN .

    $default  reduce using rule 93 (expr)


state 151

   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr
  137 nonEmpty_funct_invoc_list: expr .

    OR        shift, and go to state 100
    AND       shift, and go to state 101
    NOT_EQ    shift, and go to state 102
    GREAT     shift, and go to state 103
    GREAT_EQ  shift, and go to state 104
    EQUAL     shift, and go to state 105
    LESS_EQ   shift, and go to state 106
    LESS      shift, and go to state 107
    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 137 (nonEmpty_funct_invoc_list)


state 152

  135 funct_invoc_list: L_PAREN nonEmpty_funct_invoc_list .
  136 nonEmpty_funct_invoc_list: nonEmpty_funct_invoc_list . COMMA expr

    COMMA  shift, and go to state 195

    $default  reduce using rule 135 (funct_invoc_list)


state 153

   84 arr_ref_index: L_BRACKET expr . R_BRACKET
   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    R_BRACKET  shift, and go to state 196
    OR         shift, and go to state 100
    AND        shift, and go to state 101
    NOT_EQ     shift, and go to state 102
    GREAT      shift, and go to state 103
    GREAT_EQ   shift, and go to state 104
    EQUAL      shift, and go to state 105
    LESS_EQ    shift, and go to state 106
    LESS       shift, and go to state 107
    MINUS      shift, and go to state 108
    PLUS       shift, and go to state 109
    MOD        shift, and go to state 110
    DIVIDE     shift, and go to state 111
    MULTIPLY   shift, and go to state 112


state 154

   82 arr_ref_indice: arr_ref_index arr_ref_indice .

    $default  reduce using rule 82 (arr_ref_indice)


state 155

  132 funct_invoc_ref: symbol_id funct_invoc_list R_PAREN .

    $default  reduce using rule 132 (funct_invoc_ref)


state 156

   94 expr: expr . OR expr
   94     | expr OR expr .
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    AND       shift, and go to state 101
    NOT_EQ    shift, and go to state 102
    GREAT     shift, and go to state 103
    GREAT_EQ  shift, and go to state 104
    EQUAL     shift, and go to state 105
    LESS_EQ   shift, and go to state 106
    LESS      shift, and go to state 107
    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 94 (expr)


state 157

   94 expr: expr . OR expr
   95     | expr . AND expr
   95     | expr AND expr .
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    NOT_EQ    shift, and go to state 102
    GREAT     shift, and go to state 103
    GREAT_EQ  shift, and go to state 104
    EQUAL     shift, and go to state 105
    LESS_EQ   shift, and go to state 106
    LESS      shift, and go to state 107
    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 95 (expr)


state 158

   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  102     | expr NOT_EQ expr .
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 102 (expr)


state 159

   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  101     | expr GREAT expr .
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 101 (expr)


state 160

   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  100     | expr GREAT_EQ expr .
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 100 (expr)


state 161

   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
   99     | expr EQUAL expr .
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 99 (expr)


state 162

   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   98     | expr LESS_EQ expr .
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 98 (expr)


state 163

   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   97     | expr LESS expr .
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 97 (expr)


state 164

   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  104     | expr MINUS expr .
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 104 (expr)


state 165

   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  103     | expr PLUS expr .
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 103 (expr)


state 166

   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr
  107     | expr MOD expr .

    $default  reduce using rule 107 (expr)


state 167

   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  106     | expr DIVIDE expr .
  107     | expr . MOD expr

    $default  reduce using rule 106 (expr)


state 168

   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  105     | expr MULTIPLY expr .
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    $default  reduce using rule 105 (expr)


state 169

   24 array_indice: array_indice L_BRACKET CONS_INTEGER R_BRACKET .

    $default  reduce using rule 24 (array_indice)


state 170

   32 init_arr_list: L_BRACE nonEmpty_init_arr_list .
   34 nonEmpty_init_arr_list: nonEmpty_init_arr_list . COMMA expr

    COMMA  shift, and go to state 197

    $default  reduce using rule 32 (init_arr_list)


state 171

   35 nonEmpty_init_arr_list: expr .
   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    OR        shift, and go to state 100
    AND       shift, and go to state 101
    NOT_EQ    shift, and go to state 102
    GREAT     shift, and go to state 103
    GREAT_EQ  shift, and go to state 104
    EQUAL     shift, and go to state 105
    LESS_EQ   shift, and go to state 106
    LESS      shift, and go to state 107
    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 35 (nonEmpty_init_arr_list)


state 172

   31 init_array: init_arr_list R_BRACE .

    $default  reduce using rule 31 (init_array)


state 173

   47 definition_list: type symbol_id arg_list R_PAREN compound_st definition_list .

    $default  reduce using rule 47 (definition_list)


state 174

   88 while_st: WHILE L_PAREN . bool_expr R_PAREN compound_st

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    bool_expr         go to state 198
    expr              go to state 199
    funct_invoc_ref   go to state 74


state 175

   89 while_st: DO compound_st . WHILE L_PAREN bool_expr R_PAREN SEMICOLON

    WHILE  shift, and go to state 200


state 176

   85 condition_st: IF L_PAREN . bool_expr R_PAREN compound_st
   86             | IF L_PAREN . bool_expr R_PAREN compound_st ELSE compound_st

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    bool_expr         go to state 201
    expr              go to state 199
    funct_invoc_ref   go to state 74


state 177

  113 for_init: L_PAREN . nonEmpty_for_init
  114         | L_PAREN .

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    $default  reduce using rule 114 (for_init)

    symbol_id          go to state 202
    literal_constant   go to state 71
    var_ref            go to state 72
    expr               go to state 203
    nonEmpty_for_init  go to state 204
    for_single_entry   go to state 205
    funct_invoc_ref    go to state 74


state 178

  112 for_st: FOR for_init . for_control for_incre R_PAREN compound_st

    SEMICOLON  shift, and go to state 206

    for_control  go to state 207


state 179

   77 simple_st: PRINT var_ref . SEMICOLON
  110 expr: var_ref .

    SEMICOLON  shift, and go to state 208

    SEMICOLON  [reduce using rule 110 (expr)]
    $default   reduce using rule 110 (expr)


state 180

   78 simple_st: PRINT expr . SEMICOLON
   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    OR         shift, and go to state 100
    AND        shift, and go to state 101
    NOT_EQ     shift, and go to state 102
    GREAT      shift, and go to state 103
    GREAT_EQ   shift, and go to state 104
    EQUAL      shift, and go to state 105
    LESS_EQ    shift, and go to state 106
    LESS       shift, and go to state 107
    MINUS      shift, and go to state 108
    PLUS       shift, and go to state 109
    MOD        shift, and go to state 110
    DIVIDE     shift, and go to state 111
    MULTIPLY   shift, and go to state 112
    SEMICOLON  shift, and go to state 209


state 181

   80 var_ref: symbol_id .
   81        | symbol_id . arr_ref_indice

    L_BRACKET  shift, and go to state 96

    $default  reduce using rule 80 (var_ref)

    arr_ref_indice  go to state 97
    arr_ref_index   go to state 98


state 182

   79 simple_st: READ var_ref . SEMICOLON

    SEMICOLON  shift, and go to state 210


state 183

   92 jump_st: CONTINUE SEMICOLON .

    $default  reduce using rule 92 (jump_st)


state 184

   91 jump_st: BREAK SEMICOLON .

    $default  reduce using rule 91 (jump_st)


state 185

   90 jump_st: RETURN expr . SEMICOLON
   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    OR         shift, and go to state 100
    AND        shift, and go to state 101
    NOT_EQ     shift, and go to state 102
    GREAT      shift, and go to state 103
    GREAT_EQ   shift, and go to state 104
    EQUAL      shift, and go to state 105
    LESS_EQ    shift, and go to state 106
    LESS       shift, and go to state 107
    MINUS      shift, and go to state 108
    PLUS       shift, and go to state 109
    MOD        shift, and go to state 110
    DIVIDE     shift, and go to state 111
    MULTIPLY   shift, and go to state 112
    SEMICOLON  shift, and go to state 211


state 186

  133 funct_invoc_st: symbol_id funct_invoc_list . R_PAREN SEMICOLON

    R_PAREN  shift, and go to state 212


state 187

   63 var_const_decl_list: var_const_decl_list var_decl .
   65                    | var_decl .

    CONST     reduce using rule 63 (var_const_decl_list)
    CONST     [reduce using rule 65 (var_const_decl_list)]
    STRING    reduce using rule 63 (var_const_decl_list)
    STRING    [reduce using rule 65 (var_const_decl_list)]
    DOUBLE    reduce using rule 63 (var_const_decl_list)
    DOUBLE    [reduce using rule 65 (var_const_decl_list)]
    FLOAT     reduce using rule 63 (var_const_decl_list)
    FLOAT     [reduce using rule 65 (var_const_decl_list)]
    BOOL      reduce using rule 63 (var_const_decl_list)
    BOOL      [reduce using rule 65 (var_const_decl_list)]
    INT       reduce using rule 63 (var_const_decl_list)
    INT       [reduce using rule 65 (var_const_decl_list)]
    BOOLEAN   reduce using rule 63 (var_const_decl_list)
    BOOLEAN   [reduce using rule 65 (var_const_decl_list)]
    L_BRACE   reduce using rule 63 (var_const_decl_list)
    L_BRACE   [reduce using rule 65 (var_const_decl_list)]
    R_BRACE   reduce using rule 63 (var_const_decl_list)
    R_BRACE   [reduce using rule 65 (var_const_decl_list)]
    WHILE     reduce using rule 63 (var_const_decl_list)
    WHILE     [reduce using rule 65 (var_const_decl_list)]
    DO        reduce using rule 63 (var_const_decl_list)
    DO        [reduce using rule 65 (var_const_decl_list)]
    IF        reduce using rule 63 (var_const_decl_list)
    IF        [reduce using rule 65 (var_const_decl_list)]
    FOR       reduce using rule 63 (var_const_decl_list)
    FOR       [reduce using rule 65 (var_const_decl_list)]
    PRINT     reduce using rule 63 (var_const_decl_list)
    PRINT     [reduce using rule 65 (var_const_decl_list)]
    READ      reduce using rule 63 (var_const_decl_list)
    READ      [reduce using rule 65 (var_const_decl_list)]
    CONTINUE  reduce using rule 63 (var_const_decl_list)
    CONTINUE  [reduce using rule 65 (var_const_decl_list)]
    BREAK     reduce using rule 63 (var_const_decl_list)
    BREAK     [reduce using rule 65 (var_const_decl_list)]
    RETURN    reduce using rule 63 (var_const_decl_list)
    RETURN    [reduce using rule 65 (var_const_decl_list)]
    ID        reduce using rule 63 (var_const_decl_list)
    ID        [reduce using rule 65 (var_const_decl_list)]
    $default  reduce using rule 63 (var_const_decl_list)


state 188

   64 var_const_decl_list: var_const_decl_list const_decl .
   66                    | const_decl .

    CONST     reduce using rule 64 (var_const_decl_list)
    CONST     [reduce using rule 66 (var_const_decl_list)]
    STRING    reduce using rule 64 (var_const_decl_list)
    STRING    [reduce using rule 66 (var_const_decl_list)]
    DOUBLE    reduce using rule 64 (var_const_decl_list)
    DOUBLE    [reduce using rule 66 (var_const_decl_list)]
    FLOAT     reduce using rule 64 (var_const_decl_list)
    FLOAT     [reduce using rule 66 (var_const_decl_list)]
    BOOL      reduce using rule 64 (var_const_decl_list)
    BOOL      [reduce using rule 66 (var_const_decl_list)]
    INT       reduce using rule 64 (var_const_decl_list)
    INT       [reduce using rule 66 (var_const_decl_list)]
    BOOLEAN   reduce using rule 64 (var_const_decl_list)
    BOOLEAN   [reduce using rule 66 (var_const_decl_list)]
    L_BRACE   reduce using rule 64 (var_const_decl_list)
    L_BRACE   [reduce using rule 66 (var_const_decl_list)]
    R_BRACE   reduce using rule 64 (var_const_decl_list)
    R_BRACE   [reduce using rule 66 (var_const_decl_list)]
    WHILE     reduce using rule 64 (var_const_decl_list)
    WHILE     [reduce using rule 66 (var_const_decl_list)]
    DO        reduce using rule 64 (var_const_decl_list)
    DO        [reduce using rule 66 (var_const_decl_list)]
    IF        reduce using rule 64 (var_const_decl_list)
    IF        [reduce using rule 66 (var_const_decl_list)]
    FOR       reduce using rule 64 (var_const_decl_list)
    FOR       [reduce using rule 66 (var_const_decl_list)]
    PRINT     reduce using rule 64 (var_const_decl_list)
    PRINT     [reduce using rule 66 (var_const_decl_list)]
    READ      reduce using rule 64 (var_const_decl_list)
    READ      [reduce using rule 66 (var_const_decl_list)]
    CONTINUE  reduce using rule 64 (var_const_decl_list)
    CONTINUE  [reduce using rule 66 (var_const_decl_list)]
    BREAK     reduce using rule 64 (var_const_decl_list)
    BREAK     [reduce using rule 66 (var_const_decl_list)]
    RETURN    reduce using rule 64 (var_const_decl_list)
    RETURN    [reduce using rule 66 (var_const_decl_list)]
    ID        reduce using rule 64 (var_const_decl_list)
    ID        [reduce using rule 66 (var_const_decl_list)]
    $default  reduce using rule 64 (var_const_decl_list)


state 189

   59 nonEmpty_compound_list: var_const_decl_list nonEmpty_compound_list .

    $default  reduce using rule 59 (nonEmpty_compound_list)


state 190

   60 nonEmpty_compound_list: stat_list nonEmpty_compound_list .

    $default  reduce using rule 60 (nonEmpty_compound_list)


state 191

   67 stat_list: stat_list statement .
   68          | statement .

    CONST     reduce using rule 67 (stat_list)
    CONST     [reduce using rule 68 (stat_list)]
    STRING    reduce using rule 67 (stat_list)
    STRING    [reduce using rule 68 (stat_list)]
    DOUBLE    reduce using rule 67 (stat_list)
    DOUBLE    [reduce using rule 68 (stat_list)]
    FLOAT     reduce using rule 67 (stat_list)
    FLOAT     [reduce using rule 68 (stat_list)]
    BOOL      reduce using rule 67 (stat_list)
    BOOL      [reduce using rule 68 (stat_list)]
    INT       reduce using rule 67 (stat_list)
    INT       [reduce using rule 68 (stat_list)]
    BOOLEAN   reduce using rule 67 (stat_list)
    BOOLEAN   [reduce using rule 68 (stat_list)]
    L_BRACE   reduce using rule 67 (stat_list)
    L_BRACE   [reduce using rule 68 (stat_list)]
    R_BRACE   reduce using rule 67 (stat_list)
    R_BRACE   [reduce using rule 68 (stat_list)]
    WHILE     reduce using rule 67 (stat_list)
    WHILE     [reduce using rule 68 (stat_list)]
    DO        reduce using rule 67 (stat_list)
    DO        [reduce using rule 68 (stat_list)]
    IF        reduce using rule 67 (stat_list)
    IF        [reduce using rule 68 (stat_list)]
    FOR       reduce using rule 67 (stat_list)
    FOR       [reduce using rule 68 (stat_list)]
    PRINT     reduce using rule 67 (stat_list)
    PRINT     [reduce using rule 68 (stat_list)]
    READ      reduce using rule 67 (stat_list)
    READ      [reduce using rule 68 (stat_list)]
    CONTINUE  reduce using rule 67 (stat_list)
    CONTINUE  [reduce using rule 68 (stat_list)]
    BREAK     reduce using rule 67 (stat_list)
    BREAK     [reduce using rule 68 (stat_list)]
    RETURN    reduce using rule 67 (stat_list)
    RETURN    [reduce using rule 68 (stat_list)]
    ID        reduce using rule 67 (stat_list)
    ID        [reduce using rule 68 (stat_list)]
    $default  reduce using rule 67 (stat_list)


state 192

   76 simple_st: var_ref ASSIGN . expr SEMICOLON

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 213
    funct_invoc_ref   go to state 74


state 193

   48 definition_list: VOID symbol_id . arg_list R_PAREN compound_st definition_list
   50                | VOID symbol_id . arg_list R_PAREN compound_st

    L_PAREN  shift, and go to state 35

    arg_list  go to state 214


state 194

   47 definition_list: type symbol_id . arg_list R_PAREN compound_st definition_list
   49                | type symbol_id . arg_list R_PAREN compound_st

    L_PAREN  shift, and go to state 35

    arg_list  go to state 215


state 195

  136 nonEmpty_funct_invoc_list: nonEmpty_funct_invoc_list COMMA . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 216
    funct_invoc_ref   go to state 74


state 196

   84 arr_ref_index: L_BRACKET expr R_BRACKET .

    $default  reduce using rule 84 (arr_ref_index)


state 197

   34 nonEmpty_init_arr_list: nonEmpty_init_arr_list COMMA . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 217
    funct_invoc_ref   go to state 74


state 198

   88 while_st: WHILE L_PAREN bool_expr . R_PAREN compound_st

    R_PAREN  shift, and go to state 218


state 199

   87 bool_expr: expr .
   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    OR        shift, and go to state 100
    AND       shift, and go to state 101
    NOT_EQ    shift, and go to state 102
    GREAT     shift, and go to state 103
    GREAT_EQ  shift, and go to state 104
    EQUAL     shift, and go to state 105
    LESS_EQ   shift, and go to state 106
    LESS      shift, and go to state 107
    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 87 (bool_expr)


state 200

   89 while_st: DO compound_st WHILE . L_PAREN bool_expr R_PAREN SEMICOLON

    L_PAREN  shift, and go to state 219


state 201

   85 condition_st: IF L_PAREN bool_expr . R_PAREN compound_st
   86             | IF L_PAREN bool_expr . R_PAREN compound_st ELSE compound_st

    R_PAREN  shift, and go to state 220


state 202

   80 var_ref: symbol_id .
   81        | symbol_id . arr_ref_indice
  128 for_single_entry: symbol_id . ASSIGN expr
  129                 | symbol_id . array_indice ASSIGN init_array
  131                 | symbol_id . funct_invoc_list R_PAREN
  132 funct_invoc_ref: symbol_id . funct_invoc_list R_PAREN

    L_PAREN    shift, and go to state 95
    L_BRACKET  shift, and go to state 221
    ASSIGN     shift, and go to state 222

    $default  reduce using rule 80 (var_ref)

    array_indice      go to state 223
    arr_ref_indice    go to state 97
    arr_ref_index     go to state 98
    funct_invoc_list  go to state 224


state 203

   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr
  130 for_single_entry: expr .

    OR        shift, and go to state 100
    AND       shift, and go to state 101
    NOT_EQ    shift, and go to state 102
    GREAT     shift, and go to state 103
    GREAT_EQ  shift, and go to state 104
    EQUAL     shift, and go to state 105
    LESS_EQ   shift, and go to state 106
    LESS      shift, and go to state 107
    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 130 (for_single_entry)


state 204

  113 for_init: L_PAREN nonEmpty_for_init .
  115 nonEmpty_for_init: nonEmpty_for_init . COMMA for_single_entry

    COMMA  shift, and go to state 225

    $default  reduce using rule 113 (for_init)


state 205

  116 nonEmpty_for_init: for_single_entry .

    $default  reduce using rule 116 (nonEmpty_for_init)


state 206

  121 for_control: SEMICOLON . nonEmpty_for_control
  122            | SEMICOLON .

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    $default  reduce using rule 122 (for_control)

    symbol_id             go to state 226
    literal_constant      go to state 71
    var_ref               go to state 72
    expr                  go to state 227
    nonEmpty_for_control  go to state 228
    for_control_entry     go to state 229
    funct_invoc_ref       go to state 74


state 207

  112 for_st: FOR for_init for_control . for_incre R_PAREN compound_st

    SEMICOLON  shift, and go to state 230

    for_incre  go to state 231


state 208

   77 simple_st: PRINT var_ref SEMICOLON .

    $default  reduce using rule 77 (simple_st)


state 209

   78 simple_st: PRINT expr SEMICOLON .

    $default  reduce using rule 78 (simple_st)


state 210

   79 simple_st: READ var_ref SEMICOLON .

    $default  reduce using rule 79 (simple_st)


state 211

   90 jump_st: RETURN expr SEMICOLON .

    $default  reduce using rule 90 (jump_st)


state 212

  133 funct_invoc_st: symbol_id funct_invoc_list R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 232


state 213

   76 simple_st: var_ref ASSIGN expr . SEMICOLON
   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    OR         shift, and go to state 100
    AND        shift, and go to state 101
    NOT_EQ     shift, and go to state 102
    GREAT      shift, and go to state 103
    GREAT_EQ   shift, and go to state 104
    EQUAL      shift, and go to state 105
    LESS_EQ    shift, and go to state 106
    LESS       shift, and go to state 107
    MINUS      shift, and go to state 108
    PLUS       shift, and go to state 109
    MOD        shift, and go to state 110
    DIVIDE     shift, and go to state 111
    MULTIPLY   shift, and go to state 112
    SEMICOLON  shift, and go to state 233


state 214

   48 definition_list: VOID symbol_id arg_list . R_PAREN compound_st definition_list
   50                | VOID symbol_id arg_list . R_PAREN compound_st

    R_PAREN  shift, and go to state 234


state 215

   47 definition_list: type symbol_id arg_list . R_PAREN compound_st definition_list
   49                | type symbol_id arg_list . R_PAREN compound_st

    R_PAREN  shift, and go to state 235


state 216

   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr
  136 nonEmpty_funct_invoc_list: nonEmpty_funct_invoc_list COMMA expr .

    OR        shift, and go to state 100
    AND       shift, and go to state 101
    NOT_EQ    shift, and go to state 102
    GREAT     shift, and go to state 103
    GREAT_EQ  shift, and go to state 104
    EQUAL     shift, and go to state 105
    LESS_EQ   shift, and go to state 106
    LESS      shift, and go to state 107
    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 136 (nonEmpty_funct_invoc_list)


state 217

   34 nonEmpty_init_arr_list: nonEmpty_init_arr_list COMMA expr .
   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    OR        shift, and go to state 100
    AND       shift, and go to state 101
    NOT_EQ    shift, and go to state 102
    GREAT     shift, and go to state 103
    GREAT_EQ  shift, and go to state 104
    EQUAL     shift, and go to state 105
    LESS_EQ   shift, and go to state 106
    LESS      shift, and go to state 107
    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 34 (nonEmpty_init_arr_list)


state 218

   88 while_st: WHILE L_PAREN bool_expr R_PAREN . compound_st

    L_BRACE  shift, and go to state 83

    compound_st    go to state 236
    compound_list  go to state 86


state 219

   89 while_st: DO compound_st WHILE L_PAREN . bool_expr R_PAREN SEMICOLON

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    bool_expr         go to state 237
    expr              go to state 199
    funct_invoc_ref   go to state 74


state 220

   85 condition_st: IF L_PAREN bool_expr R_PAREN . compound_st
   86             | IF L_PAREN bool_expr R_PAREN . compound_st ELSE compound_st

    L_BRACE  shift, and go to state 83

    compound_st    go to state 238
    compound_list  go to state 86


state 221

   25 array_indice: L_BRACKET . CONS_INTEGER R_BRACKET
   84 arr_ref_index: L_BRACKET . expr R_BRACKET

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 239
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 153
    funct_invoc_ref   go to state 74


state 222

  128 for_single_entry: symbol_id ASSIGN . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 240
    funct_invoc_ref   go to state 74


state 223

   24 array_indice: array_indice . L_BRACKET CONS_INTEGER R_BRACKET
  129 for_single_entry: symbol_id array_indice . ASSIGN init_array

    L_BRACKET  shift, and go to state 75
    ASSIGN     shift, and go to state 241


state 224

  131 for_single_entry: symbol_id funct_invoc_list . R_PAREN
  132 funct_invoc_ref: symbol_id funct_invoc_list . R_PAREN

    R_PAREN  shift, and go to state 242


state 225

  115 nonEmpty_for_init: nonEmpty_for_init COMMA . for_single_entry

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 202
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 203
    for_single_entry  go to state 243
    funct_invoc_ref   go to state 74


state 226

   80 var_ref: symbol_id .
   81        | symbol_id . arr_ref_indice
  126 for_control_entry: symbol_id . ASSIGN expr
  127                  | symbol_id . array_indice ASSIGN init_array
  132 funct_invoc_ref: symbol_id . funct_invoc_list R_PAREN

    L_PAREN    shift, and go to state 95
    L_BRACKET  shift, and go to state 221
    ASSIGN     shift, and go to state 244

    $default  reduce using rule 80 (var_ref)

    array_indice      go to state 245
    arr_ref_indice    go to state 97
    arr_ref_index     go to state 98
    funct_invoc_list  go to state 99


state 227

   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr
  125 for_control_entry: expr .

    OR        shift, and go to state 100
    AND       shift, and go to state 101
    NOT_EQ    shift, and go to state 102
    GREAT     shift, and go to state 103
    GREAT_EQ  shift, and go to state 104
    EQUAL     shift, and go to state 105
    LESS_EQ   shift, and go to state 106
    LESS      shift, and go to state 107
    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 125 (for_control_entry)


state 228

  121 for_control: SEMICOLON nonEmpty_for_control .
  123 nonEmpty_for_control: nonEmpty_for_control . COMMA for_control_entry

    COMMA  shift, and go to state 246

    $default  reduce using rule 121 (for_control)


state 229

  124 nonEmpty_for_control: for_control_entry .

    $default  reduce using rule 124 (nonEmpty_for_control)


state 230

  117 for_incre: SEMICOLON . nonEmpty_for_incre
  118          | SEMICOLON .

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    $default  reduce using rule 118 (for_incre)

    symbol_id           go to state 202
    literal_constant    go to state 71
    var_ref             go to state 72
    expr                go to state 203
    nonEmpty_for_incre  go to state 247
    for_single_entry    go to state 248
    funct_invoc_ref     go to state 74


state 231

  112 for_st: FOR for_init for_control for_incre . R_PAREN compound_st

    R_PAREN  shift, and go to state 249


state 232

  133 funct_invoc_st: symbol_id funct_invoc_list R_PAREN SEMICOLON .

    $default  reduce using rule 133 (funct_invoc_st)


state 233

   76 simple_st: var_ref ASSIGN expr SEMICOLON .

    $default  reduce using rule 76 (simple_st)


state 234

   48 definition_list: VOID symbol_id arg_list R_PAREN . compound_st definition_list
   50                | VOID symbol_id arg_list R_PAREN . compound_st

    L_BRACE  shift, and go to state 83

    compound_st    go to state 85
    compound_list  go to state 86


state 235

   47 definition_list: type symbol_id arg_list R_PAREN . compound_st definition_list
   49                | type symbol_id arg_list R_PAREN . compound_st

    L_BRACE  shift, and go to state 83

    compound_st    go to state 118
    compound_list  go to state 86


state 236

   88 while_st: WHILE L_PAREN bool_expr R_PAREN compound_st .

    $default  reduce using rule 88 (while_st)


state 237

   89 while_st: DO compound_st WHILE L_PAREN bool_expr . R_PAREN SEMICOLON

    R_PAREN  shift, and go to state 250


state 238

   85 condition_st: IF L_PAREN bool_expr R_PAREN compound_st .
   86             | IF L_PAREN bool_expr R_PAREN compound_st . ELSE compound_st

    ELSE  shift, and go to state 251

    $default  reduce using rule 85 (condition_st)


state 239

   25 array_indice: L_BRACKET CONS_INTEGER . R_BRACKET
   40 literal_constant: CONS_INTEGER .

    R_BRACKET  shift, and go to state 91

    R_BRACKET  [reduce using rule 40 (literal_constant)]
    $default   reduce using rule 40 (literal_constant)


state 240

   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr
  128 for_single_entry: symbol_id ASSIGN expr .

    OR        shift, and go to state 100
    AND       shift, and go to state 101
    NOT_EQ    shift, and go to state 102
    GREAT     shift, and go to state 103
    GREAT_EQ  shift, and go to state 104
    EQUAL     shift, and go to state 105
    LESS_EQ   shift, and go to state 106
    LESS      shift, and go to state 107
    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 128 (for_single_entry)


state 241

  129 for_single_entry: symbol_id array_indice ASSIGN . init_array

    L_BRACE  shift, and go to state 114

    init_array     go to state 252
    init_arr_list  go to state 116


state 242

  131 for_single_entry: symbol_id funct_invoc_list R_PAREN .
  132 funct_invoc_ref: symbol_id funct_invoc_list R_PAREN .

    R_PAREN    reduce using rule 131 (for_single_entry)
    R_PAREN    [reduce using rule 132 (funct_invoc_ref)]
    SEMICOLON  reduce using rule 131 (for_single_entry)
    SEMICOLON  [reduce using rule 132 (funct_invoc_ref)]
    COMMA      reduce using rule 131 (for_single_entry)
    COMMA      [reduce using rule 132 (funct_invoc_ref)]
    $default   reduce using rule 132 (funct_invoc_ref)


state 243

  115 nonEmpty_for_init: nonEmpty_for_init COMMA for_single_entry .

    $default  reduce using rule 115 (nonEmpty_for_init)


state 244

  126 for_control_entry: symbol_id ASSIGN . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 253
    funct_invoc_ref   go to state 74


state 245

   24 array_indice: array_indice . L_BRACKET CONS_INTEGER R_BRACKET
  127 for_control_entry: symbol_id array_indice . ASSIGN init_array

    L_BRACKET  shift, and go to state 75
    ASSIGN     shift, and go to state 254


state 246

  123 nonEmpty_for_control: nonEmpty_for_control COMMA . for_control_entry

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id          go to state 226
    literal_constant   go to state 71
    var_ref            go to state 72
    expr               go to state 227
    for_control_entry  go to state 255
    funct_invoc_ref    go to state 74


state 247

  117 for_incre: SEMICOLON nonEmpty_for_incre .
  119 nonEmpty_for_incre: nonEmpty_for_incre . COMMA for_single_entry

    COMMA  shift, and go to state 256

    $default  reduce using rule 117 (for_incre)


state 248

  120 nonEmpty_for_incre: for_single_entry .

    $default  reduce using rule 120 (nonEmpty_for_incre)


state 249

  112 for_st: FOR for_init for_control for_incre R_PAREN . compound_st

    L_BRACE  shift, and go to state 83

    compound_st    go to state 257
    compound_list  go to state 86


state 250

   89 while_st: DO compound_st WHILE L_PAREN bool_expr R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 258


state 251

   86 condition_st: IF L_PAREN bool_expr R_PAREN compound_st ELSE . compound_st

    L_BRACE  shift, and go to state 83

    compound_st    go to state 259
    compound_list  go to state 86


state 252

  129 for_single_entry: symbol_id array_indice ASSIGN init_array .

    $default  reduce using rule 129 (for_single_entry)


state 253

   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr
  126 for_control_entry: symbol_id ASSIGN expr .

    OR        shift, and go to state 100
    AND       shift, and go to state 101
    NOT_EQ    shift, and go to state 102
    GREAT     shift, and go to state 103
    GREAT_EQ  shift, and go to state 104
    EQUAL     shift, and go to state 105
    LESS_EQ   shift, and go to state 106
    LESS      shift, and go to state 107
    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 126 (for_control_entry)


state 254

  127 for_control_entry: symbol_id array_indice ASSIGN . init_array

    L_BRACE  shift, and go to state 114

    init_array     go to state 260
    init_arr_list  go to state 116


state 255

  123 nonEmpty_for_control: nonEmpty_for_control COMMA for_control_entry .

    $default  reduce using rule 123 (nonEmpty_for_control)


state 256

  119 nonEmpty_for_incre: nonEmpty_for_incre COMMA . for_single_entry

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 202
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 203
    for_single_entry  go to state 261
    funct_invoc_ref   go to state 74


state 257

  112 for_st: FOR for_init for_control for_incre R_PAREN compound_st .

    $default  reduce using rule 112 (for_st)


state 258

   89 while_st: DO compound_st WHILE L_PAREN bool_expr R_PAREN SEMICOLON .

    $default  reduce using rule 89 (while_st)


state 259

   86 condition_st: IF L_PAREN bool_expr R_PAREN compound_st ELSE compound_st .

    $default  reduce using rule 86 (condition_st)


state 260

  127 for_control_entry: symbol_id array_indice ASSIGN init_array .

    $default  reduce using rule 127 (for_control_entry)


state 261

  119 nonEmpty_for_incre: nonEmpty_for_incre COMMA for_single_entry .

    $default  reduce using rule 119 (nonEmpty_for_incre)
