State 17 conflicts: 8 shift/reduce
State 23 conflicts: 8 shift/reduce
State 25 conflicts: 8 shift/reduce
State 26 conflicts: 8 reduce/reduce
State 27 conflicts: 8 reduce/reduce
State 28 conflicts: 8 reduce/reduce
State 29 conflicts: 8 reduce/reduce
State 34 conflicts: 8 shift/reduce
State 93 conflicts: 13 shift/reduce
State 177 conflicts: 1 shift/reduce
State 235 conflicts: 1 shift/reduce
State 238 conflicts: 3 reduce/reduce


Grammar

    0 $accept: program $end

    1 program: decl_and_def_list

    2 decl_and_def_list: decl_and_def_list declaration_list
    3                  | declaration_list decl_and_def_list
    4                  | definition_list
    5                  | definition_list decl_and_def_list

    6 declaration_list: declaration_list const_decl
    7                 | declaration_list var_decl
    8                 | declaration_list funct_decl
    9                 | declaration_list proc_decl
   10                 | const_decl
   11                 | var_decl
   12                 | funct_decl
   13                 | proc_decl

   14 var_decl: type var_list SEMICOLON

   15 type: INT
   16     | DOUBLE
   17     | FLOAT
   18     | STRING
   19     | BOOL
   20     | BOOLEAN

   21 identifier: symbol_id
   22           | symbol_id array_indice

   23 symbol_id: ID

   24 array_indice: array_indice L_BRACKET CONS_INTEGER R_BRACKET
   25             | L_BRACKET CONS_INTEGER R_BRACKET

   26 var_list: var_list COMMA var_single
   27         | var_single

   28 var_single: identifier
   29           | symbol_id ASSIGN expr
   30           | symbol_id array_indice ASSIGN init_array

   31 init_array: init_arr_list R_BRACE

   32 init_arr_list: L_BRACE nonEmpty_init_arr_list
   33              | L_BRACE

   34 nonEmpty_init_arr_list: nonEmpty_init_arr_list COMMA expr
   35                       | expr

   36 const_decl: CONST type const_list SEMICOLON

   37 const_list: const_init COMMA const_list
   38           | const_init

   39 const_init: symbol_id ASSIGN literal_constant

   40 literal_constant: CONS_INTEGER
   41                 | CONS_FLOAT
   42                 | CONS_SCIENTIFIC
   43                 | CONS_STRING
   44                 | CONS_BOOL

   45 funct_decl: type symbol_id arg_list R_PAREN SEMICOLON

   46 proc_decl: VOID symbol_id arg_list R_PAREN SEMICOLON

   47 definition_list: type symbol_id arg_list R_PAREN compound_st definition_list
   48                | VOID symbol_id arg_list R_PAREN compound_st definition_list
   49                | type symbol_id arg_list R_PAREN compound_st
   50                | VOID symbol_id arg_list R_PAREN compound_st

   51 arg_list: L_PAREN nonEmpty_arg_list
   52         | L_PAREN

   53 nonEmpty_arg_list: arg COMMA nonEmpty_arg_list
   54                  | arg

   55 arg: type identifier

   56 compound_st: compound_list R_BRACE

   57 compound_list: L_BRACE nonEmpty_compound_list
   58              | L_BRACE

   59 nonEmpty_compound_list: var_decl nonEmpty_compound_list
   60                       | const_decl nonEmpty_compound_list
   61                       | statement nonEmpty_compound_list
   62                       | var_decl
   63                       | const_decl
   64                       | statement

   65 statement: compound_st
   66          | simple_st
   67          | condition_st
   68          | while_st
   69          | for_st
   70          | jump_st
   71          | funct_invoc_st

   72 simple_st: var_ref ASSIGN expr SEMICOLON
   73          | PRINT var_ref SEMICOLON
   74          | PRINT expr SEMICOLON
   75          | READ var_ref SEMICOLON

   76 var_ref: symbol_id
   77        | symbol_id arr_ref_indice

   78 arr_ref_indice: arr_ref_index arr_ref_indice
   79               | arr_ref_index

   80 arr_ref_index: L_BRACKET expr R_BRACKET

   81 condition_st: IF L_PAREN bool_expr R_PAREN compound_st
   82             | IF L_PAREN bool_expr R_PAREN compound_st ELSE compound_st

   83 bool_expr: expr

   84 while_st: WHILE L_PAREN bool_expr R_PAREN compound_st
   85         | DO compound_st WHILE L_PAREN bool_expr R_PAREN SEMICOLON

   86 jump_st: RETURN expr SEMICOLON
   87        | BREAK SEMICOLON
   88        | CONTINUE SEMICOLON

   89 expr: L_PAREN expr R_PAREN
   90     | expr OR expr
   91     | expr AND expr
   92     | NOT expr
   93     | expr LESS expr
   94     | expr LESS_EQ expr
   95     | expr EQUAL expr
   96     | expr GREAT_EQ expr
   97     | expr GREAT expr
   98     | expr NOT_EQ expr
   99     | expr PLUS expr
  100     | expr MINUS expr
  101     | expr MULTIPLY expr
  102     | expr DIVIDE expr
  103     | expr MOD expr
  104     | MINUS expr
  105     | literal_constant
  106     | var_ref
  107     | funct_invoc_ref

  108 for_st: FOR for_init for_control for_incre R_PAREN compound_st

  109 for_init: L_PAREN nonEmpty_for_init
  110         | L_PAREN

  111 nonEmpty_for_init: nonEmpty_for_init COMMA for_single_entry
  112                  | for_single_entry

  113 for_incre: SEMICOLON nonEmpty_for_incre
  114          | SEMICOLON

  115 nonEmpty_for_incre: nonEmpty_for_incre COMMA for_single_entry
  116                   | for_single_entry

  117 for_control: SEMICOLON nonEmpty_for_control
  118            | SEMICOLON

  119 nonEmpty_for_control: nonEmpty_for_control COMMA for_control_entry
  120                     | for_control_entry

  121 for_control_entry: expr
  122                  | symbol_id ASSIGN expr
  123                  | symbol_id array_indice ASSIGN init_array

  124 for_single_entry: symbol_id ASSIGN expr
  125                 | symbol_id array_indice ASSIGN init_array
  126                 | expr
  127                 | symbol_id funct_invoc_list R_PAREN

  128 funct_invoc_ref: symbol_id funct_invoc_list R_PAREN

  129 funct_invoc_st: symbol_id funct_invoc_list R_PAREN SEMICOLON

  130 funct_invoc_list: L_PAREN
  131                 | L_PAREN nonEmpty_funct_invoc_list

  132 nonEmpty_funct_invoc_list: nonEmpty_funct_invoc_list COMMA expr
  133                          | expr


Terminals, with rules where they appear

$end (0) 0
error (256)
VOID (258) 46 48 50
CONST (259) 36
STRING (260) 18
DOUBLE (261) 16
FLOAT (262) 17
BOOL (263) 19
INT (264) 15
BOOLEAN (265) 20
L_PAREN (266) 51 52 81 82 84 85 89 109 110 130 131
R_PAREN (267) 45 46 47 48 49 50 81 82 84 85 89 108 127 128 129
L_BRACKET (268) 24 25 80
R_BRACKET (269) 24 25 80
L_BRACE (270) 32 33 57 58
R_BRACE (271) 31 56
OR (272) 90
AND (273) 91
NOT (274) 92
NOT_EQ (275) 98
GREAT (276) 97
GREAT_EQ (277) 96
EQUAL (278) 95
LESS_EQ (279) 94
LESS (280) 93
MINUS (281) 100 104
PLUS (282) 99
MOD (283) 103
DIVIDE (284) 102
MULTIPLY (285) 101
ASSIGN (286) 29 30 39 72 122 123 124 125
WHILE (287) 84 85
DO (288) 85
IF (289) 81 82
ELSE (290) 82
FOR (291) 108
PRINT (292) 73 74
READ (293) 75
CONTINUE (294) 88
BREAK (295) 87
RETURN (296) 86
ID (297) 23
SEMICOLON (298) 14 36 45 46 72 73 74 75 85 86 87 88 113 114 117 118
    129
COMMA (299) 26 34 37 53 111 115 119 132
CONS_INTEGER (300) 24 25 40
CONS_FLOAT (301) 41
CONS_SCIENTIFIC (302) 42
CONS_STRING (303) 43
CONS_BOOL (304) 44


Nonterminals, with rules where they appear

$accept (50)
    on left: 0
program (51)
    on left: 1, on right: 0
decl_and_def_list (52)
    on left: 2 3 4 5, on right: 1 2 3 5
declaration_list (53)
    on left: 6 7 8 9 10 11 12 13, on right: 2 3 6 7 8 9
var_decl (54)
    on left: 14, on right: 7 11 59 62
type (55)
    on left: 15 16 17 18 19 20, on right: 14 36 45 47 49 55
identifier (56)
    on left: 21 22, on right: 28 55
symbol_id (57)
    on left: 23, on right: 21 22 29 30 39 45 46 47 48 49 50 76 77 122
    123 124 125 127 128 129
array_indice (58)
    on left: 24 25, on right: 22 24 30 123 125
var_list (59)
    on left: 26 27, on right: 14 26
var_single (60)
    on left: 28 29 30, on right: 26 27
init_array (61)
    on left: 31, on right: 30 123 125
init_arr_list (62)
    on left: 32 33, on right: 31
nonEmpty_init_arr_list (63)
    on left: 34 35, on right: 32 34
const_decl (64)
    on left: 36, on right: 6 10 60 63
const_list (65)
    on left: 37 38, on right: 36 37
const_init (66)
    on left: 39, on right: 37 38
literal_constant (67)
    on left: 40 41 42 43 44, on right: 39 105
funct_decl (68)
    on left: 45, on right: 8 12
proc_decl (69)
    on left: 46, on right: 9 13
definition_list (70)
    on left: 47 48 49 50, on right: 4 5 47 48
arg_list (71)
    on left: 51 52, on right: 45 46 47 48 49 50
nonEmpty_arg_list (72)
    on left: 53 54, on right: 51 53
arg (73)
    on left: 55, on right: 53 54
compound_st (74)
    on left: 56, on right: 47 48 49 50 65 81 82 84 85 108
compound_list (75)
    on left: 57 58, on right: 56
nonEmpty_compound_list (76)
    on left: 59 60 61 62 63 64, on right: 57 59 60 61
statement (77)
    on left: 65 66 67 68 69 70 71, on right: 61 64
simple_st (78)
    on left: 72 73 74 75, on right: 66
var_ref (79)
    on left: 76 77, on right: 72 73 75 106
arr_ref_indice (80)
    on left: 78 79, on right: 77 78
arr_ref_index (81)
    on left: 80, on right: 78 79
condition_st (82)
    on left: 81 82, on right: 67
bool_expr (83)
    on left: 83, on right: 81 82 84 85
while_st (84)
    on left: 84 85, on right: 68
jump_st (85)
    on left: 86 87 88, on right: 70
expr (86)
    on left: 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105
    106 107, on right: 29 34 35 72 74 80 83 86 89 90 91 92 93 94 95
    96 97 98 99 100 101 102 103 104 121 122 124 126 132 133
for_st (87)
    on left: 108, on right: 69
for_init (88)
    on left: 109 110, on right: 108
nonEmpty_for_init (89)
    on left: 111 112, on right: 109 111
for_incre (90)
    on left: 113 114, on right: 108
nonEmpty_for_incre (91)
    on left: 115 116, on right: 113 115
for_control (92)
    on left: 117 118, on right: 108
nonEmpty_for_control (93)
    on left: 119 120, on right: 117 119
for_control_entry (94)
    on left: 121 122 123, on right: 119 120
for_single_entry (95)
    on left: 124 125 126 127, on right: 111 112 115 116
funct_invoc_ref (96)
    on left: 128, on right: 107
funct_invoc_st (97)
    on left: 129, on right: 71
funct_invoc_list (98)
    on left: 130 131, on right: 127 128 129
nonEmpty_funct_invoc_list (99)
    on left: 132 133, on right: 131 132


state 0

    0 $accept: . program $end

    VOID     shift, and go to state 1
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    program            go to state 9
    decl_and_def_list  go to state 10
    declaration_list   go to state 11
    var_decl           go to state 12
    type               go to state 13
    const_decl         go to state 14
    funct_decl         go to state 15
    proc_decl          go to state 16
    definition_list    go to state 17


state 1

   46 proc_decl: VOID . symbol_id arg_list R_PAREN SEMICOLON
   48 definition_list: VOID . symbol_id arg_list R_PAREN compound_st definition_list
   50                | VOID . symbol_id arg_list R_PAREN compound_st

    ID  shift, and go to state 18

    symbol_id  go to state 19


state 2

   36 const_decl: CONST . type const_list SEMICOLON

    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    type  go to state 20


state 3

   18 type: STRING .

    $default  reduce using rule 18 (type)


state 4

   16 type: DOUBLE .

    $default  reduce using rule 16 (type)


state 5

   17 type: FLOAT .

    $default  reduce using rule 17 (type)


state 6

   19 type: BOOL .

    $default  reduce using rule 19 (type)


state 7

   15 type: INT .

    $default  reduce using rule 15 (type)


state 8

   20 type: BOOLEAN .

    $default  reduce using rule 20 (type)


state 9

    0 $accept: program . $end

    $end  shift, and go to state 21


state 10

    1 program: decl_and_def_list .
    2 decl_and_def_list: decl_and_def_list . declaration_list

    VOID     shift, and go to state 22
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    $default  reduce using rule 1 (program)

    declaration_list  go to state 23
    var_decl          go to state 12
    type              go to state 24
    const_decl        go to state 14
    funct_decl        go to state 15
    proc_decl         go to state 16


state 11

    3 decl_and_def_list: declaration_list . decl_and_def_list
    6 declaration_list: declaration_list . const_decl
    7                 | declaration_list . var_decl
    8                 | declaration_list . funct_decl
    9                 | declaration_list . proc_decl

    VOID     shift, and go to state 1
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    decl_and_def_list  go to state 25
    declaration_list   go to state 11
    var_decl           go to state 26
    type               go to state 13
    const_decl         go to state 27
    funct_decl         go to state 28
    proc_decl          go to state 29
    definition_list    go to state 17


state 12

   11 declaration_list: var_decl .

    $default  reduce using rule 11 (declaration_list)


state 13

   14 var_decl: type . var_list SEMICOLON
   45 funct_decl: type . symbol_id arg_list R_PAREN SEMICOLON
   47 definition_list: type . symbol_id arg_list R_PAREN compound_st definition_list
   49                | type . symbol_id arg_list R_PAREN compound_st

    ID  shift, and go to state 18

    identifier  go to state 30
    symbol_id   go to state 31
    var_list    go to state 32
    var_single  go to state 33


state 14

   10 declaration_list: const_decl .

    $default  reduce using rule 10 (declaration_list)


state 15

   12 declaration_list: funct_decl .

    $default  reduce using rule 12 (declaration_list)


state 16

   13 declaration_list: proc_decl .

    $default  reduce using rule 13 (declaration_list)


state 17

    4 decl_and_def_list: definition_list .
    5                  | definition_list . decl_and_def_list

    VOID     shift, and go to state 1
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    VOID      [reduce using rule 4 (decl_and_def_list)]
    CONST     [reduce using rule 4 (decl_and_def_list)]
    STRING    [reduce using rule 4 (decl_and_def_list)]
    DOUBLE    [reduce using rule 4 (decl_and_def_list)]
    FLOAT     [reduce using rule 4 (decl_and_def_list)]
    BOOL      [reduce using rule 4 (decl_and_def_list)]
    INT       [reduce using rule 4 (decl_and_def_list)]
    BOOLEAN   [reduce using rule 4 (decl_and_def_list)]
    $default  reduce using rule 4 (decl_and_def_list)

    decl_and_def_list  go to state 34
    declaration_list   go to state 11
    var_decl           go to state 12
    type               go to state 13
    const_decl         go to state 14
    funct_decl         go to state 15
    proc_decl          go to state 16
    definition_list    go to state 17


state 18

   23 symbol_id: ID .

    $default  reduce using rule 23 (symbol_id)


state 19

   46 proc_decl: VOID symbol_id . arg_list R_PAREN SEMICOLON
   48 definition_list: VOID symbol_id . arg_list R_PAREN compound_st definition_list
   50                | VOID symbol_id . arg_list R_PAREN compound_st

    L_PAREN  shift, and go to state 35

    arg_list  go to state 36


state 20

   36 const_decl: CONST type . const_list SEMICOLON

    ID  shift, and go to state 18

    symbol_id   go to state 37
    const_list  go to state 38
    const_init  go to state 39


state 21

    0 $accept: program $end .

    $default  accept


state 22

   46 proc_decl: VOID . symbol_id arg_list R_PAREN SEMICOLON

    ID  shift, and go to state 18

    symbol_id  go to state 40


state 23

    2 decl_and_def_list: decl_and_def_list declaration_list .
    6 declaration_list: declaration_list . const_decl
    7                 | declaration_list . var_decl
    8                 | declaration_list . funct_decl
    9                 | declaration_list . proc_decl

    VOID     shift, and go to state 22
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    VOID      [reduce using rule 2 (decl_and_def_list)]
    CONST     [reduce using rule 2 (decl_and_def_list)]
    STRING    [reduce using rule 2 (decl_and_def_list)]
    DOUBLE    [reduce using rule 2 (decl_and_def_list)]
    FLOAT     [reduce using rule 2 (decl_and_def_list)]
    BOOL      [reduce using rule 2 (decl_and_def_list)]
    INT       [reduce using rule 2 (decl_and_def_list)]
    BOOLEAN   [reduce using rule 2 (decl_and_def_list)]
    $default  reduce using rule 2 (decl_and_def_list)

    var_decl    go to state 41
    type        go to state 24
    const_decl  go to state 42
    funct_decl  go to state 43
    proc_decl   go to state 44


state 24

   14 var_decl: type . var_list SEMICOLON
   45 funct_decl: type . symbol_id arg_list R_PAREN SEMICOLON

    ID  shift, and go to state 18

    identifier  go to state 30
    symbol_id   go to state 45
    var_list    go to state 32
    var_single  go to state 33


state 25

    2 decl_and_def_list: decl_and_def_list . declaration_list
    3                  | declaration_list decl_and_def_list .

    VOID     shift, and go to state 22
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    VOID      [reduce using rule 3 (decl_and_def_list)]
    CONST     [reduce using rule 3 (decl_and_def_list)]
    STRING    [reduce using rule 3 (decl_and_def_list)]
    DOUBLE    [reduce using rule 3 (decl_and_def_list)]
    FLOAT     [reduce using rule 3 (decl_and_def_list)]
    BOOL      [reduce using rule 3 (decl_and_def_list)]
    INT       [reduce using rule 3 (decl_and_def_list)]
    BOOLEAN   [reduce using rule 3 (decl_and_def_list)]
    $default  reduce using rule 3 (decl_and_def_list)

    declaration_list  go to state 23
    var_decl          go to state 12
    type              go to state 24
    const_decl        go to state 14
    funct_decl        go to state 15
    proc_decl         go to state 16


state 26

    7 declaration_list: declaration_list var_decl .
   11                 | var_decl .

    VOID      reduce using rule 7 (declaration_list)
    VOID      [reduce using rule 11 (declaration_list)]
    CONST     reduce using rule 7 (declaration_list)
    CONST     [reduce using rule 11 (declaration_list)]
    STRING    reduce using rule 7 (declaration_list)
    STRING    [reduce using rule 11 (declaration_list)]
    DOUBLE    reduce using rule 7 (declaration_list)
    DOUBLE    [reduce using rule 11 (declaration_list)]
    FLOAT     reduce using rule 7 (declaration_list)
    FLOAT     [reduce using rule 11 (declaration_list)]
    BOOL      reduce using rule 7 (declaration_list)
    BOOL      [reduce using rule 11 (declaration_list)]
    INT       reduce using rule 7 (declaration_list)
    INT       [reduce using rule 11 (declaration_list)]
    BOOLEAN   reduce using rule 7 (declaration_list)
    BOOLEAN   [reduce using rule 11 (declaration_list)]
    $default  reduce using rule 7 (declaration_list)


state 27

    6 declaration_list: declaration_list const_decl .
   10                 | const_decl .

    VOID      reduce using rule 6 (declaration_list)
    VOID      [reduce using rule 10 (declaration_list)]
    CONST     reduce using rule 6 (declaration_list)
    CONST     [reduce using rule 10 (declaration_list)]
    STRING    reduce using rule 6 (declaration_list)
    STRING    [reduce using rule 10 (declaration_list)]
    DOUBLE    reduce using rule 6 (declaration_list)
    DOUBLE    [reduce using rule 10 (declaration_list)]
    FLOAT     reduce using rule 6 (declaration_list)
    FLOAT     [reduce using rule 10 (declaration_list)]
    BOOL      reduce using rule 6 (declaration_list)
    BOOL      [reduce using rule 10 (declaration_list)]
    INT       reduce using rule 6 (declaration_list)
    INT       [reduce using rule 10 (declaration_list)]
    BOOLEAN   reduce using rule 6 (declaration_list)
    BOOLEAN   [reduce using rule 10 (declaration_list)]
    $default  reduce using rule 6 (declaration_list)


state 28

    8 declaration_list: declaration_list funct_decl .
   12                 | funct_decl .

    VOID      reduce using rule 8 (declaration_list)
    VOID      [reduce using rule 12 (declaration_list)]
    CONST     reduce using rule 8 (declaration_list)
    CONST     [reduce using rule 12 (declaration_list)]
    STRING    reduce using rule 8 (declaration_list)
    STRING    [reduce using rule 12 (declaration_list)]
    DOUBLE    reduce using rule 8 (declaration_list)
    DOUBLE    [reduce using rule 12 (declaration_list)]
    FLOAT     reduce using rule 8 (declaration_list)
    FLOAT     [reduce using rule 12 (declaration_list)]
    BOOL      reduce using rule 8 (declaration_list)
    BOOL      [reduce using rule 12 (declaration_list)]
    INT       reduce using rule 8 (declaration_list)
    INT       [reduce using rule 12 (declaration_list)]
    BOOLEAN   reduce using rule 8 (declaration_list)
    BOOLEAN   [reduce using rule 12 (declaration_list)]
    $default  reduce using rule 8 (declaration_list)


state 29

    9 declaration_list: declaration_list proc_decl .
   13                 | proc_decl .

    VOID      reduce using rule 9 (declaration_list)
    VOID      [reduce using rule 13 (declaration_list)]
    CONST     reduce using rule 9 (declaration_list)
    CONST     [reduce using rule 13 (declaration_list)]
    STRING    reduce using rule 9 (declaration_list)
    STRING    [reduce using rule 13 (declaration_list)]
    DOUBLE    reduce using rule 9 (declaration_list)
    DOUBLE    [reduce using rule 13 (declaration_list)]
    FLOAT     reduce using rule 9 (declaration_list)
    FLOAT     [reduce using rule 13 (declaration_list)]
    BOOL      reduce using rule 9 (declaration_list)
    BOOL      [reduce using rule 13 (declaration_list)]
    INT       reduce using rule 9 (declaration_list)
    INT       [reduce using rule 13 (declaration_list)]
    BOOLEAN   reduce using rule 9 (declaration_list)
    BOOLEAN   [reduce using rule 13 (declaration_list)]
    $default  reduce using rule 9 (declaration_list)


state 30

   28 var_single: identifier .

    $default  reduce using rule 28 (var_single)


state 31

   21 identifier: symbol_id .
   22           | symbol_id . array_indice
   29 var_single: symbol_id . ASSIGN expr
   30           | symbol_id . array_indice ASSIGN init_array
   45 funct_decl: type symbol_id . arg_list R_PAREN SEMICOLON
   47 definition_list: type symbol_id . arg_list R_PAREN compound_st definition_list
   49                | type symbol_id . arg_list R_PAREN compound_st

    L_PAREN    shift, and go to state 35
    L_BRACKET  shift, and go to state 46
    ASSIGN     shift, and go to state 47

    $default  reduce using rule 21 (identifier)

    array_indice  go to state 48
    arg_list      go to state 49


state 32

   14 var_decl: type var_list . SEMICOLON
   26 var_list: var_list . COMMA var_single

    SEMICOLON  shift, and go to state 50
    COMMA      shift, and go to state 51


state 33

   27 var_list: var_single .

    $default  reduce using rule 27 (var_list)


state 34

    2 decl_and_def_list: decl_and_def_list . declaration_list
    5                  | definition_list decl_and_def_list .

    VOID     shift, and go to state 22
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    VOID      [reduce using rule 5 (decl_and_def_list)]
    CONST     [reduce using rule 5 (decl_and_def_list)]
    STRING    [reduce using rule 5 (decl_and_def_list)]
    DOUBLE    [reduce using rule 5 (decl_and_def_list)]
    FLOAT     [reduce using rule 5 (decl_and_def_list)]
    BOOL      [reduce using rule 5 (decl_and_def_list)]
    INT       [reduce using rule 5 (decl_and_def_list)]
    BOOLEAN   [reduce using rule 5 (decl_and_def_list)]
    $default  reduce using rule 5 (decl_and_def_list)

    declaration_list  go to state 23
    var_decl          go to state 12
    type              go to state 24
    const_decl        go to state 14
    funct_decl        go to state 15
    proc_decl         go to state 16


state 35

   51 arg_list: L_PAREN . nonEmpty_arg_list
   52         | L_PAREN .

    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    $default  reduce using rule 52 (arg_list)

    type               go to state 52
    nonEmpty_arg_list  go to state 53
    arg                go to state 54


state 36

   46 proc_decl: VOID symbol_id arg_list . R_PAREN SEMICOLON
   48 definition_list: VOID symbol_id arg_list . R_PAREN compound_st definition_list
   50                | VOID symbol_id arg_list . R_PAREN compound_st

    R_PAREN  shift, and go to state 55


state 37

   39 const_init: symbol_id . ASSIGN literal_constant

    ASSIGN  shift, and go to state 56


state 38

   36 const_decl: CONST type const_list . SEMICOLON

    SEMICOLON  shift, and go to state 57


state 39

   37 const_list: const_init . COMMA const_list
   38           | const_init .

    COMMA  shift, and go to state 58

    $default  reduce using rule 38 (const_list)


state 40

   46 proc_decl: VOID symbol_id . arg_list R_PAREN SEMICOLON

    L_PAREN  shift, and go to state 35

    arg_list  go to state 59


state 41

    7 declaration_list: declaration_list var_decl .

    $default  reduce using rule 7 (declaration_list)


state 42

    6 declaration_list: declaration_list const_decl .

    $default  reduce using rule 6 (declaration_list)


state 43

    8 declaration_list: declaration_list funct_decl .

    $default  reduce using rule 8 (declaration_list)


state 44

    9 declaration_list: declaration_list proc_decl .

    $default  reduce using rule 9 (declaration_list)


state 45

   21 identifier: symbol_id .
   22           | symbol_id . array_indice
   29 var_single: symbol_id . ASSIGN expr
   30           | symbol_id . array_indice ASSIGN init_array
   45 funct_decl: type symbol_id . arg_list R_PAREN SEMICOLON

    L_PAREN    shift, and go to state 35
    L_BRACKET  shift, and go to state 46
    ASSIGN     shift, and go to state 47

    $default  reduce using rule 21 (identifier)

    array_indice  go to state 48
    arg_list      go to state 60


state 46

   25 array_indice: L_BRACKET . CONS_INTEGER R_BRACKET

    CONS_INTEGER  shift, and go to state 61


state 47

   29 var_single: symbol_id ASSIGN . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 73
    funct_invoc_ref   go to state 74


state 48

   22 identifier: symbol_id array_indice .
   24 array_indice: array_indice . L_BRACKET CONS_INTEGER R_BRACKET
   30 var_single: symbol_id array_indice . ASSIGN init_array

    L_BRACKET  shift, and go to state 75
    ASSIGN     shift, and go to state 76

    $default  reduce using rule 22 (identifier)


state 49

   45 funct_decl: type symbol_id arg_list . R_PAREN SEMICOLON
   47 definition_list: type symbol_id arg_list . R_PAREN compound_st definition_list
   49                | type symbol_id arg_list . R_PAREN compound_st

    R_PAREN  shift, and go to state 77


state 50

   14 var_decl: type var_list SEMICOLON .

    $default  reduce using rule 14 (var_decl)


state 51

   26 var_list: var_list COMMA . var_single

    ID  shift, and go to state 18

    identifier  go to state 30
    symbol_id   go to state 78
    var_single  go to state 79


state 52

   55 arg: type . identifier

    ID  shift, and go to state 18

    identifier  go to state 80
    symbol_id   go to state 81


state 53

   51 arg_list: L_PAREN nonEmpty_arg_list .

    $default  reduce using rule 51 (arg_list)


state 54

   53 nonEmpty_arg_list: arg . COMMA nonEmpty_arg_list
   54                  | arg .

    COMMA  shift, and go to state 82

    $default  reduce using rule 54 (nonEmpty_arg_list)


state 55

   46 proc_decl: VOID symbol_id arg_list R_PAREN . SEMICOLON
   48 definition_list: VOID symbol_id arg_list R_PAREN . compound_st definition_list
   50                | VOID symbol_id arg_list R_PAREN . compound_st

    L_BRACE    shift, and go to state 83
    SEMICOLON  shift, and go to state 84

    compound_st    go to state 85
    compound_list  go to state 86


state 56

   39 const_init: symbol_id ASSIGN . literal_constant

    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    literal_constant  go to state 87


state 57

   36 const_decl: CONST type const_list SEMICOLON .

    $default  reduce using rule 36 (const_decl)


state 58

   37 const_list: const_init COMMA . const_list

    ID  shift, and go to state 18

    symbol_id   go to state 37
    const_list  go to state 88
    const_init  go to state 39


state 59

   46 proc_decl: VOID symbol_id arg_list . R_PAREN SEMICOLON

    R_PAREN  shift, and go to state 89


state 60

   45 funct_decl: type symbol_id arg_list . R_PAREN SEMICOLON

    R_PAREN  shift, and go to state 90


state 61

   25 array_indice: L_BRACKET CONS_INTEGER . R_BRACKET

    R_BRACKET  shift, and go to state 91


state 62

   89 expr: L_PAREN . expr R_PAREN

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 92
    funct_invoc_ref   go to state 74


state 63

   92 expr: NOT . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 93
    funct_invoc_ref   go to state 74


state 64

  104 expr: MINUS . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 94
    funct_invoc_ref   go to state 74


state 65

   40 literal_constant: CONS_INTEGER .

    $default  reduce using rule 40 (literal_constant)


state 66

   41 literal_constant: CONS_FLOAT .

    $default  reduce using rule 41 (literal_constant)


state 67

   42 literal_constant: CONS_SCIENTIFIC .

    $default  reduce using rule 42 (literal_constant)


state 68

   43 literal_constant: CONS_STRING .

    $default  reduce using rule 43 (literal_constant)


state 69

   44 literal_constant: CONS_BOOL .

    $default  reduce using rule 44 (literal_constant)


state 70

   76 var_ref: symbol_id .
   77        | symbol_id . arr_ref_indice
  128 funct_invoc_ref: symbol_id . funct_invoc_list R_PAREN

    L_PAREN    shift, and go to state 95
    L_BRACKET  shift, and go to state 96

    $default  reduce using rule 76 (var_ref)

    arr_ref_indice    go to state 97
    arr_ref_index     go to state 98
    funct_invoc_list  go to state 99


state 71

  105 expr: literal_constant .

    $default  reduce using rule 105 (expr)


state 72

  106 expr: var_ref .

    $default  reduce using rule 106 (expr)


state 73

   29 var_single: symbol_id ASSIGN expr .
   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    OR        shift, and go to state 100
    AND       shift, and go to state 101
    NOT_EQ    shift, and go to state 102
    GREAT     shift, and go to state 103
    GREAT_EQ  shift, and go to state 104
    EQUAL     shift, and go to state 105
    LESS_EQ   shift, and go to state 106
    LESS      shift, and go to state 107
    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 29 (var_single)


state 74

  107 expr: funct_invoc_ref .

    $default  reduce using rule 107 (expr)


state 75

   24 array_indice: array_indice L_BRACKET . CONS_INTEGER R_BRACKET

    CONS_INTEGER  shift, and go to state 113


state 76

   30 var_single: symbol_id array_indice ASSIGN . init_array

    L_BRACE  shift, and go to state 114

    init_array     go to state 115
    init_arr_list  go to state 116


state 77

   45 funct_decl: type symbol_id arg_list R_PAREN . SEMICOLON
   47 definition_list: type symbol_id arg_list R_PAREN . compound_st definition_list
   49                | type symbol_id arg_list R_PAREN . compound_st

    L_BRACE    shift, and go to state 83
    SEMICOLON  shift, and go to state 117

    compound_st    go to state 118
    compound_list  go to state 86


state 78

   21 identifier: symbol_id .
   22           | symbol_id . array_indice
   29 var_single: symbol_id . ASSIGN expr
   30           | symbol_id . array_indice ASSIGN init_array

    L_BRACKET  shift, and go to state 46
    ASSIGN     shift, and go to state 47

    $default  reduce using rule 21 (identifier)

    array_indice  go to state 48


state 79

   26 var_list: var_list COMMA var_single .

    $default  reduce using rule 26 (var_list)


state 80

   55 arg: type identifier .

    $default  reduce using rule 55 (arg)


state 81

   21 identifier: symbol_id .
   22           | symbol_id . array_indice

    L_BRACKET  shift, and go to state 46

    $default  reduce using rule 21 (identifier)

    array_indice  go to state 119


state 82

   53 nonEmpty_arg_list: arg COMMA . nonEmpty_arg_list

    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    type               go to state 52
    nonEmpty_arg_list  go to state 120
    arg                go to state 54


state 83

   57 compound_list: L_BRACE . nonEmpty_compound_list
   58              | L_BRACE .

    CONST     shift, and go to state 2
    STRING    shift, and go to state 3
    DOUBLE    shift, and go to state 4
    FLOAT     shift, and go to state 5
    BOOL      shift, and go to state 6
    INT       shift, and go to state 7
    BOOLEAN   shift, and go to state 8
    L_BRACE   shift, and go to state 83
    WHILE     shift, and go to state 121
    DO        shift, and go to state 122
    IF        shift, and go to state 123
    FOR       shift, and go to state 124
    PRINT     shift, and go to state 125
    READ      shift, and go to state 126
    CONTINUE  shift, and go to state 127
    BREAK     shift, and go to state 128
    RETURN    shift, and go to state 129
    ID        shift, and go to state 18

    $default  reduce using rule 58 (compound_list)

    var_decl                go to state 130
    type                    go to state 131
    symbol_id               go to state 132
    const_decl              go to state 133
    compound_st             go to state 134
    compound_list           go to state 86
    nonEmpty_compound_list  go to state 135
    statement               go to state 136
    simple_st               go to state 137
    var_ref                 go to state 138
    condition_st            go to state 139
    while_st                go to state 140
    jump_st                 go to state 141
    for_st                  go to state 142
    funct_invoc_st          go to state 143


state 84

   46 proc_decl: VOID symbol_id arg_list R_PAREN SEMICOLON .

    $default  reduce using rule 46 (proc_decl)


state 85

   48 definition_list: VOID symbol_id arg_list R_PAREN compound_st . definition_list
   50                | VOID symbol_id arg_list R_PAREN compound_st .

    $default  reduce using rule 50 (definition_list)

    type             go to state 145
    definition_list  go to state 146


state 86

   56 compound_st: compound_list . R_BRACE

    R_BRACE  shift, and go to state 147


state 87

   39 const_init: symbol_id ASSIGN literal_constant .

    $default  reduce using rule 39 (const_init)


state 88

   37 const_list: const_init COMMA const_list .

    $default  reduce using rule 37 (const_list)


state 89

   46 proc_decl: VOID symbol_id arg_list R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 84


state 90

   45 funct_decl: type symbol_id arg_list R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 117


state 91

   25 array_indice: L_BRACKET CONS_INTEGER R_BRACKET .

    $default  reduce using rule 25 (array_indice)


state 92

   89 expr: L_PAREN expr . R_PAREN
   90     | expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    R_PAREN   shift, and go to state 148
    OR        shift, and go to state 100
    AND       shift, and go to state 101
    NOT_EQ    shift, and go to state 102
    GREAT     shift, and go to state 103
    GREAT_EQ  shift, and go to state 104
    EQUAL     shift, and go to state 105
    LESS_EQ   shift, and go to state 106
    LESS      shift, and go to state 107
    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112


state 93

   90 expr: expr . OR expr
   91     | expr . AND expr
   92     | NOT expr .
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    OR        shift, and go to state 100
    AND       shift, and go to state 101
    NOT_EQ    shift, and go to state 102
    GREAT     shift, and go to state 103
    GREAT_EQ  shift, and go to state 104
    EQUAL     shift, and go to state 105
    LESS_EQ   shift, and go to state 106
    LESS      shift, and go to state 107
    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    OR        [reduce using rule 92 (expr)]
    AND       [reduce using rule 92 (expr)]
    NOT_EQ    [reduce using rule 92 (expr)]
    GREAT     [reduce using rule 92 (expr)]
    GREAT_EQ  [reduce using rule 92 (expr)]
    EQUAL     [reduce using rule 92 (expr)]
    LESS_EQ   [reduce using rule 92 (expr)]
    LESS      [reduce using rule 92 (expr)]
    MINUS     [reduce using rule 92 (expr)]
    PLUS      [reduce using rule 92 (expr)]
    MOD       [reduce using rule 92 (expr)]
    DIVIDE    [reduce using rule 92 (expr)]
    MULTIPLY  [reduce using rule 92 (expr)]
    $default  reduce using rule 92 (expr)


state 94

   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr
  104     | MINUS expr .

    $default  reduce using rule 104 (expr)


state 95

  130 funct_invoc_list: L_PAREN .
  131                 | L_PAREN . nonEmpty_funct_invoc_list

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    $default  reduce using rule 130 (funct_invoc_list)

    symbol_id                  go to state 70
    literal_constant           go to state 71
    var_ref                    go to state 72
    expr                       go to state 149
    funct_invoc_ref            go to state 74
    nonEmpty_funct_invoc_list  go to state 150


state 96

   80 arr_ref_index: L_BRACKET . expr R_BRACKET

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 151
    funct_invoc_ref   go to state 74


state 97

   77 var_ref: symbol_id arr_ref_indice .

    $default  reduce using rule 77 (var_ref)


state 98

   78 arr_ref_indice: arr_ref_index . arr_ref_indice
   79               | arr_ref_index .

    L_BRACKET  shift, and go to state 96

    $default  reduce using rule 79 (arr_ref_indice)

    arr_ref_indice  go to state 152
    arr_ref_index   go to state 98


state 99

  128 funct_invoc_ref: symbol_id funct_invoc_list . R_PAREN

    R_PAREN  shift, and go to state 153


state 100

   90 expr: expr OR . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 154
    funct_invoc_ref   go to state 74


state 101

   91 expr: expr AND . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 155
    funct_invoc_ref   go to state 74


state 102

   98 expr: expr NOT_EQ . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 156
    funct_invoc_ref   go to state 74


state 103

   97 expr: expr GREAT . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 157
    funct_invoc_ref   go to state 74


state 104

   96 expr: expr GREAT_EQ . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 158
    funct_invoc_ref   go to state 74


state 105

   95 expr: expr EQUAL . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 159
    funct_invoc_ref   go to state 74


state 106

   94 expr: expr LESS_EQ . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 160
    funct_invoc_ref   go to state 74


state 107

   93 expr: expr LESS . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 161
    funct_invoc_ref   go to state 74


state 108

  100 expr: expr MINUS . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 162
    funct_invoc_ref   go to state 74


state 109

   99 expr: expr PLUS . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 163
    funct_invoc_ref   go to state 74


state 110

  103 expr: expr MOD . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 164
    funct_invoc_ref   go to state 74


state 111

  102 expr: expr DIVIDE . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 165
    funct_invoc_ref   go to state 74


state 112

  101 expr: expr MULTIPLY . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 166
    funct_invoc_ref   go to state 74


state 113

   24 array_indice: array_indice L_BRACKET CONS_INTEGER . R_BRACKET

    R_BRACKET  shift, and go to state 167


state 114

   32 init_arr_list: L_BRACE . nonEmpty_init_arr_list
   33              | L_BRACE .

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    $default  reduce using rule 33 (init_arr_list)

    symbol_id               go to state 70
    nonEmpty_init_arr_list  go to state 168
    literal_constant        go to state 71
    var_ref                 go to state 72
    expr                    go to state 169
    funct_invoc_ref         go to state 74


state 115

   30 var_single: symbol_id array_indice ASSIGN init_array .

    $default  reduce using rule 30 (var_single)


state 116

   31 init_array: init_arr_list . R_BRACE

    R_BRACE  shift, and go to state 170


state 117

   45 funct_decl: type symbol_id arg_list R_PAREN SEMICOLON .

    $default  reduce using rule 45 (funct_decl)


state 118

   47 definition_list: type symbol_id arg_list R_PAREN compound_st . definition_list
   49                | type symbol_id arg_list R_PAREN compound_st .

    $default  reduce using rule 49 (definition_list)

    type             go to state 145
    definition_list  go to state 171


state 119

   22 identifier: symbol_id array_indice .
   24 array_indice: array_indice . L_BRACKET CONS_INTEGER R_BRACKET

    L_BRACKET  shift, and go to state 75

    $default  reduce using rule 22 (identifier)


state 120

   53 nonEmpty_arg_list: arg COMMA nonEmpty_arg_list .

    $default  reduce using rule 53 (nonEmpty_arg_list)


state 121

   84 while_st: WHILE . L_PAREN bool_expr R_PAREN compound_st

    L_PAREN  shift, and go to state 172


state 122

   85 while_st: DO . compound_st WHILE L_PAREN bool_expr R_PAREN SEMICOLON

    L_BRACE  shift, and go to state 83

    compound_st    go to state 173
    compound_list  go to state 86


state 123

   81 condition_st: IF . L_PAREN bool_expr R_PAREN compound_st
   82             | IF . L_PAREN bool_expr R_PAREN compound_st ELSE compound_st

    L_PAREN  shift, and go to state 174


state 124

  108 for_st: FOR . for_init for_control for_incre R_PAREN compound_st

    L_PAREN  shift, and go to state 175

    for_init  go to state 176


state 125

   73 simple_st: PRINT . var_ref SEMICOLON
   74          | PRINT . expr SEMICOLON

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 177
    expr              go to state 178
    funct_invoc_ref   go to state 74


state 126

   75 simple_st: READ . var_ref SEMICOLON

    ID  shift, and go to state 18

    symbol_id  go to state 179
    var_ref    go to state 180


state 127

   88 jump_st: CONTINUE . SEMICOLON

    SEMICOLON  shift, and go to state 181


state 128

   87 jump_st: BREAK . SEMICOLON

    SEMICOLON  shift, and go to state 182


state 129

   86 jump_st: RETURN . expr SEMICOLON

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 183
    funct_invoc_ref   go to state 74


state 130

   59 nonEmpty_compound_list: var_decl . nonEmpty_compound_list
   62                       | var_decl .

    CONST     shift, and go to state 2
    STRING    shift, and go to state 3
    DOUBLE    shift, and go to state 4
    FLOAT     shift, and go to state 5
    BOOL      shift, and go to state 6
    INT       shift, and go to state 7
    BOOLEAN   shift, and go to state 8
    L_BRACE   shift, and go to state 83
    WHILE     shift, and go to state 121
    DO        shift, and go to state 122
    IF        shift, and go to state 123
    FOR       shift, and go to state 124
    PRINT     shift, and go to state 125
    READ      shift, and go to state 126
    CONTINUE  shift, and go to state 127
    BREAK     shift, and go to state 128
    RETURN    shift, and go to state 129
    ID        shift, and go to state 18

    $default  reduce using rule 62 (nonEmpty_compound_list)

    var_decl                go to state 130
    type                    go to state 131
    symbol_id               go to state 132
    const_decl              go to state 133
    compound_st             go to state 134
    compound_list           go to state 86
    nonEmpty_compound_list  go to state 184
    statement               go to state 136
    simple_st               go to state 137
    var_ref                 go to state 138
    condition_st            go to state 139
    while_st                go to state 140
    jump_st                 go to state 141
    for_st                  go to state 142
    funct_invoc_st          go to state 143


state 131

   14 var_decl: type . var_list SEMICOLON

    ID  shift, and go to state 18

    identifier  go to state 30
    symbol_id   go to state 78
    var_list    go to state 32
    var_single  go to state 33


state 132

   76 var_ref: symbol_id .
   77        | symbol_id . arr_ref_indice
  129 funct_invoc_st: symbol_id . funct_invoc_list R_PAREN SEMICOLON

    L_PAREN    shift, and go to state 95
    L_BRACKET  shift, and go to state 96

    $default  reduce using rule 76 (var_ref)

    arr_ref_indice    go to state 97
    arr_ref_index     go to state 98
    funct_invoc_list  go to state 185


state 133

   60 nonEmpty_compound_list: const_decl . nonEmpty_compound_list
   63                       | const_decl .

    CONST     shift, and go to state 2
    STRING    shift, and go to state 3
    DOUBLE    shift, and go to state 4
    FLOAT     shift, and go to state 5
    BOOL      shift, and go to state 6
    INT       shift, and go to state 7
    BOOLEAN   shift, and go to state 8
    L_BRACE   shift, and go to state 83
    WHILE     shift, and go to state 121
    DO        shift, and go to state 122
    IF        shift, and go to state 123
    FOR       shift, and go to state 124
    PRINT     shift, and go to state 125
    READ      shift, and go to state 126
    CONTINUE  shift, and go to state 127
    BREAK     shift, and go to state 128
    RETURN    shift, and go to state 129
    ID        shift, and go to state 18

    $default  reduce using rule 63 (nonEmpty_compound_list)

    var_decl                go to state 130
    type                    go to state 131
    symbol_id               go to state 132
    const_decl              go to state 133
    compound_st             go to state 134
    compound_list           go to state 86
    nonEmpty_compound_list  go to state 186
    statement               go to state 136
    simple_st               go to state 137
    var_ref                 go to state 138
    condition_st            go to state 139
    while_st                go to state 140
    jump_st                 go to state 141
    for_st                  go to state 142
    funct_invoc_st          go to state 143


state 134

   65 statement: compound_st .

    $default  reduce using rule 65 (statement)


state 135

   57 compound_list: L_BRACE nonEmpty_compound_list .

    $default  reduce using rule 57 (compound_list)


state 136

   61 nonEmpty_compound_list: statement . nonEmpty_compound_list
   64                       | statement .

    CONST     shift, and go to state 2
    STRING    shift, and go to state 3
    DOUBLE    shift, and go to state 4
    FLOAT     shift, and go to state 5
    BOOL      shift, and go to state 6
    INT       shift, and go to state 7
    BOOLEAN   shift, and go to state 8
    L_BRACE   shift, and go to state 83
    WHILE     shift, and go to state 121
    DO        shift, and go to state 122
    IF        shift, and go to state 123
    FOR       shift, and go to state 124
    PRINT     shift, and go to state 125
    READ      shift, and go to state 126
    CONTINUE  shift, and go to state 127
    BREAK     shift, and go to state 128
    RETURN    shift, and go to state 129
    ID        shift, and go to state 18

    $default  reduce using rule 64 (nonEmpty_compound_list)

    var_decl                go to state 130
    type                    go to state 131
    symbol_id               go to state 132
    const_decl              go to state 133
    compound_st             go to state 134
    compound_list           go to state 86
    nonEmpty_compound_list  go to state 187
    statement               go to state 136
    simple_st               go to state 137
    var_ref                 go to state 138
    condition_st            go to state 139
    while_st                go to state 140
    jump_st                 go to state 141
    for_st                  go to state 142
    funct_invoc_st          go to state 143


state 137

   66 statement: simple_st .

    $default  reduce using rule 66 (statement)


state 138

   72 simple_st: var_ref . ASSIGN expr SEMICOLON

    ASSIGN  shift, and go to state 188


state 139

   67 statement: condition_st .

    $default  reduce using rule 67 (statement)


state 140

   68 statement: while_st .

    $default  reduce using rule 68 (statement)


state 141

   70 statement: jump_st .

    $default  reduce using rule 70 (statement)


state 142

   69 statement: for_st .

    $default  reduce using rule 69 (statement)


state 143

   71 statement: funct_invoc_st .

    $default  reduce using rule 71 (statement)


state 144

   48 definition_list: VOID . symbol_id arg_list R_PAREN compound_st definition_list
   50                | VOID . symbol_id arg_list R_PAREN compound_st

    ID  shift, and go to state 18

    symbol_id  go to state 189


state 145

   47 definition_list: type . symbol_id arg_list R_PAREN compound_st definition_list
   49                | type . symbol_id arg_list R_PAREN compound_st

    ID  shift, and go to state 18

    symbol_id  go to state 190


state 146

   48 definition_list: VOID symbol_id arg_list R_PAREN compound_st definition_list .

    $default  reduce using rule 48 (definition_list)


state 147

   56 compound_st: compound_list R_BRACE .

    $default  reduce using rule 56 (compound_st)


state 148

   89 expr: L_PAREN expr R_PAREN .

    $default  reduce using rule 89 (expr)


state 149

   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr
  133 nonEmpty_funct_invoc_list: expr .

    OR        shift, and go to state 100
    AND       shift, and go to state 101
    NOT_EQ    shift, and go to state 102
    GREAT     shift, and go to state 103
    GREAT_EQ  shift, and go to state 104
    EQUAL     shift, and go to state 105
    LESS_EQ   shift, and go to state 106
    LESS      shift, and go to state 107
    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 133 (nonEmpty_funct_invoc_list)


state 150

  131 funct_invoc_list: L_PAREN nonEmpty_funct_invoc_list .
  132 nonEmpty_funct_invoc_list: nonEmpty_funct_invoc_list . COMMA expr

    COMMA  shift, and go to state 191

    $default  reduce using rule 131 (funct_invoc_list)


state 151

   80 arr_ref_index: L_BRACKET expr . R_BRACKET
   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    R_BRACKET  shift, and go to state 192
    OR         shift, and go to state 100
    AND        shift, and go to state 101
    NOT_EQ     shift, and go to state 102
    GREAT      shift, and go to state 103
    GREAT_EQ   shift, and go to state 104
    EQUAL      shift, and go to state 105
    LESS_EQ    shift, and go to state 106
    LESS       shift, and go to state 107
    MINUS      shift, and go to state 108
    PLUS       shift, and go to state 109
    MOD        shift, and go to state 110
    DIVIDE     shift, and go to state 111
    MULTIPLY   shift, and go to state 112


state 152

   78 arr_ref_indice: arr_ref_index arr_ref_indice .

    $default  reduce using rule 78 (arr_ref_indice)


state 153

  128 funct_invoc_ref: symbol_id funct_invoc_list R_PAREN .

    $default  reduce using rule 128 (funct_invoc_ref)


state 154

   90 expr: expr . OR expr
   90     | expr OR expr .
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    AND       shift, and go to state 101
    NOT_EQ    shift, and go to state 102
    GREAT     shift, and go to state 103
    GREAT_EQ  shift, and go to state 104
    EQUAL     shift, and go to state 105
    LESS_EQ   shift, and go to state 106
    LESS      shift, and go to state 107
    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 90 (expr)


state 155

   90 expr: expr . OR expr
   91     | expr . AND expr
   91     | expr AND expr .
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    NOT_EQ    shift, and go to state 102
    GREAT     shift, and go to state 103
    GREAT_EQ  shift, and go to state 104
    EQUAL     shift, and go to state 105
    LESS_EQ   shift, and go to state 106
    LESS      shift, and go to state 107
    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 91 (expr)


state 156

   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   98     | expr NOT_EQ expr .
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 98 (expr)


state 157

   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   97     | expr GREAT expr .
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 97 (expr)


state 158

   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   96     | expr GREAT_EQ expr .
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 96 (expr)


state 159

   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   95     | expr EQUAL expr .
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 95 (expr)


state 160

   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   94     | expr LESS_EQ expr .
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 94 (expr)


state 161

   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   93     | expr LESS expr .
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 93 (expr)


state 162

   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  100     | expr MINUS expr .
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 100 (expr)


state 163

   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
   99     | expr PLUS expr .
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 99 (expr)


state 164

   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr
  103     | expr MOD expr .

    $default  reduce using rule 103 (expr)


state 165

   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  102     | expr DIVIDE expr .
  103     | expr . MOD expr

    $default  reduce using rule 102 (expr)


state 166

   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  101     | expr MULTIPLY expr .
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    $default  reduce using rule 101 (expr)


state 167

   24 array_indice: array_indice L_BRACKET CONS_INTEGER R_BRACKET .

    $default  reduce using rule 24 (array_indice)


state 168

   32 init_arr_list: L_BRACE nonEmpty_init_arr_list .
   34 nonEmpty_init_arr_list: nonEmpty_init_arr_list . COMMA expr

    COMMA  shift, and go to state 193

    $default  reduce using rule 32 (init_arr_list)


state 169

   35 nonEmpty_init_arr_list: expr .
   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    OR        shift, and go to state 100
    AND       shift, and go to state 101
    NOT_EQ    shift, and go to state 102
    GREAT     shift, and go to state 103
    GREAT_EQ  shift, and go to state 104
    EQUAL     shift, and go to state 105
    LESS_EQ   shift, and go to state 106
    LESS      shift, and go to state 107
    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 35 (nonEmpty_init_arr_list)


state 170

   31 init_array: init_arr_list R_BRACE .

    $default  reduce using rule 31 (init_array)


state 171

   47 definition_list: type symbol_id arg_list R_PAREN compound_st definition_list .

    $default  reduce using rule 47 (definition_list)


state 172

   84 while_st: WHILE L_PAREN . bool_expr R_PAREN compound_st

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    bool_expr         go to state 194
    expr              go to state 195
    funct_invoc_ref   go to state 74


state 173

   85 while_st: DO compound_st . WHILE L_PAREN bool_expr R_PAREN SEMICOLON

    WHILE  shift, and go to state 196


state 174

   81 condition_st: IF L_PAREN . bool_expr R_PAREN compound_st
   82             | IF L_PAREN . bool_expr R_PAREN compound_st ELSE compound_st

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    bool_expr         go to state 197
    expr              go to state 195
    funct_invoc_ref   go to state 74


state 175

  109 for_init: L_PAREN . nonEmpty_for_init
  110         | L_PAREN .

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    $default  reduce using rule 110 (for_init)

    symbol_id          go to state 198
    literal_constant   go to state 71
    var_ref            go to state 72
    expr               go to state 199
    nonEmpty_for_init  go to state 200
    for_single_entry   go to state 201
    funct_invoc_ref    go to state 74


state 176

  108 for_st: FOR for_init . for_control for_incre R_PAREN compound_st

    SEMICOLON  shift, and go to state 202

    for_control  go to state 203


state 177

   73 simple_st: PRINT var_ref . SEMICOLON
  106 expr: var_ref .

    SEMICOLON  shift, and go to state 204

    SEMICOLON  [reduce using rule 106 (expr)]
    $default   reduce using rule 106 (expr)


state 178

   74 simple_st: PRINT expr . SEMICOLON
   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    OR         shift, and go to state 100
    AND        shift, and go to state 101
    NOT_EQ     shift, and go to state 102
    GREAT      shift, and go to state 103
    GREAT_EQ   shift, and go to state 104
    EQUAL      shift, and go to state 105
    LESS_EQ    shift, and go to state 106
    LESS       shift, and go to state 107
    MINUS      shift, and go to state 108
    PLUS       shift, and go to state 109
    MOD        shift, and go to state 110
    DIVIDE     shift, and go to state 111
    MULTIPLY   shift, and go to state 112
    SEMICOLON  shift, and go to state 205


state 179

   76 var_ref: symbol_id .
   77        | symbol_id . arr_ref_indice

    L_BRACKET  shift, and go to state 96

    $default  reduce using rule 76 (var_ref)

    arr_ref_indice  go to state 97
    arr_ref_index   go to state 98


state 180

   75 simple_st: READ var_ref . SEMICOLON

    SEMICOLON  shift, and go to state 206


state 181

   88 jump_st: CONTINUE SEMICOLON .

    $default  reduce using rule 88 (jump_st)


state 182

   87 jump_st: BREAK SEMICOLON .

    $default  reduce using rule 87 (jump_st)


state 183

   86 jump_st: RETURN expr . SEMICOLON
   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    OR         shift, and go to state 100
    AND        shift, and go to state 101
    NOT_EQ     shift, and go to state 102
    GREAT      shift, and go to state 103
    GREAT_EQ   shift, and go to state 104
    EQUAL      shift, and go to state 105
    LESS_EQ    shift, and go to state 106
    LESS       shift, and go to state 107
    MINUS      shift, and go to state 108
    PLUS       shift, and go to state 109
    MOD        shift, and go to state 110
    DIVIDE     shift, and go to state 111
    MULTIPLY   shift, and go to state 112
    SEMICOLON  shift, and go to state 207


state 184

   59 nonEmpty_compound_list: var_decl nonEmpty_compound_list .

    $default  reduce using rule 59 (nonEmpty_compound_list)


state 185

  129 funct_invoc_st: symbol_id funct_invoc_list . R_PAREN SEMICOLON

    R_PAREN  shift, and go to state 208


state 186

   60 nonEmpty_compound_list: const_decl nonEmpty_compound_list .

    $default  reduce using rule 60 (nonEmpty_compound_list)


state 187

   61 nonEmpty_compound_list: statement nonEmpty_compound_list .

    $default  reduce using rule 61 (nonEmpty_compound_list)


state 188

   72 simple_st: var_ref ASSIGN . expr SEMICOLON

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 209
    funct_invoc_ref   go to state 74


state 189

   48 definition_list: VOID symbol_id . arg_list R_PAREN compound_st definition_list
   50                | VOID symbol_id . arg_list R_PAREN compound_st

    L_PAREN  shift, and go to state 35

    arg_list  go to state 210


state 190

   47 definition_list: type symbol_id . arg_list R_PAREN compound_st definition_list
   49                | type symbol_id . arg_list R_PAREN compound_st

    L_PAREN  shift, and go to state 35

    arg_list  go to state 211


state 191

  132 nonEmpty_funct_invoc_list: nonEmpty_funct_invoc_list COMMA . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 212
    funct_invoc_ref   go to state 74


state 192

   80 arr_ref_index: L_BRACKET expr R_BRACKET .

    $default  reduce using rule 80 (arr_ref_index)


state 193

   34 nonEmpty_init_arr_list: nonEmpty_init_arr_list COMMA . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 213
    funct_invoc_ref   go to state 74


state 194

   84 while_st: WHILE L_PAREN bool_expr . R_PAREN compound_st

    R_PAREN  shift, and go to state 214


state 195

   83 bool_expr: expr .
   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    OR        shift, and go to state 100
    AND       shift, and go to state 101
    NOT_EQ    shift, and go to state 102
    GREAT     shift, and go to state 103
    GREAT_EQ  shift, and go to state 104
    EQUAL     shift, and go to state 105
    LESS_EQ   shift, and go to state 106
    LESS      shift, and go to state 107
    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 83 (bool_expr)


state 196

   85 while_st: DO compound_st WHILE . L_PAREN bool_expr R_PAREN SEMICOLON

    L_PAREN  shift, and go to state 215


state 197

   81 condition_st: IF L_PAREN bool_expr . R_PAREN compound_st
   82             | IF L_PAREN bool_expr . R_PAREN compound_st ELSE compound_st

    R_PAREN  shift, and go to state 216


state 198

   76 var_ref: symbol_id .
   77        | symbol_id . arr_ref_indice
  124 for_single_entry: symbol_id . ASSIGN expr
  125                 | symbol_id . array_indice ASSIGN init_array
  127                 | symbol_id . funct_invoc_list R_PAREN
  128 funct_invoc_ref: symbol_id . funct_invoc_list R_PAREN

    L_PAREN    shift, and go to state 95
    L_BRACKET  shift, and go to state 217
    ASSIGN     shift, and go to state 218

    $default  reduce using rule 76 (var_ref)

    array_indice      go to state 219
    arr_ref_indice    go to state 97
    arr_ref_index     go to state 98
    funct_invoc_list  go to state 220


state 199

   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr
  126 for_single_entry: expr .

    OR        shift, and go to state 100
    AND       shift, and go to state 101
    NOT_EQ    shift, and go to state 102
    GREAT     shift, and go to state 103
    GREAT_EQ  shift, and go to state 104
    EQUAL     shift, and go to state 105
    LESS_EQ   shift, and go to state 106
    LESS      shift, and go to state 107
    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 126 (for_single_entry)


state 200

  109 for_init: L_PAREN nonEmpty_for_init .
  111 nonEmpty_for_init: nonEmpty_for_init . COMMA for_single_entry

    COMMA  shift, and go to state 221

    $default  reduce using rule 109 (for_init)


state 201

  112 nonEmpty_for_init: for_single_entry .

    $default  reduce using rule 112 (nonEmpty_for_init)


state 202

  117 for_control: SEMICOLON . nonEmpty_for_control
  118            | SEMICOLON .

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    $default  reduce using rule 118 (for_control)

    symbol_id             go to state 222
    literal_constant      go to state 71
    var_ref               go to state 72
    expr                  go to state 223
    nonEmpty_for_control  go to state 224
    for_control_entry     go to state 225
    funct_invoc_ref       go to state 74


state 203

  108 for_st: FOR for_init for_control . for_incre R_PAREN compound_st

    SEMICOLON  shift, and go to state 226

    for_incre  go to state 227


state 204

   73 simple_st: PRINT var_ref SEMICOLON .

    $default  reduce using rule 73 (simple_st)


state 205

   74 simple_st: PRINT expr SEMICOLON .

    $default  reduce using rule 74 (simple_st)


state 206

   75 simple_st: READ var_ref SEMICOLON .

    $default  reduce using rule 75 (simple_st)


state 207

   86 jump_st: RETURN expr SEMICOLON .

    $default  reduce using rule 86 (jump_st)


state 208

  129 funct_invoc_st: symbol_id funct_invoc_list R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 228


state 209

   72 simple_st: var_ref ASSIGN expr . SEMICOLON
   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    OR         shift, and go to state 100
    AND        shift, and go to state 101
    NOT_EQ     shift, and go to state 102
    GREAT      shift, and go to state 103
    GREAT_EQ   shift, and go to state 104
    EQUAL      shift, and go to state 105
    LESS_EQ    shift, and go to state 106
    LESS       shift, and go to state 107
    MINUS      shift, and go to state 108
    PLUS       shift, and go to state 109
    MOD        shift, and go to state 110
    DIVIDE     shift, and go to state 111
    MULTIPLY   shift, and go to state 112
    SEMICOLON  shift, and go to state 229


state 210

   48 definition_list: VOID symbol_id arg_list . R_PAREN compound_st definition_list
   50                | VOID symbol_id arg_list . R_PAREN compound_st

    R_PAREN  shift, and go to state 230


state 211

   47 definition_list: type symbol_id arg_list . R_PAREN compound_st definition_list
   49                | type symbol_id arg_list . R_PAREN compound_st

    R_PAREN  shift, and go to state 231


state 212

   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr
  132 nonEmpty_funct_invoc_list: nonEmpty_funct_invoc_list COMMA expr .

    OR        shift, and go to state 100
    AND       shift, and go to state 101
    NOT_EQ    shift, and go to state 102
    GREAT     shift, and go to state 103
    GREAT_EQ  shift, and go to state 104
    EQUAL     shift, and go to state 105
    LESS_EQ   shift, and go to state 106
    LESS      shift, and go to state 107
    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 132 (nonEmpty_funct_invoc_list)


state 213

   34 nonEmpty_init_arr_list: nonEmpty_init_arr_list COMMA expr .
   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr

    OR        shift, and go to state 100
    AND       shift, and go to state 101
    NOT_EQ    shift, and go to state 102
    GREAT     shift, and go to state 103
    GREAT_EQ  shift, and go to state 104
    EQUAL     shift, and go to state 105
    LESS_EQ   shift, and go to state 106
    LESS      shift, and go to state 107
    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 34 (nonEmpty_init_arr_list)


state 214

   84 while_st: WHILE L_PAREN bool_expr R_PAREN . compound_st

    L_BRACE  shift, and go to state 83

    compound_st    go to state 232
    compound_list  go to state 86


state 215

   85 while_st: DO compound_st WHILE L_PAREN . bool_expr R_PAREN SEMICOLON

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    bool_expr         go to state 233
    expr              go to state 195
    funct_invoc_ref   go to state 74


state 216

   81 condition_st: IF L_PAREN bool_expr R_PAREN . compound_st
   82             | IF L_PAREN bool_expr R_PAREN . compound_st ELSE compound_st

    L_BRACE  shift, and go to state 83

    compound_st    go to state 234
    compound_list  go to state 86


state 217

   25 array_indice: L_BRACKET . CONS_INTEGER R_BRACKET
   80 arr_ref_index: L_BRACKET . expr R_BRACKET

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 235
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 151
    funct_invoc_ref   go to state 74


state 218

  124 for_single_entry: symbol_id ASSIGN . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 236
    funct_invoc_ref   go to state 74


state 219

   24 array_indice: array_indice . L_BRACKET CONS_INTEGER R_BRACKET
  125 for_single_entry: symbol_id array_indice . ASSIGN init_array

    L_BRACKET  shift, and go to state 75
    ASSIGN     shift, and go to state 237


state 220

  127 for_single_entry: symbol_id funct_invoc_list . R_PAREN
  128 funct_invoc_ref: symbol_id funct_invoc_list . R_PAREN

    R_PAREN  shift, and go to state 238


state 221

  111 nonEmpty_for_init: nonEmpty_for_init COMMA . for_single_entry

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 198
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 199
    for_single_entry  go to state 239
    funct_invoc_ref   go to state 74


state 222

   76 var_ref: symbol_id .
   77        | symbol_id . arr_ref_indice
  122 for_control_entry: symbol_id . ASSIGN expr
  123                  | symbol_id . array_indice ASSIGN init_array
  128 funct_invoc_ref: symbol_id . funct_invoc_list R_PAREN

    L_PAREN    shift, and go to state 95
    L_BRACKET  shift, and go to state 217
    ASSIGN     shift, and go to state 240

    $default  reduce using rule 76 (var_ref)

    array_indice      go to state 241
    arr_ref_indice    go to state 97
    arr_ref_index     go to state 98
    funct_invoc_list  go to state 99


state 223

   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr
  121 for_control_entry: expr .

    OR        shift, and go to state 100
    AND       shift, and go to state 101
    NOT_EQ    shift, and go to state 102
    GREAT     shift, and go to state 103
    GREAT_EQ  shift, and go to state 104
    EQUAL     shift, and go to state 105
    LESS_EQ   shift, and go to state 106
    LESS      shift, and go to state 107
    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 121 (for_control_entry)


state 224

  117 for_control: SEMICOLON nonEmpty_for_control .
  119 nonEmpty_for_control: nonEmpty_for_control . COMMA for_control_entry

    COMMA  shift, and go to state 242

    $default  reduce using rule 117 (for_control)


state 225

  120 nonEmpty_for_control: for_control_entry .

    $default  reduce using rule 120 (nonEmpty_for_control)


state 226

  113 for_incre: SEMICOLON . nonEmpty_for_incre
  114          | SEMICOLON .

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    $default  reduce using rule 114 (for_incre)

    symbol_id           go to state 198
    literal_constant    go to state 71
    var_ref             go to state 72
    expr                go to state 199
    nonEmpty_for_incre  go to state 243
    for_single_entry    go to state 244
    funct_invoc_ref     go to state 74


state 227

  108 for_st: FOR for_init for_control for_incre . R_PAREN compound_st

    R_PAREN  shift, and go to state 245


state 228

  129 funct_invoc_st: symbol_id funct_invoc_list R_PAREN SEMICOLON .

    $default  reduce using rule 129 (funct_invoc_st)


state 229

   72 simple_st: var_ref ASSIGN expr SEMICOLON .

    $default  reduce using rule 72 (simple_st)


state 230

   48 definition_list: VOID symbol_id arg_list R_PAREN . compound_st definition_list
   50                | VOID symbol_id arg_list R_PAREN . compound_st

    L_BRACE  shift, and go to state 83

    compound_st    go to state 85
    compound_list  go to state 86


state 231

   47 definition_list: type symbol_id arg_list R_PAREN . compound_st definition_list
   49                | type symbol_id arg_list R_PAREN . compound_st

    L_BRACE  shift, and go to state 83

    compound_st    go to state 118
    compound_list  go to state 86


state 232

   84 while_st: WHILE L_PAREN bool_expr R_PAREN compound_st .

    $default  reduce using rule 84 (while_st)


state 233

   85 while_st: DO compound_st WHILE L_PAREN bool_expr . R_PAREN SEMICOLON

    R_PAREN  shift, and go to state 246


state 234

   81 condition_st: IF L_PAREN bool_expr R_PAREN compound_st .
   82             | IF L_PAREN bool_expr R_PAREN compound_st . ELSE compound_st

    ELSE  shift, and go to state 247

    $default  reduce using rule 81 (condition_st)


state 235

   25 array_indice: L_BRACKET CONS_INTEGER . R_BRACKET
   40 literal_constant: CONS_INTEGER .

    R_BRACKET  shift, and go to state 91

    R_BRACKET  [reduce using rule 40 (literal_constant)]
    $default   reduce using rule 40 (literal_constant)


state 236

   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr
  124 for_single_entry: symbol_id ASSIGN expr .

    OR        shift, and go to state 100
    AND       shift, and go to state 101
    NOT_EQ    shift, and go to state 102
    GREAT     shift, and go to state 103
    GREAT_EQ  shift, and go to state 104
    EQUAL     shift, and go to state 105
    LESS_EQ   shift, and go to state 106
    LESS      shift, and go to state 107
    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 124 (for_single_entry)


state 237

  125 for_single_entry: symbol_id array_indice ASSIGN . init_array

    L_BRACE  shift, and go to state 114

    init_array     go to state 248
    init_arr_list  go to state 116


state 238

  127 for_single_entry: symbol_id funct_invoc_list R_PAREN .
  128 funct_invoc_ref: symbol_id funct_invoc_list R_PAREN .

    R_PAREN    reduce using rule 127 (for_single_entry)
    R_PAREN    [reduce using rule 128 (funct_invoc_ref)]
    SEMICOLON  reduce using rule 127 (for_single_entry)
    SEMICOLON  [reduce using rule 128 (funct_invoc_ref)]
    COMMA      reduce using rule 127 (for_single_entry)
    COMMA      [reduce using rule 128 (funct_invoc_ref)]
    $default   reduce using rule 128 (funct_invoc_ref)


state 239

  111 nonEmpty_for_init: nonEmpty_for_init COMMA for_single_entry .

    $default  reduce using rule 111 (nonEmpty_for_init)


state 240

  122 for_control_entry: symbol_id ASSIGN . expr

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 70
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 249
    funct_invoc_ref   go to state 74


state 241

   24 array_indice: array_indice . L_BRACKET CONS_INTEGER R_BRACKET
  123 for_control_entry: symbol_id array_indice . ASSIGN init_array

    L_BRACKET  shift, and go to state 75
    ASSIGN     shift, and go to state 250


state 242

  119 nonEmpty_for_control: nonEmpty_for_control COMMA . for_control_entry

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id          go to state 222
    literal_constant   go to state 71
    var_ref            go to state 72
    expr               go to state 223
    for_control_entry  go to state 251
    funct_invoc_ref    go to state 74


state 243

  113 for_incre: SEMICOLON nonEmpty_for_incre .
  115 nonEmpty_for_incre: nonEmpty_for_incre . COMMA for_single_entry

    COMMA  shift, and go to state 252

    $default  reduce using rule 113 (for_incre)


state 244

  116 nonEmpty_for_incre: for_single_entry .

    $default  reduce using rule 116 (nonEmpty_for_incre)


state 245

  108 for_st: FOR for_init for_control for_incre R_PAREN . compound_st

    L_BRACE  shift, and go to state 83

    compound_st    go to state 253
    compound_list  go to state 86


state 246

   85 while_st: DO compound_st WHILE L_PAREN bool_expr R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 254


state 247

   82 condition_st: IF L_PAREN bool_expr R_PAREN compound_st ELSE . compound_st

    L_BRACE  shift, and go to state 83

    compound_st    go to state 255
    compound_list  go to state 86


state 248

  125 for_single_entry: symbol_id array_indice ASSIGN init_array .

    $default  reduce using rule 125 (for_single_entry)


state 249

   90 expr: expr . OR expr
   91     | expr . AND expr
   93     | expr . LESS expr
   94     | expr . LESS_EQ expr
   95     | expr . EQUAL expr
   96     | expr . GREAT_EQ expr
   97     | expr . GREAT expr
   98     | expr . NOT_EQ expr
   99     | expr . PLUS expr
  100     | expr . MINUS expr
  101     | expr . MULTIPLY expr
  102     | expr . DIVIDE expr
  103     | expr . MOD expr
  122 for_control_entry: symbol_id ASSIGN expr .

    OR        shift, and go to state 100
    AND       shift, and go to state 101
    NOT_EQ    shift, and go to state 102
    GREAT     shift, and go to state 103
    GREAT_EQ  shift, and go to state 104
    EQUAL     shift, and go to state 105
    LESS_EQ   shift, and go to state 106
    LESS      shift, and go to state 107
    MINUS     shift, and go to state 108
    PLUS      shift, and go to state 109
    MOD       shift, and go to state 110
    DIVIDE    shift, and go to state 111
    MULTIPLY  shift, and go to state 112

    $default  reduce using rule 122 (for_control_entry)


state 250

  123 for_control_entry: symbol_id array_indice ASSIGN . init_array

    L_BRACE  shift, and go to state 114

    init_array     go to state 256
    init_arr_list  go to state 116


state 251

  119 nonEmpty_for_control: nonEmpty_for_control COMMA for_control_entry .

    $default  reduce using rule 119 (nonEmpty_for_control)


state 252

  115 nonEmpty_for_incre: nonEmpty_for_incre COMMA . for_single_entry

    L_PAREN          shift, and go to state 62
    NOT              shift, and go to state 63
    MINUS            shift, and go to state 64
    ID               shift, and go to state 18
    CONS_INTEGER     shift, and go to state 65
    CONS_FLOAT       shift, and go to state 66
    CONS_SCIENTIFIC  shift, and go to state 67
    CONS_STRING      shift, and go to state 68
    CONS_BOOL        shift, and go to state 69

    symbol_id         go to state 198
    literal_constant  go to state 71
    var_ref           go to state 72
    expr              go to state 199
    for_single_entry  go to state 257
    funct_invoc_ref   go to state 74


state 253

  108 for_st: FOR for_init for_control for_incre R_PAREN compound_st .

    $default  reduce using rule 108 (for_st)


state 254

   85 while_st: DO compound_st WHILE L_PAREN bool_expr R_PAREN SEMICOLON .

    $default  reduce using rule 85 (while_st)


state 255

   82 condition_st: IF L_PAREN bool_expr R_PAREN compound_st ELSE compound_st .

    $default  reduce using rule 82 (condition_st)


state 256

  123 for_control_entry: symbol_id array_indice ASSIGN init_array .

    $default  reduce using rule 123 (for_control_entry)


state 257

  115 nonEmpty_for_incre: nonEmpty_for_incre COMMA for_single_entry .

    $default  reduce using rule 115 (nonEmpty_for_incre)
