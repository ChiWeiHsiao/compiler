State 12 conflicts: 8 shift/reduce
State 14 conflicts: 8 shift/reduce
State 15 conflicts: 8 shift/reduce
State 16 conflicts: 8 shift/reduce
State 17 conflicts: 8 shift/reduce
State 18 conflicts: 7 shift/reduce
State 26 conflicts: 8 shift/reduce
State 35 conflicts: 8 shift/reduce
State 97 conflicts: 13 shift/reduce
State 181 conflicts: 1 shift/reduce
State 189 conflicts: 19 reduce/reduce
State 190 conflicts: 19 reduce/reduce
State 193 conflicts: 19 reduce/reduce
State 235 conflicts: 1 shift/reduce
State 238 conflicts: 3 reduce/reduce


Grammar

    0 $accept: program $end

    1 program: decl_and_def_list

    2 decl_and_def_list: decl_and_def_list declaration_list
    3                  | declaration_list decl_and_def_list
    4                  | definition_list
    5                  | definition_list decl_and_def_list

    6 declaration_list: const_decl declaration_list
    7                 | var_decl declaration_list
    8                 | funct_decl declaration_list
    9                 | proc_decl declaration_list
   10                 | const_decl
   11                 | var_decl
   12                 | funct_decl
   13                 | proc_decl

   14 var_decl: type var_list SEMICOLON

   15 type: INT
   16     | DOUBLE
   17     | FLOAT
   18     | STRING
   19     | BOOL
   20     | BOOLEAN

   21 identifier: symbol_id
   22           | symbol_id array_indice

   23 symbol_id: ID

   24 array_indice: array_indice L_BRACKET CONS_INTEGER R_BRACKET
   25             | L_BRACKET CONS_INTEGER R_BRACKET

   26 var_list: var_list COMMA var_single
   27         | var_single

   28 var_single: identifier
   29           | symbol_id ASSIGN expr
   30           | symbol_id array_indice ASSIGN init_array

   31 init_array: init_arr_list R_BRACE

   32 init_arr_list: L_BRACE nonEmpty_init_arr_list
   33              | L_BRACE

   34 nonEmpty_init_arr_list: nonEmpty_init_arr_list COMMA expr
   35                       | expr

   36 const_decl: CONST type const_list SEMICOLON

   37 const_list: const_init COMMA const_list
   38           | const_init

   39 const_init: symbol_id ASSIGN literal_constant

   40 literal_constant: CONS_INTEGER
   41                 | CONS_FLOAT
   42                 | CONS_SCIENTIFIC
   43                 | CONS_STRING
   44                 | CONS_BOOL

   45 funct_decl: type symbol_id arg_list R_PAREN SEMICOLON

   46 proc_decl: VOID symbol_id arg_list R_PAREN SEMICOLON

   47 definition_list: definition definition_list
   48                | definition

   49 definition: type symbol_id arg_list R_PAREN compound_st
   50           | VOID symbol_id arg_list R_PAREN compound_st

   51 arg_list: L_PAREN nonEmpty_arg_list
   52         | L_PAREN

   53 nonEmpty_arg_list: arg COMMA nonEmpty_arg_list
   54                  | arg

   55 arg: type identifier

   56 compound_st: compound_list R_BRACE

   57 compound_list: L_BRACE nonEmpty_compound_list
   58              | L_BRACE

   59 nonEmpty_compound_list: var_const_decl_list nonEmpty_compound_list
   60                       | stat_list nonEmpty_compound_list
   61                       | var_const_decl_list
   62                       | stat_list

   63 var_const_decl_list: var_const_decl_list var_decl
   64                    | var_const_decl_list const_decl
   65                    | var_decl
   66                    | const_decl

   67 stat_list: stat_list statement
   68          | statement

   69 statement: compound_st
   70          | simple_st
   71          | condition_st
   72          | while_st
   73          | for_st
   74          | jump_st
   75          | funct_invoc_st

   76 simple_st: var_ref ASSIGN expr SEMICOLON
   77          | PRINT var_ref SEMICOLON
   78          | PRINT expr SEMICOLON
   79          | READ var_ref SEMICOLON

   80 var_ref: symbol_id
   81        | symbol_id arr_ref_indice

   82 arr_ref_indice: arr_ref_index arr_ref_indice
   83               | arr_ref_index

   84 arr_ref_index: L_BRACKET expr R_BRACKET

   85 condition_st: IF L_PAREN bool_expr R_PAREN compound_st
   86             | IF L_PAREN bool_expr R_PAREN compound_st ELSE compound_st

   87 bool_expr: expr

   88 while_st: WHILE L_PAREN bool_expr R_PAREN compound_st
   89         | DO compound_st WHILE L_PAREN bool_expr R_PAREN SEMICOLON

   90 jump_st: RETURN expr SEMICOLON
   91        | BREAK SEMICOLON
   92        | CONTINUE SEMICOLON

   93 expr: L_PAREN expr R_PAREN
   94     | expr OR expr
   95     | expr AND expr
   96     | NOT expr
   97     | expr LESS expr
   98     | expr LESS_EQ expr
   99     | expr EQUAL expr
  100     | expr GREAT_EQ expr
  101     | expr GREAT expr
  102     | expr NOT_EQ expr
  103     | expr PLUS expr
  104     | expr MINUS expr
  105     | expr MULTIPLY expr
  106     | expr DIVIDE expr
  107     | expr MOD expr
  108     | MINUS expr
  109     | literal_constant
  110     | var_ref
  111     | funct_invoc_ref

  112 for_st: FOR for_init for_control for_incre R_PAREN compound_st

  113 for_init: L_PAREN nonEmpty_for_init
  114         | L_PAREN

  115 nonEmpty_for_init: nonEmpty_for_init COMMA for_single_entry
  116                  | for_single_entry

  117 for_incre: SEMICOLON nonEmpty_for_incre
  118          | SEMICOLON

  119 nonEmpty_for_incre: nonEmpty_for_incre COMMA for_single_entry
  120                   | for_single_entry

  121 for_control: SEMICOLON nonEmpty_for_control
  122            | SEMICOLON

  123 nonEmpty_for_control: nonEmpty_for_control COMMA for_control_entry
  124                     | for_control_entry

  125 for_control_entry: expr
  126                  | symbol_id ASSIGN expr
  127                  | symbol_id array_indice ASSIGN init_array

  128 for_single_entry: symbol_id ASSIGN expr
  129                 | symbol_id array_indice ASSIGN init_array
  130                 | expr
  131                 | symbol_id funct_invoc_list R_PAREN

  132 funct_invoc_ref: symbol_id funct_invoc_list R_PAREN

  133 funct_invoc_st: symbol_id funct_invoc_list R_PAREN SEMICOLON

  134 funct_invoc_list: L_PAREN
  135                 | L_PAREN nonEmpty_funct_invoc_list

  136 nonEmpty_funct_invoc_list: nonEmpty_funct_invoc_list COMMA expr
  137                          | expr


Terminals, with rules where they appear

$end (0) 0
error (256)
VOID (258) 46 50
CONST (259) 36
STRING (260) 18
DOUBLE (261) 16
FLOAT (262) 17
BOOL (263) 19
INT (264) 15
BOOLEAN (265) 20
L_PAREN (266) 51 52 85 86 88 89 93 113 114 134 135
R_PAREN (267) 45 46 49 50 85 86 88 89 93 112 131 132 133
L_BRACKET (268) 24 25 84
R_BRACKET (269) 24 25 84
L_BRACE (270) 32 33 57 58
R_BRACE (271) 31 56
OR (272) 94
AND (273) 95
NOT (274) 96
NOT_EQ (275) 102
GREAT (276) 101
GREAT_EQ (277) 100
EQUAL (278) 99
LESS_EQ (279) 98
LESS (280) 97
MINUS (281) 104 108
PLUS (282) 103
MOD (283) 107
DIVIDE (284) 106
MULTIPLY (285) 105
ASSIGN (286) 29 30 39 76 126 127 128 129
WHILE (287) 88 89
DO (288) 89
IF (289) 85 86
ELSE (290) 86
FOR (291) 112
PRINT (292) 77 78
READ (293) 79
CONTINUE (294) 92
BREAK (295) 91
RETURN (296) 90
ID (297) 23
SEMICOLON (298) 14 36 45 46 76 77 78 79 89 90 91 92 117 118 121 122
    133
COMMA (299) 26 34 37 53 115 119 123 136
CONS_INTEGER (300) 24 25 40
CONS_FLOAT (301) 41
CONS_SCIENTIFIC (302) 42
CONS_STRING (303) 43
CONS_BOOL (304) 44


Nonterminals, with rules where they appear

$accept (50)
    on left: 0
program (51)
    on left: 1, on right: 0
decl_and_def_list (52)
    on left: 2 3 4 5, on right: 1 2 3 5
declaration_list (53)
    on left: 6 7 8 9 10 11 12 13, on right: 2 3 6 7 8 9
var_decl (54)
    on left: 14, on right: 7 11 63 65
type (55)
    on left: 15 16 17 18 19 20, on right: 14 36 45 49 55
identifier (56)
    on left: 21 22, on right: 28 55
symbol_id (57)
    on left: 23, on right: 21 22 29 30 39 45 46 49 50 80 81 126 127
    128 129 131 132 133
array_indice (58)
    on left: 24 25, on right: 22 24 30 127 129
var_list (59)
    on left: 26 27, on right: 14 26
var_single (60)
    on left: 28 29 30, on right: 26 27
init_array (61)
    on left: 31, on right: 30 127 129
init_arr_list (62)
    on left: 32 33, on right: 31
nonEmpty_init_arr_list (63)
    on left: 34 35, on right: 32 34
const_decl (64)
    on left: 36, on right: 6 10 64 66
const_list (65)
    on left: 37 38, on right: 36 37
const_init (66)
    on left: 39, on right: 37 38
literal_constant (67)
    on left: 40 41 42 43 44, on right: 39 109
funct_decl (68)
    on left: 45, on right: 8 12
proc_decl (69)
    on left: 46, on right: 9 13
definition_list (70)
    on left: 47 48, on right: 4 5 47
definition (71)
    on left: 49 50, on right: 47 48
arg_list (72)
    on left: 51 52, on right: 45 46 49 50
nonEmpty_arg_list (73)
    on left: 53 54, on right: 51 53
arg (74)
    on left: 55, on right: 53 54
compound_st (75)
    on left: 56, on right: 49 50 69 85 86 88 89 112
compound_list (76)
    on left: 57 58, on right: 56
nonEmpty_compound_list (77)
    on left: 59 60 61 62, on right: 57 59 60
var_const_decl_list (78)
    on left: 63 64 65 66, on right: 59 61 63 64
stat_list (79)
    on left: 67 68, on right: 60 62 67
statement (80)
    on left: 69 70 71 72 73 74 75, on right: 67 68
simple_st (81)
    on left: 76 77 78 79, on right: 70
var_ref (82)
    on left: 80 81, on right: 76 77 79 110
arr_ref_indice (83)
    on left: 82 83, on right: 81 82
arr_ref_index (84)
    on left: 84, on right: 82 83
condition_st (85)
    on left: 85 86, on right: 71
bool_expr (86)
    on left: 87, on right: 85 86 88 89
while_st (87)
    on left: 88 89, on right: 72
jump_st (88)
    on left: 90 91 92, on right: 74
expr (89)
    on left: 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108
    109 110 111, on right: 29 34 35 76 78 84 87 90 93 94 95 96 97 98
    99 100 101 102 103 104 105 106 107 108 125 126 128 130 136 137
for_st (90)
    on left: 112, on right: 73
for_init (91)
    on left: 113 114, on right: 112
nonEmpty_for_init (92)
    on left: 115 116, on right: 113 115
for_incre (93)
    on left: 117 118, on right: 112
nonEmpty_for_incre (94)
    on left: 119 120, on right: 117 119
for_control (95)
    on left: 121 122, on right: 112
nonEmpty_for_control (96)
    on left: 123 124, on right: 121 123
for_control_entry (97)
    on left: 125 126 127, on right: 123 124
for_single_entry (98)
    on left: 128 129 130 131, on right: 115 116 119 120
funct_invoc_ref (99)
    on left: 132, on right: 111
funct_invoc_st (100)
    on left: 133, on right: 75
funct_invoc_list (101)
    on left: 134 135, on right: 131 132 133
nonEmpty_funct_invoc_list (102)
    on left: 136 137, on right: 135 136


state 0

    0 $accept: . program $end

    VOID     shift, and go to state 1
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    program            go to state 9
    decl_and_def_list  go to state 10
    declaration_list   go to state 11
    var_decl           go to state 12
    type               go to state 13
    const_decl         go to state 14
    funct_decl         go to state 15
    proc_decl          go to state 16
    definition_list    go to state 17
    definition         go to state 18


state 1

   46 proc_decl: VOID . symbol_id arg_list R_PAREN SEMICOLON
   50 definition: VOID . symbol_id arg_list R_PAREN compound_st

    ID  shift, and go to state 19

    symbol_id  go to state 20


state 2

   36 const_decl: CONST . type const_list SEMICOLON

    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    type  go to state 21


state 3

   18 type: STRING .

    $default  reduce using rule 18 (type)


state 4

   16 type: DOUBLE .

    $default  reduce using rule 16 (type)


state 5

   17 type: FLOAT .

    $default  reduce using rule 17 (type)


state 6

   19 type: BOOL .

    $default  reduce using rule 19 (type)


state 7

   15 type: INT .

    $default  reduce using rule 15 (type)


state 8

   20 type: BOOLEAN .

    $default  reduce using rule 20 (type)


state 9

    0 $accept: program . $end

    $end  shift, and go to state 22


state 10

    1 program: decl_and_def_list .
    2 decl_and_def_list: decl_and_def_list . declaration_list

    VOID     shift, and go to state 23
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    $default  reduce using rule 1 (program)

    declaration_list  go to state 24
    var_decl          go to state 12
    type              go to state 25
    const_decl        go to state 14
    funct_decl        go to state 15
    proc_decl         go to state 16


state 11

    3 decl_and_def_list: declaration_list . decl_and_def_list

    VOID     shift, and go to state 1
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    decl_and_def_list  go to state 26
    declaration_list   go to state 11
    var_decl           go to state 12
    type               go to state 13
    const_decl         go to state 14
    funct_decl         go to state 15
    proc_decl          go to state 16
    definition_list    go to state 17
    definition         go to state 18


state 12

    7 declaration_list: var_decl . declaration_list
   11                 | var_decl .

    VOID     shift, and go to state 23
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    VOID      [reduce using rule 11 (declaration_list)]
    CONST     [reduce using rule 11 (declaration_list)]
    STRING    [reduce using rule 11 (declaration_list)]
    DOUBLE    [reduce using rule 11 (declaration_list)]
    FLOAT     [reduce using rule 11 (declaration_list)]
    BOOL      [reduce using rule 11 (declaration_list)]
    INT       [reduce using rule 11 (declaration_list)]
    BOOLEAN   [reduce using rule 11 (declaration_list)]
    $default  reduce using rule 11 (declaration_list)

    declaration_list  go to state 27
    var_decl          go to state 12
    type              go to state 25
    const_decl        go to state 14
    funct_decl        go to state 15
    proc_decl         go to state 16


state 13

   14 var_decl: type . var_list SEMICOLON
   45 funct_decl: type . symbol_id arg_list R_PAREN SEMICOLON
   49 definition: type . symbol_id arg_list R_PAREN compound_st

    ID  shift, and go to state 19

    identifier  go to state 28
    symbol_id   go to state 29
    var_list    go to state 30
    var_single  go to state 31


state 14

    6 declaration_list: const_decl . declaration_list
   10                 | const_decl .

    VOID     shift, and go to state 23
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    VOID      [reduce using rule 10 (declaration_list)]
    CONST     [reduce using rule 10 (declaration_list)]
    STRING    [reduce using rule 10 (declaration_list)]
    DOUBLE    [reduce using rule 10 (declaration_list)]
    FLOAT     [reduce using rule 10 (declaration_list)]
    BOOL      [reduce using rule 10 (declaration_list)]
    INT       [reduce using rule 10 (declaration_list)]
    BOOLEAN   [reduce using rule 10 (declaration_list)]
    $default  reduce using rule 10 (declaration_list)

    declaration_list  go to state 32
    var_decl          go to state 12
    type              go to state 25
    const_decl        go to state 14
    funct_decl        go to state 15
    proc_decl         go to state 16


state 15

    8 declaration_list: funct_decl . declaration_list
   12                 | funct_decl .

    VOID     shift, and go to state 23
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    VOID      [reduce using rule 12 (declaration_list)]
    CONST     [reduce using rule 12 (declaration_list)]
    STRING    [reduce using rule 12 (declaration_list)]
    DOUBLE    [reduce using rule 12 (declaration_list)]
    FLOAT     [reduce using rule 12 (declaration_list)]
    BOOL      [reduce using rule 12 (declaration_list)]
    INT       [reduce using rule 12 (declaration_list)]
    BOOLEAN   [reduce using rule 12 (declaration_list)]
    $default  reduce using rule 12 (declaration_list)

    declaration_list  go to state 33
    var_decl          go to state 12
    type              go to state 25
    const_decl        go to state 14
    funct_decl        go to state 15
    proc_decl         go to state 16


state 16

    9 declaration_list: proc_decl . declaration_list
   13                 | proc_decl .

    VOID     shift, and go to state 23
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    VOID      [reduce using rule 13 (declaration_list)]
    CONST     [reduce using rule 13 (declaration_list)]
    STRING    [reduce using rule 13 (declaration_list)]
    DOUBLE    [reduce using rule 13 (declaration_list)]
    FLOAT     [reduce using rule 13 (declaration_list)]
    BOOL      [reduce using rule 13 (declaration_list)]
    INT       [reduce using rule 13 (declaration_list)]
    BOOLEAN   [reduce using rule 13 (declaration_list)]
    $default  reduce using rule 13 (declaration_list)

    declaration_list  go to state 34
    var_decl          go to state 12
    type              go to state 25
    const_decl        go to state 14
    funct_decl        go to state 15
    proc_decl         go to state 16


state 17

    4 decl_and_def_list: definition_list .
    5                  | definition_list . decl_and_def_list

    VOID     shift, and go to state 1
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    VOID      [reduce using rule 4 (decl_and_def_list)]
    CONST     [reduce using rule 4 (decl_and_def_list)]
    STRING    [reduce using rule 4 (decl_and_def_list)]
    DOUBLE    [reduce using rule 4 (decl_and_def_list)]
    FLOAT     [reduce using rule 4 (decl_and_def_list)]
    BOOL      [reduce using rule 4 (decl_and_def_list)]
    INT       [reduce using rule 4 (decl_and_def_list)]
    BOOLEAN   [reduce using rule 4 (decl_and_def_list)]
    $default  reduce using rule 4 (decl_and_def_list)

    decl_and_def_list  go to state 35
    declaration_list   go to state 11
    var_decl           go to state 12
    type               go to state 13
    const_decl         go to state 14
    funct_decl         go to state 15
    proc_decl          go to state 16
    definition_list    go to state 17
    definition         go to state 18


state 18

   47 definition_list: definition . definition_list
   48                | definition .

    VOID     shift, and go to state 36
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    VOID      [reduce using rule 48 (definition_list)]
    STRING    [reduce using rule 48 (definition_list)]
    DOUBLE    [reduce using rule 48 (definition_list)]
    FLOAT     [reduce using rule 48 (definition_list)]
    BOOL      [reduce using rule 48 (definition_list)]
    INT       [reduce using rule 48 (definition_list)]
    BOOLEAN   [reduce using rule 48 (definition_list)]
    $default  reduce using rule 48 (definition_list)

    type             go to state 37
    definition_list  go to state 38
    definition       go to state 18


state 19

   23 symbol_id: ID .

    $default  reduce using rule 23 (symbol_id)


state 20

   46 proc_decl: VOID symbol_id . arg_list R_PAREN SEMICOLON
   50 definition: VOID symbol_id . arg_list R_PAREN compound_st

    L_PAREN  shift, and go to state 39

    arg_list  go to state 40


state 21

   36 const_decl: CONST type . const_list SEMICOLON

    ID  shift, and go to state 19

    symbol_id   go to state 41
    const_list  go to state 42
    const_init  go to state 43


state 22

    0 $accept: program $end .

    $default  accept


state 23

   46 proc_decl: VOID . symbol_id arg_list R_PAREN SEMICOLON

    ID  shift, and go to state 19

    symbol_id  go to state 44


state 24

    2 decl_and_def_list: decl_and_def_list declaration_list .

    $default  reduce using rule 2 (decl_and_def_list)


state 25

   14 var_decl: type . var_list SEMICOLON
   45 funct_decl: type . symbol_id arg_list R_PAREN SEMICOLON

    ID  shift, and go to state 19

    identifier  go to state 28
    symbol_id   go to state 45
    var_list    go to state 30
    var_single  go to state 31


state 26

    2 decl_and_def_list: decl_and_def_list . declaration_list
    3                  | declaration_list decl_and_def_list .

    VOID     shift, and go to state 23
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    VOID      [reduce using rule 3 (decl_and_def_list)]
    CONST     [reduce using rule 3 (decl_and_def_list)]
    STRING    [reduce using rule 3 (decl_and_def_list)]
    DOUBLE    [reduce using rule 3 (decl_and_def_list)]
    FLOAT     [reduce using rule 3 (decl_and_def_list)]
    BOOL      [reduce using rule 3 (decl_and_def_list)]
    INT       [reduce using rule 3 (decl_and_def_list)]
    BOOLEAN   [reduce using rule 3 (decl_and_def_list)]
    $default  reduce using rule 3 (decl_and_def_list)

    declaration_list  go to state 24
    var_decl          go to state 12
    type              go to state 25
    const_decl        go to state 14
    funct_decl        go to state 15
    proc_decl         go to state 16


state 27

    7 declaration_list: var_decl declaration_list .

    $default  reduce using rule 7 (declaration_list)


state 28

   28 var_single: identifier .

    $default  reduce using rule 28 (var_single)


state 29

   21 identifier: symbol_id .
   22           | symbol_id . array_indice
   29 var_single: symbol_id . ASSIGN expr
   30           | symbol_id . array_indice ASSIGN init_array
   45 funct_decl: type symbol_id . arg_list R_PAREN SEMICOLON
   49 definition: type symbol_id . arg_list R_PAREN compound_st

    L_PAREN    shift, and go to state 39
    L_BRACKET  shift, and go to state 46
    ASSIGN     shift, and go to state 47

    $default  reduce using rule 21 (identifier)

    array_indice  go to state 48
    arg_list      go to state 49


state 30

   14 var_decl: type var_list . SEMICOLON
   26 var_list: var_list . COMMA var_single

    SEMICOLON  shift, and go to state 50
    COMMA      shift, and go to state 51


state 31

   27 var_list: var_single .

    $default  reduce using rule 27 (var_list)


state 32

    6 declaration_list: const_decl declaration_list .

    $default  reduce using rule 6 (declaration_list)


state 33

    8 declaration_list: funct_decl declaration_list .

    $default  reduce using rule 8 (declaration_list)


state 34

    9 declaration_list: proc_decl declaration_list .

    $default  reduce using rule 9 (declaration_list)


state 35

    2 decl_and_def_list: decl_and_def_list . declaration_list
    5                  | definition_list decl_and_def_list .

    VOID     shift, and go to state 23
    CONST    shift, and go to state 2
    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    VOID      [reduce using rule 5 (decl_and_def_list)]
    CONST     [reduce using rule 5 (decl_and_def_list)]
    STRING    [reduce using rule 5 (decl_and_def_list)]
    DOUBLE    [reduce using rule 5 (decl_and_def_list)]
    FLOAT     [reduce using rule 5 (decl_and_def_list)]
    BOOL      [reduce using rule 5 (decl_and_def_list)]
    INT       [reduce using rule 5 (decl_and_def_list)]
    BOOLEAN   [reduce using rule 5 (decl_and_def_list)]
    $default  reduce using rule 5 (decl_and_def_list)

    declaration_list  go to state 24
    var_decl          go to state 12
    type              go to state 25
    const_decl        go to state 14
    funct_decl        go to state 15
    proc_decl         go to state 16


state 36

   50 definition: VOID . symbol_id arg_list R_PAREN compound_st

    ID  shift, and go to state 19

    symbol_id  go to state 52


state 37

   49 definition: type . symbol_id arg_list R_PAREN compound_st

    ID  shift, and go to state 19

    symbol_id  go to state 53


state 38

   47 definition_list: definition definition_list .

    $default  reduce using rule 47 (definition_list)


state 39

   51 arg_list: L_PAREN . nonEmpty_arg_list
   52         | L_PAREN .

    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    $default  reduce using rule 52 (arg_list)

    type               go to state 54
    nonEmpty_arg_list  go to state 55
    arg                go to state 56


state 40

   46 proc_decl: VOID symbol_id arg_list . R_PAREN SEMICOLON
   50 definition: VOID symbol_id arg_list . R_PAREN compound_st

    R_PAREN  shift, and go to state 57


state 41

   39 const_init: symbol_id . ASSIGN literal_constant

    ASSIGN  shift, and go to state 58


state 42

   36 const_decl: CONST type const_list . SEMICOLON

    SEMICOLON  shift, and go to state 59


state 43

   37 const_list: const_init . COMMA const_list
   38           | const_init .

    COMMA  shift, and go to state 60

    $default  reduce using rule 38 (const_list)


state 44

   46 proc_decl: VOID symbol_id . arg_list R_PAREN SEMICOLON

    L_PAREN  shift, and go to state 39

    arg_list  go to state 61


state 45

   21 identifier: symbol_id .
   22           | symbol_id . array_indice
   29 var_single: symbol_id . ASSIGN expr
   30           | symbol_id . array_indice ASSIGN init_array
   45 funct_decl: type symbol_id . arg_list R_PAREN SEMICOLON

    L_PAREN    shift, and go to state 39
    L_BRACKET  shift, and go to state 46
    ASSIGN     shift, and go to state 47

    $default  reduce using rule 21 (identifier)

    array_indice  go to state 48
    arg_list      go to state 62


state 46

   25 array_indice: L_BRACKET . CONS_INTEGER R_BRACKET

    CONS_INTEGER  shift, and go to state 63


state 47

   29 var_single: symbol_id ASSIGN . expr

    L_PAREN          shift, and go to state 64
    NOT              shift, and go to state 65
    MINUS            shift, and go to state 66
    ID               shift, and go to state 19
    CONS_INTEGER     shift, and go to state 67
    CONS_FLOAT       shift, and go to state 68
    CONS_SCIENTIFIC  shift, and go to state 69
    CONS_STRING      shift, and go to state 70
    CONS_BOOL        shift, and go to state 71

    symbol_id         go to state 72
    literal_constant  go to state 73
    var_ref           go to state 74
    expr              go to state 75
    funct_invoc_ref   go to state 76


state 48

   22 identifier: symbol_id array_indice .
   24 array_indice: array_indice . L_BRACKET CONS_INTEGER R_BRACKET
   30 var_single: symbol_id array_indice . ASSIGN init_array

    L_BRACKET  shift, and go to state 77
    ASSIGN     shift, and go to state 78

    $default  reduce using rule 22 (identifier)


state 49

   45 funct_decl: type symbol_id arg_list . R_PAREN SEMICOLON
   49 definition: type symbol_id arg_list . R_PAREN compound_st

    R_PAREN  shift, and go to state 79


state 50

   14 var_decl: type var_list SEMICOLON .

    $default  reduce using rule 14 (var_decl)


state 51

   26 var_list: var_list COMMA . var_single

    ID  shift, and go to state 19

    identifier  go to state 28
    symbol_id   go to state 80
    var_single  go to state 81


state 52

   50 definition: VOID symbol_id . arg_list R_PAREN compound_st

    L_PAREN  shift, and go to state 39

    arg_list  go to state 82


state 53

   49 definition: type symbol_id . arg_list R_PAREN compound_st

    L_PAREN  shift, and go to state 39

    arg_list  go to state 83


state 54

   55 arg: type . identifier

    ID  shift, and go to state 19

    identifier  go to state 84
    symbol_id   go to state 85


state 55

   51 arg_list: L_PAREN nonEmpty_arg_list .

    $default  reduce using rule 51 (arg_list)


state 56

   53 nonEmpty_arg_list: arg . COMMA nonEmpty_arg_list
   54                  | arg .

    COMMA  shift, and go to state 86

    $default  reduce using rule 54 (nonEmpty_arg_list)


state 57

   46 proc_decl: VOID symbol_id arg_list R_PAREN . SEMICOLON
   50 definition: VOID symbol_id arg_list R_PAREN . compound_st

    L_BRACE    shift, and go to state 87
    SEMICOLON  shift, and go to state 88

    compound_st    go to state 89
    compound_list  go to state 90


state 58

   39 const_init: symbol_id ASSIGN . literal_constant

    CONS_INTEGER     shift, and go to state 67
    CONS_FLOAT       shift, and go to state 68
    CONS_SCIENTIFIC  shift, and go to state 69
    CONS_STRING      shift, and go to state 70
    CONS_BOOL        shift, and go to state 71

    literal_constant  go to state 91


state 59

   36 const_decl: CONST type const_list SEMICOLON .

    $default  reduce using rule 36 (const_decl)


state 60

   37 const_list: const_init COMMA . const_list

    ID  shift, and go to state 19

    symbol_id   go to state 41
    const_list  go to state 92
    const_init  go to state 43


state 61

   46 proc_decl: VOID symbol_id arg_list . R_PAREN SEMICOLON

    R_PAREN  shift, and go to state 93


state 62

   45 funct_decl: type symbol_id arg_list . R_PAREN SEMICOLON

    R_PAREN  shift, and go to state 94


state 63

   25 array_indice: L_BRACKET CONS_INTEGER . R_BRACKET

    R_BRACKET  shift, and go to state 95


state 64

   93 expr: L_PAREN . expr R_PAREN

    L_PAREN          shift, and go to state 64
    NOT              shift, and go to state 65
    MINUS            shift, and go to state 66
    ID               shift, and go to state 19
    CONS_INTEGER     shift, and go to state 67
    CONS_FLOAT       shift, and go to state 68
    CONS_SCIENTIFIC  shift, and go to state 69
    CONS_STRING      shift, and go to state 70
    CONS_BOOL        shift, and go to state 71

    symbol_id         go to state 72
    literal_constant  go to state 73
    var_ref           go to state 74
    expr              go to state 96
    funct_invoc_ref   go to state 76


state 65

   96 expr: NOT . expr

    L_PAREN          shift, and go to state 64
    NOT              shift, and go to state 65
    MINUS            shift, and go to state 66
    ID               shift, and go to state 19
    CONS_INTEGER     shift, and go to state 67
    CONS_FLOAT       shift, and go to state 68
    CONS_SCIENTIFIC  shift, and go to state 69
    CONS_STRING      shift, and go to state 70
    CONS_BOOL        shift, and go to state 71

    symbol_id         go to state 72
    literal_constant  go to state 73
    var_ref           go to state 74
    expr              go to state 97
    funct_invoc_ref   go to state 76


state 66

  108 expr: MINUS . expr

    L_PAREN          shift, and go to state 64
    NOT              shift, and go to state 65
    MINUS            shift, and go to state 66
    ID               shift, and go to state 19
    CONS_INTEGER     shift, and go to state 67
    CONS_FLOAT       shift, and go to state 68
    CONS_SCIENTIFIC  shift, and go to state 69
    CONS_STRING      shift, and go to state 70
    CONS_BOOL        shift, and go to state 71

    symbol_id         go to state 72
    literal_constant  go to state 73
    var_ref           go to state 74
    expr              go to state 98
    funct_invoc_ref   go to state 76


state 67

   40 literal_constant: CONS_INTEGER .

    $default  reduce using rule 40 (literal_constant)


state 68

   41 literal_constant: CONS_FLOAT .

    $default  reduce using rule 41 (literal_constant)


state 69

   42 literal_constant: CONS_SCIENTIFIC .

    $default  reduce using rule 42 (literal_constant)


state 70

   43 literal_constant: CONS_STRING .

    $default  reduce using rule 43 (literal_constant)


state 71

   44 literal_constant: CONS_BOOL .

    $default  reduce using rule 44 (literal_constant)


state 72

   80 var_ref: symbol_id .
   81        | symbol_id . arr_ref_indice
  132 funct_invoc_ref: symbol_id . funct_invoc_list R_PAREN

    L_PAREN    shift, and go to state 99
    L_BRACKET  shift, and go to state 100

    $default  reduce using rule 80 (var_ref)

    arr_ref_indice    go to state 101
    arr_ref_index     go to state 102
    funct_invoc_list  go to state 103


state 73

  109 expr: literal_constant .

    $default  reduce using rule 109 (expr)


state 74

  110 expr: var_ref .

    $default  reduce using rule 110 (expr)


state 75

   29 var_single: symbol_id ASSIGN expr .
   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    OR        shift, and go to state 104
    AND       shift, and go to state 105
    NOT_EQ    shift, and go to state 106
    GREAT     shift, and go to state 107
    GREAT_EQ  shift, and go to state 108
    EQUAL     shift, and go to state 109
    LESS_EQ   shift, and go to state 110
    LESS      shift, and go to state 111
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    $default  reduce using rule 29 (var_single)


state 76

  111 expr: funct_invoc_ref .

    $default  reduce using rule 111 (expr)


state 77

   24 array_indice: array_indice L_BRACKET . CONS_INTEGER R_BRACKET

    CONS_INTEGER  shift, and go to state 117


state 78

   30 var_single: symbol_id array_indice ASSIGN . init_array

    L_BRACE  shift, and go to state 118

    init_array     go to state 119
    init_arr_list  go to state 120


state 79

   45 funct_decl: type symbol_id arg_list R_PAREN . SEMICOLON
   49 definition: type symbol_id arg_list R_PAREN . compound_st

    L_BRACE    shift, and go to state 87
    SEMICOLON  shift, and go to state 121

    compound_st    go to state 122
    compound_list  go to state 90


state 80

   21 identifier: symbol_id .
   22           | symbol_id . array_indice
   29 var_single: symbol_id . ASSIGN expr
   30           | symbol_id . array_indice ASSIGN init_array

    L_BRACKET  shift, and go to state 46
    ASSIGN     shift, and go to state 47

    $default  reduce using rule 21 (identifier)

    array_indice  go to state 48


state 81

   26 var_list: var_list COMMA var_single .

    $default  reduce using rule 26 (var_list)


state 82

   50 definition: VOID symbol_id arg_list . R_PAREN compound_st

    R_PAREN  shift, and go to state 123


state 83

   49 definition: type symbol_id arg_list . R_PAREN compound_st

    R_PAREN  shift, and go to state 124


state 84

   55 arg: type identifier .

    $default  reduce using rule 55 (arg)


state 85

   21 identifier: symbol_id .
   22           | symbol_id . array_indice

    L_BRACKET  shift, and go to state 46

    $default  reduce using rule 21 (identifier)

    array_indice  go to state 125


state 86

   53 nonEmpty_arg_list: arg COMMA . nonEmpty_arg_list

    STRING   shift, and go to state 3
    DOUBLE   shift, and go to state 4
    FLOAT    shift, and go to state 5
    BOOL     shift, and go to state 6
    INT      shift, and go to state 7
    BOOLEAN  shift, and go to state 8

    type               go to state 54
    nonEmpty_arg_list  go to state 126
    arg                go to state 56


state 87

   57 compound_list: L_BRACE . nonEmpty_compound_list
   58              | L_BRACE .

    CONST     shift, and go to state 2
    STRING    shift, and go to state 3
    DOUBLE    shift, and go to state 4
    FLOAT     shift, and go to state 5
    BOOL      shift, and go to state 6
    INT       shift, and go to state 7
    BOOLEAN   shift, and go to state 8
    L_BRACE   shift, and go to state 87
    WHILE     shift, and go to state 127
    DO        shift, and go to state 128
    IF        shift, and go to state 129
    FOR       shift, and go to state 130
    PRINT     shift, and go to state 131
    READ      shift, and go to state 132
    CONTINUE  shift, and go to state 133
    BREAK     shift, and go to state 134
    RETURN    shift, and go to state 135
    ID        shift, and go to state 19

    $default  reduce using rule 58 (compound_list)

    var_decl                go to state 136
    type                    go to state 137
    symbol_id               go to state 138
    const_decl              go to state 139
    compound_st             go to state 140
    compound_list           go to state 90
    nonEmpty_compound_list  go to state 141
    var_const_decl_list     go to state 142
    stat_list               go to state 143
    statement               go to state 144
    simple_st               go to state 145
    var_ref                 go to state 146
    condition_st            go to state 147
    while_st                go to state 148
    jump_st                 go to state 149
    for_st                  go to state 150
    funct_invoc_st          go to state 151


state 88

   46 proc_decl: VOID symbol_id arg_list R_PAREN SEMICOLON .

    $default  reduce using rule 46 (proc_decl)


state 89

   50 definition: VOID symbol_id arg_list R_PAREN compound_st .

    $default  reduce using rule 50 (definition)


state 90

   56 compound_st: compound_list . R_BRACE

    R_BRACE  shift, and go to state 152


state 91

   39 const_init: symbol_id ASSIGN literal_constant .

    $default  reduce using rule 39 (const_init)


state 92

   37 const_list: const_init COMMA const_list .

    $default  reduce using rule 37 (const_list)


state 93

   46 proc_decl: VOID symbol_id arg_list R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 88


state 94

   45 funct_decl: type symbol_id arg_list R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 121


state 95

   25 array_indice: L_BRACKET CONS_INTEGER R_BRACKET .

    $default  reduce using rule 25 (array_indice)


state 96

   93 expr: L_PAREN expr . R_PAREN
   94     | expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    R_PAREN   shift, and go to state 153
    OR        shift, and go to state 104
    AND       shift, and go to state 105
    NOT_EQ    shift, and go to state 106
    GREAT     shift, and go to state 107
    GREAT_EQ  shift, and go to state 108
    EQUAL     shift, and go to state 109
    LESS_EQ   shift, and go to state 110
    LESS      shift, and go to state 111
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116


state 97

   94 expr: expr . OR expr
   95     | expr . AND expr
   96     | NOT expr .
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    OR        shift, and go to state 104
    AND       shift, and go to state 105
    NOT_EQ    shift, and go to state 106
    GREAT     shift, and go to state 107
    GREAT_EQ  shift, and go to state 108
    EQUAL     shift, and go to state 109
    LESS_EQ   shift, and go to state 110
    LESS      shift, and go to state 111
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    OR        [reduce using rule 96 (expr)]
    AND       [reduce using rule 96 (expr)]
    NOT_EQ    [reduce using rule 96 (expr)]
    GREAT     [reduce using rule 96 (expr)]
    GREAT_EQ  [reduce using rule 96 (expr)]
    EQUAL     [reduce using rule 96 (expr)]
    LESS_EQ   [reduce using rule 96 (expr)]
    LESS      [reduce using rule 96 (expr)]
    MINUS     [reduce using rule 96 (expr)]
    PLUS      [reduce using rule 96 (expr)]
    MOD       [reduce using rule 96 (expr)]
    DIVIDE    [reduce using rule 96 (expr)]
    MULTIPLY  [reduce using rule 96 (expr)]
    $default  reduce using rule 96 (expr)


state 98

   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr
  108     | MINUS expr .

    $default  reduce using rule 108 (expr)


state 99

  134 funct_invoc_list: L_PAREN .
  135                 | L_PAREN . nonEmpty_funct_invoc_list

    L_PAREN          shift, and go to state 64
    NOT              shift, and go to state 65
    MINUS            shift, and go to state 66
    ID               shift, and go to state 19
    CONS_INTEGER     shift, and go to state 67
    CONS_FLOAT       shift, and go to state 68
    CONS_SCIENTIFIC  shift, and go to state 69
    CONS_STRING      shift, and go to state 70
    CONS_BOOL        shift, and go to state 71

    $default  reduce using rule 134 (funct_invoc_list)

    symbol_id                  go to state 72
    literal_constant           go to state 73
    var_ref                    go to state 74
    expr                       go to state 154
    funct_invoc_ref            go to state 76
    nonEmpty_funct_invoc_list  go to state 155


state 100

   84 arr_ref_index: L_BRACKET . expr R_BRACKET

    L_PAREN          shift, and go to state 64
    NOT              shift, and go to state 65
    MINUS            shift, and go to state 66
    ID               shift, and go to state 19
    CONS_INTEGER     shift, and go to state 67
    CONS_FLOAT       shift, and go to state 68
    CONS_SCIENTIFIC  shift, and go to state 69
    CONS_STRING      shift, and go to state 70
    CONS_BOOL        shift, and go to state 71

    symbol_id         go to state 72
    literal_constant  go to state 73
    var_ref           go to state 74
    expr              go to state 156
    funct_invoc_ref   go to state 76


state 101

   81 var_ref: symbol_id arr_ref_indice .

    $default  reduce using rule 81 (var_ref)


state 102

   82 arr_ref_indice: arr_ref_index . arr_ref_indice
   83               | arr_ref_index .

    L_BRACKET  shift, and go to state 100

    $default  reduce using rule 83 (arr_ref_indice)

    arr_ref_indice  go to state 157
    arr_ref_index   go to state 102


state 103

  132 funct_invoc_ref: symbol_id funct_invoc_list . R_PAREN

    R_PAREN  shift, and go to state 158


state 104

   94 expr: expr OR . expr

    L_PAREN          shift, and go to state 64
    NOT              shift, and go to state 65
    MINUS            shift, and go to state 66
    ID               shift, and go to state 19
    CONS_INTEGER     shift, and go to state 67
    CONS_FLOAT       shift, and go to state 68
    CONS_SCIENTIFIC  shift, and go to state 69
    CONS_STRING      shift, and go to state 70
    CONS_BOOL        shift, and go to state 71

    symbol_id         go to state 72
    literal_constant  go to state 73
    var_ref           go to state 74
    expr              go to state 159
    funct_invoc_ref   go to state 76


state 105

   95 expr: expr AND . expr

    L_PAREN          shift, and go to state 64
    NOT              shift, and go to state 65
    MINUS            shift, and go to state 66
    ID               shift, and go to state 19
    CONS_INTEGER     shift, and go to state 67
    CONS_FLOAT       shift, and go to state 68
    CONS_SCIENTIFIC  shift, and go to state 69
    CONS_STRING      shift, and go to state 70
    CONS_BOOL        shift, and go to state 71

    symbol_id         go to state 72
    literal_constant  go to state 73
    var_ref           go to state 74
    expr              go to state 160
    funct_invoc_ref   go to state 76


state 106

  102 expr: expr NOT_EQ . expr

    L_PAREN          shift, and go to state 64
    NOT              shift, and go to state 65
    MINUS            shift, and go to state 66
    ID               shift, and go to state 19
    CONS_INTEGER     shift, and go to state 67
    CONS_FLOAT       shift, and go to state 68
    CONS_SCIENTIFIC  shift, and go to state 69
    CONS_STRING      shift, and go to state 70
    CONS_BOOL        shift, and go to state 71

    symbol_id         go to state 72
    literal_constant  go to state 73
    var_ref           go to state 74
    expr              go to state 161
    funct_invoc_ref   go to state 76


state 107

  101 expr: expr GREAT . expr

    L_PAREN          shift, and go to state 64
    NOT              shift, and go to state 65
    MINUS            shift, and go to state 66
    ID               shift, and go to state 19
    CONS_INTEGER     shift, and go to state 67
    CONS_FLOAT       shift, and go to state 68
    CONS_SCIENTIFIC  shift, and go to state 69
    CONS_STRING      shift, and go to state 70
    CONS_BOOL        shift, and go to state 71

    symbol_id         go to state 72
    literal_constant  go to state 73
    var_ref           go to state 74
    expr              go to state 162
    funct_invoc_ref   go to state 76


state 108

  100 expr: expr GREAT_EQ . expr

    L_PAREN          shift, and go to state 64
    NOT              shift, and go to state 65
    MINUS            shift, and go to state 66
    ID               shift, and go to state 19
    CONS_INTEGER     shift, and go to state 67
    CONS_FLOAT       shift, and go to state 68
    CONS_SCIENTIFIC  shift, and go to state 69
    CONS_STRING      shift, and go to state 70
    CONS_BOOL        shift, and go to state 71

    symbol_id         go to state 72
    literal_constant  go to state 73
    var_ref           go to state 74
    expr              go to state 163
    funct_invoc_ref   go to state 76


state 109

   99 expr: expr EQUAL . expr

    L_PAREN          shift, and go to state 64
    NOT              shift, and go to state 65
    MINUS            shift, and go to state 66
    ID               shift, and go to state 19
    CONS_INTEGER     shift, and go to state 67
    CONS_FLOAT       shift, and go to state 68
    CONS_SCIENTIFIC  shift, and go to state 69
    CONS_STRING      shift, and go to state 70
    CONS_BOOL        shift, and go to state 71

    symbol_id         go to state 72
    literal_constant  go to state 73
    var_ref           go to state 74
    expr              go to state 164
    funct_invoc_ref   go to state 76


state 110

   98 expr: expr LESS_EQ . expr

    L_PAREN          shift, and go to state 64
    NOT              shift, and go to state 65
    MINUS            shift, and go to state 66
    ID               shift, and go to state 19
    CONS_INTEGER     shift, and go to state 67
    CONS_FLOAT       shift, and go to state 68
    CONS_SCIENTIFIC  shift, and go to state 69
    CONS_STRING      shift, and go to state 70
    CONS_BOOL        shift, and go to state 71

    symbol_id         go to state 72
    literal_constant  go to state 73
    var_ref           go to state 74
    expr              go to state 165
    funct_invoc_ref   go to state 76


state 111

   97 expr: expr LESS . expr

    L_PAREN          shift, and go to state 64
    NOT              shift, and go to state 65
    MINUS            shift, and go to state 66
    ID               shift, and go to state 19
    CONS_INTEGER     shift, and go to state 67
    CONS_FLOAT       shift, and go to state 68
    CONS_SCIENTIFIC  shift, and go to state 69
    CONS_STRING      shift, and go to state 70
    CONS_BOOL        shift, and go to state 71

    symbol_id         go to state 72
    literal_constant  go to state 73
    var_ref           go to state 74
    expr              go to state 166
    funct_invoc_ref   go to state 76


state 112

  104 expr: expr MINUS . expr

    L_PAREN          shift, and go to state 64
    NOT              shift, and go to state 65
    MINUS            shift, and go to state 66
    ID               shift, and go to state 19
    CONS_INTEGER     shift, and go to state 67
    CONS_FLOAT       shift, and go to state 68
    CONS_SCIENTIFIC  shift, and go to state 69
    CONS_STRING      shift, and go to state 70
    CONS_BOOL        shift, and go to state 71

    symbol_id         go to state 72
    literal_constant  go to state 73
    var_ref           go to state 74
    expr              go to state 167
    funct_invoc_ref   go to state 76


state 113

  103 expr: expr PLUS . expr

    L_PAREN          shift, and go to state 64
    NOT              shift, and go to state 65
    MINUS            shift, and go to state 66
    ID               shift, and go to state 19
    CONS_INTEGER     shift, and go to state 67
    CONS_FLOAT       shift, and go to state 68
    CONS_SCIENTIFIC  shift, and go to state 69
    CONS_STRING      shift, and go to state 70
    CONS_BOOL        shift, and go to state 71

    symbol_id         go to state 72
    literal_constant  go to state 73
    var_ref           go to state 74
    expr              go to state 168
    funct_invoc_ref   go to state 76


state 114

  107 expr: expr MOD . expr

    L_PAREN          shift, and go to state 64
    NOT              shift, and go to state 65
    MINUS            shift, and go to state 66
    ID               shift, and go to state 19
    CONS_INTEGER     shift, and go to state 67
    CONS_FLOAT       shift, and go to state 68
    CONS_SCIENTIFIC  shift, and go to state 69
    CONS_STRING      shift, and go to state 70
    CONS_BOOL        shift, and go to state 71

    symbol_id         go to state 72
    literal_constant  go to state 73
    var_ref           go to state 74
    expr              go to state 169
    funct_invoc_ref   go to state 76


state 115

  106 expr: expr DIVIDE . expr

    L_PAREN          shift, and go to state 64
    NOT              shift, and go to state 65
    MINUS            shift, and go to state 66
    ID               shift, and go to state 19
    CONS_INTEGER     shift, and go to state 67
    CONS_FLOAT       shift, and go to state 68
    CONS_SCIENTIFIC  shift, and go to state 69
    CONS_STRING      shift, and go to state 70
    CONS_BOOL        shift, and go to state 71

    symbol_id         go to state 72
    literal_constant  go to state 73
    var_ref           go to state 74
    expr              go to state 170
    funct_invoc_ref   go to state 76


state 116

  105 expr: expr MULTIPLY . expr

    L_PAREN          shift, and go to state 64
    NOT              shift, and go to state 65
    MINUS            shift, and go to state 66
    ID               shift, and go to state 19
    CONS_INTEGER     shift, and go to state 67
    CONS_FLOAT       shift, and go to state 68
    CONS_SCIENTIFIC  shift, and go to state 69
    CONS_STRING      shift, and go to state 70
    CONS_BOOL        shift, and go to state 71

    symbol_id         go to state 72
    literal_constant  go to state 73
    var_ref           go to state 74
    expr              go to state 171
    funct_invoc_ref   go to state 76


state 117

   24 array_indice: array_indice L_BRACKET CONS_INTEGER . R_BRACKET

    R_BRACKET  shift, and go to state 172


state 118

   32 init_arr_list: L_BRACE . nonEmpty_init_arr_list
   33              | L_BRACE .

    L_PAREN          shift, and go to state 64
    NOT              shift, and go to state 65
    MINUS            shift, and go to state 66
    ID               shift, and go to state 19
    CONS_INTEGER     shift, and go to state 67
    CONS_FLOAT       shift, and go to state 68
    CONS_SCIENTIFIC  shift, and go to state 69
    CONS_STRING      shift, and go to state 70
    CONS_BOOL        shift, and go to state 71

    $default  reduce using rule 33 (init_arr_list)

    symbol_id               go to state 72
    nonEmpty_init_arr_list  go to state 173
    literal_constant        go to state 73
    var_ref                 go to state 74
    expr                    go to state 174
    funct_invoc_ref         go to state 76


state 119

   30 var_single: symbol_id array_indice ASSIGN init_array .

    $default  reduce using rule 30 (var_single)


state 120

   31 init_array: init_arr_list . R_BRACE

    R_BRACE  shift, and go to state 175


state 121

   45 funct_decl: type symbol_id arg_list R_PAREN SEMICOLON .

    $default  reduce using rule 45 (funct_decl)


state 122

   49 definition: type symbol_id arg_list R_PAREN compound_st .

    $default  reduce using rule 49 (definition)


state 123

   50 definition: VOID symbol_id arg_list R_PAREN . compound_st

    L_BRACE  shift, and go to state 87

    compound_st    go to state 89
    compound_list  go to state 90


state 124

   49 definition: type symbol_id arg_list R_PAREN . compound_st

    L_BRACE  shift, and go to state 87

    compound_st    go to state 122
    compound_list  go to state 90


state 125

   22 identifier: symbol_id array_indice .
   24 array_indice: array_indice . L_BRACKET CONS_INTEGER R_BRACKET

    L_BRACKET  shift, and go to state 77

    $default  reduce using rule 22 (identifier)


state 126

   53 nonEmpty_arg_list: arg COMMA nonEmpty_arg_list .

    $default  reduce using rule 53 (nonEmpty_arg_list)


state 127

   88 while_st: WHILE . L_PAREN bool_expr R_PAREN compound_st

    L_PAREN  shift, and go to state 176


state 128

   89 while_st: DO . compound_st WHILE L_PAREN bool_expr R_PAREN SEMICOLON

    L_BRACE  shift, and go to state 87

    compound_st    go to state 177
    compound_list  go to state 90


state 129

   85 condition_st: IF . L_PAREN bool_expr R_PAREN compound_st
   86             | IF . L_PAREN bool_expr R_PAREN compound_st ELSE compound_st

    L_PAREN  shift, and go to state 178


state 130

  112 for_st: FOR . for_init for_control for_incre R_PAREN compound_st

    L_PAREN  shift, and go to state 179

    for_init  go to state 180


state 131

   77 simple_st: PRINT . var_ref SEMICOLON
   78          | PRINT . expr SEMICOLON

    L_PAREN          shift, and go to state 64
    NOT              shift, and go to state 65
    MINUS            shift, and go to state 66
    ID               shift, and go to state 19
    CONS_INTEGER     shift, and go to state 67
    CONS_FLOAT       shift, and go to state 68
    CONS_SCIENTIFIC  shift, and go to state 69
    CONS_STRING      shift, and go to state 70
    CONS_BOOL        shift, and go to state 71

    symbol_id         go to state 72
    literal_constant  go to state 73
    var_ref           go to state 181
    expr              go to state 182
    funct_invoc_ref   go to state 76


state 132

   79 simple_st: READ . var_ref SEMICOLON

    ID  shift, and go to state 19

    symbol_id  go to state 183
    var_ref    go to state 184


state 133

   92 jump_st: CONTINUE . SEMICOLON

    SEMICOLON  shift, and go to state 185


state 134

   91 jump_st: BREAK . SEMICOLON

    SEMICOLON  shift, and go to state 186


state 135

   90 jump_st: RETURN . expr SEMICOLON

    L_PAREN          shift, and go to state 64
    NOT              shift, and go to state 65
    MINUS            shift, and go to state 66
    ID               shift, and go to state 19
    CONS_INTEGER     shift, and go to state 67
    CONS_FLOAT       shift, and go to state 68
    CONS_SCIENTIFIC  shift, and go to state 69
    CONS_STRING      shift, and go to state 70
    CONS_BOOL        shift, and go to state 71

    symbol_id         go to state 72
    literal_constant  go to state 73
    var_ref           go to state 74
    expr              go to state 187
    funct_invoc_ref   go to state 76


state 136

   65 var_const_decl_list: var_decl .

    $default  reduce using rule 65 (var_const_decl_list)


state 137

   14 var_decl: type . var_list SEMICOLON

    ID  shift, and go to state 19

    identifier  go to state 28
    symbol_id   go to state 80
    var_list    go to state 30
    var_single  go to state 31


state 138

   80 var_ref: symbol_id .
   81        | symbol_id . arr_ref_indice
  133 funct_invoc_st: symbol_id . funct_invoc_list R_PAREN SEMICOLON

    L_PAREN    shift, and go to state 99
    L_BRACKET  shift, and go to state 100

    $default  reduce using rule 80 (var_ref)

    arr_ref_indice    go to state 101
    arr_ref_index     go to state 102
    funct_invoc_list  go to state 188


state 139

   66 var_const_decl_list: const_decl .

    $default  reduce using rule 66 (var_const_decl_list)


state 140

   69 statement: compound_st .

    $default  reduce using rule 69 (statement)


state 141

   57 compound_list: L_BRACE nonEmpty_compound_list .

    $default  reduce using rule 57 (compound_list)


state 142

   59 nonEmpty_compound_list: var_const_decl_list . nonEmpty_compound_list
   61                       | var_const_decl_list .
   63 var_const_decl_list: var_const_decl_list . var_decl
   64                    | var_const_decl_list . const_decl

    CONST     shift, and go to state 2
    STRING    shift, and go to state 3
    DOUBLE    shift, and go to state 4
    FLOAT     shift, and go to state 5
    BOOL      shift, and go to state 6
    INT       shift, and go to state 7
    BOOLEAN   shift, and go to state 8
    L_BRACE   shift, and go to state 87
    WHILE     shift, and go to state 127
    DO        shift, and go to state 128
    IF        shift, and go to state 129
    FOR       shift, and go to state 130
    PRINT     shift, and go to state 131
    READ      shift, and go to state 132
    CONTINUE  shift, and go to state 133
    BREAK     shift, and go to state 134
    RETURN    shift, and go to state 135
    ID        shift, and go to state 19

    $default  reduce using rule 61 (nonEmpty_compound_list)

    var_decl                go to state 189
    type                    go to state 137
    symbol_id               go to state 138
    const_decl              go to state 190
    compound_st             go to state 140
    compound_list           go to state 90
    nonEmpty_compound_list  go to state 191
    var_const_decl_list     go to state 142
    stat_list               go to state 143
    statement               go to state 144
    simple_st               go to state 145
    var_ref                 go to state 146
    condition_st            go to state 147
    while_st                go to state 148
    jump_st                 go to state 149
    for_st                  go to state 150
    funct_invoc_st          go to state 151


state 143

   60 nonEmpty_compound_list: stat_list . nonEmpty_compound_list
   62                       | stat_list .
   67 stat_list: stat_list . statement

    CONST     shift, and go to state 2
    STRING    shift, and go to state 3
    DOUBLE    shift, and go to state 4
    FLOAT     shift, and go to state 5
    BOOL      shift, and go to state 6
    INT       shift, and go to state 7
    BOOLEAN   shift, and go to state 8
    L_BRACE   shift, and go to state 87
    WHILE     shift, and go to state 127
    DO        shift, and go to state 128
    IF        shift, and go to state 129
    FOR       shift, and go to state 130
    PRINT     shift, and go to state 131
    READ      shift, and go to state 132
    CONTINUE  shift, and go to state 133
    BREAK     shift, and go to state 134
    RETURN    shift, and go to state 135
    ID        shift, and go to state 19

    $default  reduce using rule 62 (nonEmpty_compound_list)

    var_decl                go to state 136
    type                    go to state 137
    symbol_id               go to state 138
    const_decl              go to state 139
    compound_st             go to state 140
    compound_list           go to state 90
    nonEmpty_compound_list  go to state 192
    var_const_decl_list     go to state 142
    stat_list               go to state 143
    statement               go to state 193
    simple_st               go to state 145
    var_ref                 go to state 146
    condition_st            go to state 147
    while_st                go to state 148
    jump_st                 go to state 149
    for_st                  go to state 150
    funct_invoc_st          go to state 151


state 144

   68 stat_list: statement .

    $default  reduce using rule 68 (stat_list)


state 145

   70 statement: simple_st .

    $default  reduce using rule 70 (statement)


state 146

   76 simple_st: var_ref . ASSIGN expr SEMICOLON

    ASSIGN  shift, and go to state 194


state 147

   71 statement: condition_st .

    $default  reduce using rule 71 (statement)


state 148

   72 statement: while_st .

    $default  reduce using rule 72 (statement)


state 149

   74 statement: jump_st .

    $default  reduce using rule 74 (statement)


state 150

   73 statement: for_st .

    $default  reduce using rule 73 (statement)


state 151

   75 statement: funct_invoc_st .

    $default  reduce using rule 75 (statement)


state 152

   56 compound_st: compound_list R_BRACE .

    $default  reduce using rule 56 (compound_st)


state 153

   93 expr: L_PAREN expr R_PAREN .

    $default  reduce using rule 93 (expr)


state 154

   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr
  137 nonEmpty_funct_invoc_list: expr .

    OR        shift, and go to state 104
    AND       shift, and go to state 105
    NOT_EQ    shift, and go to state 106
    GREAT     shift, and go to state 107
    GREAT_EQ  shift, and go to state 108
    EQUAL     shift, and go to state 109
    LESS_EQ   shift, and go to state 110
    LESS      shift, and go to state 111
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    $default  reduce using rule 137 (nonEmpty_funct_invoc_list)


state 155

  135 funct_invoc_list: L_PAREN nonEmpty_funct_invoc_list .
  136 nonEmpty_funct_invoc_list: nonEmpty_funct_invoc_list . COMMA expr

    COMMA  shift, and go to state 195

    $default  reduce using rule 135 (funct_invoc_list)


state 156

   84 arr_ref_index: L_BRACKET expr . R_BRACKET
   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    R_BRACKET  shift, and go to state 196
    OR         shift, and go to state 104
    AND        shift, and go to state 105
    NOT_EQ     shift, and go to state 106
    GREAT      shift, and go to state 107
    GREAT_EQ   shift, and go to state 108
    EQUAL      shift, and go to state 109
    LESS_EQ    shift, and go to state 110
    LESS       shift, and go to state 111
    MINUS      shift, and go to state 112
    PLUS       shift, and go to state 113
    MOD        shift, and go to state 114
    DIVIDE     shift, and go to state 115
    MULTIPLY   shift, and go to state 116


state 157

   82 arr_ref_indice: arr_ref_index arr_ref_indice .

    $default  reduce using rule 82 (arr_ref_indice)


state 158

  132 funct_invoc_ref: symbol_id funct_invoc_list R_PAREN .

    $default  reduce using rule 132 (funct_invoc_ref)


state 159

   94 expr: expr . OR expr
   94     | expr OR expr .
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    AND       shift, and go to state 105
    NOT_EQ    shift, and go to state 106
    GREAT     shift, and go to state 107
    GREAT_EQ  shift, and go to state 108
    EQUAL     shift, and go to state 109
    LESS_EQ   shift, and go to state 110
    LESS      shift, and go to state 111
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    $default  reduce using rule 94 (expr)


state 160

   94 expr: expr . OR expr
   95     | expr . AND expr
   95     | expr AND expr .
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    NOT_EQ    shift, and go to state 106
    GREAT     shift, and go to state 107
    GREAT_EQ  shift, and go to state 108
    EQUAL     shift, and go to state 109
    LESS_EQ   shift, and go to state 110
    LESS      shift, and go to state 111
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    $default  reduce using rule 95 (expr)


state 161

   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  102     | expr NOT_EQ expr .
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    $default  reduce using rule 102 (expr)


state 162

   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  101     | expr GREAT expr .
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    $default  reduce using rule 101 (expr)


state 163

   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  100     | expr GREAT_EQ expr .
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    $default  reduce using rule 100 (expr)


state 164

   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
   99     | expr EQUAL expr .
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    $default  reduce using rule 99 (expr)


state 165

   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   98     | expr LESS_EQ expr .
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    $default  reduce using rule 98 (expr)


state 166

   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   97     | expr LESS expr .
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    $default  reduce using rule 97 (expr)


state 167

   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  104     | expr MINUS expr .
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    $default  reduce using rule 104 (expr)


state 168

   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  103     | expr PLUS expr .
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    $default  reduce using rule 103 (expr)


state 169

   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr
  107     | expr MOD expr .

    $default  reduce using rule 107 (expr)


state 170

   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  106     | expr DIVIDE expr .
  107     | expr . MOD expr

    $default  reduce using rule 106 (expr)


state 171

   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  105     | expr MULTIPLY expr .
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    $default  reduce using rule 105 (expr)


state 172

   24 array_indice: array_indice L_BRACKET CONS_INTEGER R_BRACKET .

    $default  reduce using rule 24 (array_indice)


state 173

   32 init_arr_list: L_BRACE nonEmpty_init_arr_list .
   34 nonEmpty_init_arr_list: nonEmpty_init_arr_list . COMMA expr

    COMMA  shift, and go to state 197

    $default  reduce using rule 32 (init_arr_list)


state 174

   35 nonEmpty_init_arr_list: expr .
   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    OR        shift, and go to state 104
    AND       shift, and go to state 105
    NOT_EQ    shift, and go to state 106
    GREAT     shift, and go to state 107
    GREAT_EQ  shift, and go to state 108
    EQUAL     shift, and go to state 109
    LESS_EQ   shift, and go to state 110
    LESS      shift, and go to state 111
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    $default  reduce using rule 35 (nonEmpty_init_arr_list)


state 175

   31 init_array: init_arr_list R_BRACE .

    $default  reduce using rule 31 (init_array)


state 176

   88 while_st: WHILE L_PAREN . bool_expr R_PAREN compound_st

    L_PAREN          shift, and go to state 64
    NOT              shift, and go to state 65
    MINUS            shift, and go to state 66
    ID               shift, and go to state 19
    CONS_INTEGER     shift, and go to state 67
    CONS_FLOAT       shift, and go to state 68
    CONS_SCIENTIFIC  shift, and go to state 69
    CONS_STRING      shift, and go to state 70
    CONS_BOOL        shift, and go to state 71

    symbol_id         go to state 72
    literal_constant  go to state 73
    var_ref           go to state 74
    bool_expr         go to state 198
    expr              go to state 199
    funct_invoc_ref   go to state 76


state 177

   89 while_st: DO compound_st . WHILE L_PAREN bool_expr R_PAREN SEMICOLON

    WHILE  shift, and go to state 200


state 178

   85 condition_st: IF L_PAREN . bool_expr R_PAREN compound_st
   86             | IF L_PAREN . bool_expr R_PAREN compound_st ELSE compound_st

    L_PAREN          shift, and go to state 64
    NOT              shift, and go to state 65
    MINUS            shift, and go to state 66
    ID               shift, and go to state 19
    CONS_INTEGER     shift, and go to state 67
    CONS_FLOAT       shift, and go to state 68
    CONS_SCIENTIFIC  shift, and go to state 69
    CONS_STRING      shift, and go to state 70
    CONS_BOOL        shift, and go to state 71

    symbol_id         go to state 72
    literal_constant  go to state 73
    var_ref           go to state 74
    bool_expr         go to state 201
    expr              go to state 199
    funct_invoc_ref   go to state 76


state 179

  113 for_init: L_PAREN . nonEmpty_for_init
  114         | L_PAREN .

    L_PAREN          shift, and go to state 64
    NOT              shift, and go to state 65
    MINUS            shift, and go to state 66
    ID               shift, and go to state 19
    CONS_INTEGER     shift, and go to state 67
    CONS_FLOAT       shift, and go to state 68
    CONS_SCIENTIFIC  shift, and go to state 69
    CONS_STRING      shift, and go to state 70
    CONS_BOOL        shift, and go to state 71

    $default  reduce using rule 114 (for_init)

    symbol_id          go to state 202
    literal_constant   go to state 73
    var_ref            go to state 74
    expr               go to state 203
    nonEmpty_for_init  go to state 204
    for_single_entry   go to state 205
    funct_invoc_ref    go to state 76


state 180

  112 for_st: FOR for_init . for_control for_incre R_PAREN compound_st

    SEMICOLON  shift, and go to state 206

    for_control  go to state 207


state 181

   77 simple_st: PRINT var_ref . SEMICOLON
  110 expr: var_ref .

    SEMICOLON  shift, and go to state 208

    SEMICOLON  [reduce using rule 110 (expr)]
    $default   reduce using rule 110 (expr)


state 182

   78 simple_st: PRINT expr . SEMICOLON
   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    OR         shift, and go to state 104
    AND        shift, and go to state 105
    NOT_EQ     shift, and go to state 106
    GREAT      shift, and go to state 107
    GREAT_EQ   shift, and go to state 108
    EQUAL      shift, and go to state 109
    LESS_EQ    shift, and go to state 110
    LESS       shift, and go to state 111
    MINUS      shift, and go to state 112
    PLUS       shift, and go to state 113
    MOD        shift, and go to state 114
    DIVIDE     shift, and go to state 115
    MULTIPLY   shift, and go to state 116
    SEMICOLON  shift, and go to state 209


state 183

   80 var_ref: symbol_id .
   81        | symbol_id . arr_ref_indice

    L_BRACKET  shift, and go to state 100

    $default  reduce using rule 80 (var_ref)

    arr_ref_indice  go to state 101
    arr_ref_index   go to state 102


state 184

   79 simple_st: READ var_ref . SEMICOLON

    SEMICOLON  shift, and go to state 210


state 185

   92 jump_st: CONTINUE SEMICOLON .

    $default  reduce using rule 92 (jump_st)


state 186

   91 jump_st: BREAK SEMICOLON .

    $default  reduce using rule 91 (jump_st)


state 187

   90 jump_st: RETURN expr . SEMICOLON
   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    OR         shift, and go to state 104
    AND        shift, and go to state 105
    NOT_EQ     shift, and go to state 106
    GREAT      shift, and go to state 107
    GREAT_EQ   shift, and go to state 108
    EQUAL      shift, and go to state 109
    LESS_EQ    shift, and go to state 110
    LESS       shift, and go to state 111
    MINUS      shift, and go to state 112
    PLUS       shift, and go to state 113
    MOD        shift, and go to state 114
    DIVIDE     shift, and go to state 115
    MULTIPLY   shift, and go to state 116
    SEMICOLON  shift, and go to state 211


state 188

  133 funct_invoc_st: symbol_id funct_invoc_list . R_PAREN SEMICOLON

    R_PAREN  shift, and go to state 212


state 189

   63 var_const_decl_list: var_const_decl_list var_decl .
   65                    | var_decl .

    CONST     reduce using rule 63 (var_const_decl_list)
    CONST     [reduce using rule 65 (var_const_decl_list)]
    STRING    reduce using rule 63 (var_const_decl_list)
    STRING    [reduce using rule 65 (var_const_decl_list)]
    DOUBLE    reduce using rule 63 (var_const_decl_list)
    DOUBLE    [reduce using rule 65 (var_const_decl_list)]
    FLOAT     reduce using rule 63 (var_const_decl_list)
    FLOAT     [reduce using rule 65 (var_const_decl_list)]
    BOOL      reduce using rule 63 (var_const_decl_list)
    BOOL      [reduce using rule 65 (var_const_decl_list)]
    INT       reduce using rule 63 (var_const_decl_list)
    INT       [reduce using rule 65 (var_const_decl_list)]
    BOOLEAN   reduce using rule 63 (var_const_decl_list)
    BOOLEAN   [reduce using rule 65 (var_const_decl_list)]
    L_BRACE   reduce using rule 63 (var_const_decl_list)
    L_BRACE   [reduce using rule 65 (var_const_decl_list)]
    R_BRACE   reduce using rule 63 (var_const_decl_list)
    R_BRACE   [reduce using rule 65 (var_const_decl_list)]
    WHILE     reduce using rule 63 (var_const_decl_list)
    WHILE     [reduce using rule 65 (var_const_decl_list)]
    DO        reduce using rule 63 (var_const_decl_list)
    DO        [reduce using rule 65 (var_const_decl_list)]
    IF        reduce using rule 63 (var_const_decl_list)
    IF        [reduce using rule 65 (var_const_decl_list)]
    FOR       reduce using rule 63 (var_const_decl_list)
    FOR       [reduce using rule 65 (var_const_decl_list)]
    PRINT     reduce using rule 63 (var_const_decl_list)
    PRINT     [reduce using rule 65 (var_const_decl_list)]
    READ      reduce using rule 63 (var_const_decl_list)
    READ      [reduce using rule 65 (var_const_decl_list)]
    CONTINUE  reduce using rule 63 (var_const_decl_list)
    CONTINUE  [reduce using rule 65 (var_const_decl_list)]
    BREAK     reduce using rule 63 (var_const_decl_list)
    BREAK     [reduce using rule 65 (var_const_decl_list)]
    RETURN    reduce using rule 63 (var_const_decl_list)
    RETURN    [reduce using rule 65 (var_const_decl_list)]
    ID        reduce using rule 63 (var_const_decl_list)
    ID        [reduce using rule 65 (var_const_decl_list)]
    $default  reduce using rule 63 (var_const_decl_list)


state 190

   64 var_const_decl_list: var_const_decl_list const_decl .
   66                    | const_decl .

    CONST     reduce using rule 64 (var_const_decl_list)
    CONST     [reduce using rule 66 (var_const_decl_list)]
    STRING    reduce using rule 64 (var_const_decl_list)
    STRING    [reduce using rule 66 (var_const_decl_list)]
    DOUBLE    reduce using rule 64 (var_const_decl_list)
    DOUBLE    [reduce using rule 66 (var_const_decl_list)]
    FLOAT     reduce using rule 64 (var_const_decl_list)
    FLOAT     [reduce using rule 66 (var_const_decl_list)]
    BOOL      reduce using rule 64 (var_const_decl_list)
    BOOL      [reduce using rule 66 (var_const_decl_list)]
    INT       reduce using rule 64 (var_const_decl_list)
    INT       [reduce using rule 66 (var_const_decl_list)]
    BOOLEAN   reduce using rule 64 (var_const_decl_list)
    BOOLEAN   [reduce using rule 66 (var_const_decl_list)]
    L_BRACE   reduce using rule 64 (var_const_decl_list)
    L_BRACE   [reduce using rule 66 (var_const_decl_list)]
    R_BRACE   reduce using rule 64 (var_const_decl_list)
    R_BRACE   [reduce using rule 66 (var_const_decl_list)]
    WHILE     reduce using rule 64 (var_const_decl_list)
    WHILE     [reduce using rule 66 (var_const_decl_list)]
    DO        reduce using rule 64 (var_const_decl_list)
    DO        [reduce using rule 66 (var_const_decl_list)]
    IF        reduce using rule 64 (var_const_decl_list)
    IF        [reduce using rule 66 (var_const_decl_list)]
    FOR       reduce using rule 64 (var_const_decl_list)
    FOR       [reduce using rule 66 (var_const_decl_list)]
    PRINT     reduce using rule 64 (var_const_decl_list)
    PRINT     [reduce using rule 66 (var_const_decl_list)]
    READ      reduce using rule 64 (var_const_decl_list)
    READ      [reduce using rule 66 (var_const_decl_list)]
    CONTINUE  reduce using rule 64 (var_const_decl_list)
    CONTINUE  [reduce using rule 66 (var_const_decl_list)]
    BREAK     reduce using rule 64 (var_const_decl_list)
    BREAK     [reduce using rule 66 (var_const_decl_list)]
    RETURN    reduce using rule 64 (var_const_decl_list)
    RETURN    [reduce using rule 66 (var_const_decl_list)]
    ID        reduce using rule 64 (var_const_decl_list)
    ID        [reduce using rule 66 (var_const_decl_list)]
    $default  reduce using rule 64 (var_const_decl_list)


state 191

   59 nonEmpty_compound_list: var_const_decl_list nonEmpty_compound_list .

    $default  reduce using rule 59 (nonEmpty_compound_list)


state 192

   60 nonEmpty_compound_list: stat_list nonEmpty_compound_list .

    $default  reduce using rule 60 (nonEmpty_compound_list)


state 193

   67 stat_list: stat_list statement .
   68          | statement .

    CONST     reduce using rule 67 (stat_list)
    CONST     [reduce using rule 68 (stat_list)]
    STRING    reduce using rule 67 (stat_list)
    STRING    [reduce using rule 68 (stat_list)]
    DOUBLE    reduce using rule 67 (stat_list)
    DOUBLE    [reduce using rule 68 (stat_list)]
    FLOAT     reduce using rule 67 (stat_list)
    FLOAT     [reduce using rule 68 (stat_list)]
    BOOL      reduce using rule 67 (stat_list)
    BOOL      [reduce using rule 68 (stat_list)]
    INT       reduce using rule 67 (stat_list)
    INT       [reduce using rule 68 (stat_list)]
    BOOLEAN   reduce using rule 67 (stat_list)
    BOOLEAN   [reduce using rule 68 (stat_list)]
    L_BRACE   reduce using rule 67 (stat_list)
    L_BRACE   [reduce using rule 68 (stat_list)]
    R_BRACE   reduce using rule 67 (stat_list)
    R_BRACE   [reduce using rule 68 (stat_list)]
    WHILE     reduce using rule 67 (stat_list)
    WHILE     [reduce using rule 68 (stat_list)]
    DO        reduce using rule 67 (stat_list)
    DO        [reduce using rule 68 (stat_list)]
    IF        reduce using rule 67 (stat_list)
    IF        [reduce using rule 68 (stat_list)]
    FOR       reduce using rule 67 (stat_list)
    FOR       [reduce using rule 68 (stat_list)]
    PRINT     reduce using rule 67 (stat_list)
    PRINT     [reduce using rule 68 (stat_list)]
    READ      reduce using rule 67 (stat_list)
    READ      [reduce using rule 68 (stat_list)]
    CONTINUE  reduce using rule 67 (stat_list)
    CONTINUE  [reduce using rule 68 (stat_list)]
    BREAK     reduce using rule 67 (stat_list)
    BREAK     [reduce using rule 68 (stat_list)]
    RETURN    reduce using rule 67 (stat_list)
    RETURN    [reduce using rule 68 (stat_list)]
    ID        reduce using rule 67 (stat_list)
    ID        [reduce using rule 68 (stat_list)]
    $default  reduce using rule 67 (stat_list)


state 194

   76 simple_st: var_ref ASSIGN . expr SEMICOLON

    L_PAREN          shift, and go to state 64
    NOT              shift, and go to state 65
    MINUS            shift, and go to state 66
    ID               shift, and go to state 19
    CONS_INTEGER     shift, and go to state 67
    CONS_FLOAT       shift, and go to state 68
    CONS_SCIENTIFIC  shift, and go to state 69
    CONS_STRING      shift, and go to state 70
    CONS_BOOL        shift, and go to state 71

    symbol_id         go to state 72
    literal_constant  go to state 73
    var_ref           go to state 74
    expr              go to state 213
    funct_invoc_ref   go to state 76


state 195

  136 nonEmpty_funct_invoc_list: nonEmpty_funct_invoc_list COMMA . expr

    L_PAREN          shift, and go to state 64
    NOT              shift, and go to state 65
    MINUS            shift, and go to state 66
    ID               shift, and go to state 19
    CONS_INTEGER     shift, and go to state 67
    CONS_FLOAT       shift, and go to state 68
    CONS_SCIENTIFIC  shift, and go to state 69
    CONS_STRING      shift, and go to state 70
    CONS_BOOL        shift, and go to state 71

    symbol_id         go to state 72
    literal_constant  go to state 73
    var_ref           go to state 74
    expr              go to state 214
    funct_invoc_ref   go to state 76


state 196

   84 arr_ref_index: L_BRACKET expr R_BRACKET .

    $default  reduce using rule 84 (arr_ref_index)


state 197

   34 nonEmpty_init_arr_list: nonEmpty_init_arr_list COMMA . expr

    L_PAREN          shift, and go to state 64
    NOT              shift, and go to state 65
    MINUS            shift, and go to state 66
    ID               shift, and go to state 19
    CONS_INTEGER     shift, and go to state 67
    CONS_FLOAT       shift, and go to state 68
    CONS_SCIENTIFIC  shift, and go to state 69
    CONS_STRING      shift, and go to state 70
    CONS_BOOL        shift, and go to state 71

    symbol_id         go to state 72
    literal_constant  go to state 73
    var_ref           go to state 74
    expr              go to state 215
    funct_invoc_ref   go to state 76


state 198

   88 while_st: WHILE L_PAREN bool_expr . R_PAREN compound_st

    R_PAREN  shift, and go to state 216


state 199

   87 bool_expr: expr .
   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    OR        shift, and go to state 104
    AND       shift, and go to state 105
    NOT_EQ    shift, and go to state 106
    GREAT     shift, and go to state 107
    GREAT_EQ  shift, and go to state 108
    EQUAL     shift, and go to state 109
    LESS_EQ   shift, and go to state 110
    LESS      shift, and go to state 111
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    $default  reduce using rule 87 (bool_expr)


state 200

   89 while_st: DO compound_st WHILE . L_PAREN bool_expr R_PAREN SEMICOLON

    L_PAREN  shift, and go to state 217


state 201

   85 condition_st: IF L_PAREN bool_expr . R_PAREN compound_st
   86             | IF L_PAREN bool_expr . R_PAREN compound_st ELSE compound_st

    R_PAREN  shift, and go to state 218


state 202

   80 var_ref: symbol_id .
   81        | symbol_id . arr_ref_indice
  128 for_single_entry: symbol_id . ASSIGN expr
  129                 | symbol_id . array_indice ASSIGN init_array
  131                 | symbol_id . funct_invoc_list R_PAREN
  132 funct_invoc_ref: symbol_id . funct_invoc_list R_PAREN

    L_PAREN    shift, and go to state 99
    L_BRACKET  shift, and go to state 219
    ASSIGN     shift, and go to state 220

    $default  reduce using rule 80 (var_ref)

    array_indice      go to state 221
    arr_ref_indice    go to state 101
    arr_ref_index     go to state 102
    funct_invoc_list  go to state 222


state 203

   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr
  130 for_single_entry: expr .

    OR        shift, and go to state 104
    AND       shift, and go to state 105
    NOT_EQ    shift, and go to state 106
    GREAT     shift, and go to state 107
    GREAT_EQ  shift, and go to state 108
    EQUAL     shift, and go to state 109
    LESS_EQ   shift, and go to state 110
    LESS      shift, and go to state 111
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    $default  reduce using rule 130 (for_single_entry)


state 204

  113 for_init: L_PAREN nonEmpty_for_init .
  115 nonEmpty_for_init: nonEmpty_for_init . COMMA for_single_entry

    COMMA  shift, and go to state 223

    $default  reduce using rule 113 (for_init)


state 205

  116 nonEmpty_for_init: for_single_entry .

    $default  reduce using rule 116 (nonEmpty_for_init)


state 206

  121 for_control: SEMICOLON . nonEmpty_for_control
  122            | SEMICOLON .

    L_PAREN          shift, and go to state 64
    NOT              shift, and go to state 65
    MINUS            shift, and go to state 66
    ID               shift, and go to state 19
    CONS_INTEGER     shift, and go to state 67
    CONS_FLOAT       shift, and go to state 68
    CONS_SCIENTIFIC  shift, and go to state 69
    CONS_STRING      shift, and go to state 70
    CONS_BOOL        shift, and go to state 71

    $default  reduce using rule 122 (for_control)

    symbol_id             go to state 224
    literal_constant      go to state 73
    var_ref               go to state 74
    expr                  go to state 225
    nonEmpty_for_control  go to state 226
    for_control_entry     go to state 227
    funct_invoc_ref       go to state 76


state 207

  112 for_st: FOR for_init for_control . for_incre R_PAREN compound_st

    SEMICOLON  shift, and go to state 228

    for_incre  go to state 229


state 208

   77 simple_st: PRINT var_ref SEMICOLON .

    $default  reduce using rule 77 (simple_st)


state 209

   78 simple_st: PRINT expr SEMICOLON .

    $default  reduce using rule 78 (simple_st)


state 210

   79 simple_st: READ var_ref SEMICOLON .

    $default  reduce using rule 79 (simple_st)


state 211

   90 jump_st: RETURN expr SEMICOLON .

    $default  reduce using rule 90 (jump_st)


state 212

  133 funct_invoc_st: symbol_id funct_invoc_list R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 230


state 213

   76 simple_st: var_ref ASSIGN expr . SEMICOLON
   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    OR         shift, and go to state 104
    AND        shift, and go to state 105
    NOT_EQ     shift, and go to state 106
    GREAT      shift, and go to state 107
    GREAT_EQ   shift, and go to state 108
    EQUAL      shift, and go to state 109
    LESS_EQ    shift, and go to state 110
    LESS       shift, and go to state 111
    MINUS      shift, and go to state 112
    PLUS       shift, and go to state 113
    MOD        shift, and go to state 114
    DIVIDE     shift, and go to state 115
    MULTIPLY   shift, and go to state 116
    SEMICOLON  shift, and go to state 231


state 214

   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr
  136 nonEmpty_funct_invoc_list: nonEmpty_funct_invoc_list COMMA expr .

    OR        shift, and go to state 104
    AND       shift, and go to state 105
    NOT_EQ    shift, and go to state 106
    GREAT     shift, and go to state 107
    GREAT_EQ  shift, and go to state 108
    EQUAL     shift, and go to state 109
    LESS_EQ   shift, and go to state 110
    LESS      shift, and go to state 111
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    $default  reduce using rule 136 (nonEmpty_funct_invoc_list)


state 215

   34 nonEmpty_init_arr_list: nonEmpty_init_arr_list COMMA expr .
   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr

    OR        shift, and go to state 104
    AND       shift, and go to state 105
    NOT_EQ    shift, and go to state 106
    GREAT     shift, and go to state 107
    GREAT_EQ  shift, and go to state 108
    EQUAL     shift, and go to state 109
    LESS_EQ   shift, and go to state 110
    LESS      shift, and go to state 111
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    $default  reduce using rule 34 (nonEmpty_init_arr_list)


state 216

   88 while_st: WHILE L_PAREN bool_expr R_PAREN . compound_st

    L_BRACE  shift, and go to state 87

    compound_st    go to state 232
    compound_list  go to state 90


state 217

   89 while_st: DO compound_st WHILE L_PAREN . bool_expr R_PAREN SEMICOLON

    L_PAREN          shift, and go to state 64
    NOT              shift, and go to state 65
    MINUS            shift, and go to state 66
    ID               shift, and go to state 19
    CONS_INTEGER     shift, and go to state 67
    CONS_FLOAT       shift, and go to state 68
    CONS_SCIENTIFIC  shift, and go to state 69
    CONS_STRING      shift, and go to state 70
    CONS_BOOL        shift, and go to state 71

    symbol_id         go to state 72
    literal_constant  go to state 73
    var_ref           go to state 74
    bool_expr         go to state 233
    expr              go to state 199
    funct_invoc_ref   go to state 76


state 218

   85 condition_st: IF L_PAREN bool_expr R_PAREN . compound_st
   86             | IF L_PAREN bool_expr R_PAREN . compound_st ELSE compound_st

    L_BRACE  shift, and go to state 87

    compound_st    go to state 234
    compound_list  go to state 90


state 219

   25 array_indice: L_BRACKET . CONS_INTEGER R_BRACKET
   84 arr_ref_index: L_BRACKET . expr R_BRACKET

    L_PAREN          shift, and go to state 64
    NOT              shift, and go to state 65
    MINUS            shift, and go to state 66
    ID               shift, and go to state 19
    CONS_INTEGER     shift, and go to state 235
    CONS_FLOAT       shift, and go to state 68
    CONS_SCIENTIFIC  shift, and go to state 69
    CONS_STRING      shift, and go to state 70
    CONS_BOOL        shift, and go to state 71

    symbol_id         go to state 72
    literal_constant  go to state 73
    var_ref           go to state 74
    expr              go to state 156
    funct_invoc_ref   go to state 76


state 220

  128 for_single_entry: symbol_id ASSIGN . expr

    L_PAREN          shift, and go to state 64
    NOT              shift, and go to state 65
    MINUS            shift, and go to state 66
    ID               shift, and go to state 19
    CONS_INTEGER     shift, and go to state 67
    CONS_FLOAT       shift, and go to state 68
    CONS_SCIENTIFIC  shift, and go to state 69
    CONS_STRING      shift, and go to state 70
    CONS_BOOL        shift, and go to state 71

    symbol_id         go to state 72
    literal_constant  go to state 73
    var_ref           go to state 74
    expr              go to state 236
    funct_invoc_ref   go to state 76


state 221

   24 array_indice: array_indice . L_BRACKET CONS_INTEGER R_BRACKET
  129 for_single_entry: symbol_id array_indice . ASSIGN init_array

    L_BRACKET  shift, and go to state 77
    ASSIGN     shift, and go to state 237


state 222

  131 for_single_entry: symbol_id funct_invoc_list . R_PAREN
  132 funct_invoc_ref: symbol_id funct_invoc_list . R_PAREN

    R_PAREN  shift, and go to state 238


state 223

  115 nonEmpty_for_init: nonEmpty_for_init COMMA . for_single_entry

    L_PAREN          shift, and go to state 64
    NOT              shift, and go to state 65
    MINUS            shift, and go to state 66
    ID               shift, and go to state 19
    CONS_INTEGER     shift, and go to state 67
    CONS_FLOAT       shift, and go to state 68
    CONS_SCIENTIFIC  shift, and go to state 69
    CONS_STRING      shift, and go to state 70
    CONS_BOOL        shift, and go to state 71

    symbol_id         go to state 202
    literal_constant  go to state 73
    var_ref           go to state 74
    expr              go to state 203
    for_single_entry  go to state 239
    funct_invoc_ref   go to state 76


state 224

   80 var_ref: symbol_id .
   81        | symbol_id . arr_ref_indice
  126 for_control_entry: symbol_id . ASSIGN expr
  127                  | symbol_id . array_indice ASSIGN init_array
  132 funct_invoc_ref: symbol_id . funct_invoc_list R_PAREN

    L_PAREN    shift, and go to state 99
    L_BRACKET  shift, and go to state 219
    ASSIGN     shift, and go to state 240

    $default  reduce using rule 80 (var_ref)

    array_indice      go to state 241
    arr_ref_indice    go to state 101
    arr_ref_index     go to state 102
    funct_invoc_list  go to state 103


state 225

   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr
  125 for_control_entry: expr .

    OR        shift, and go to state 104
    AND       shift, and go to state 105
    NOT_EQ    shift, and go to state 106
    GREAT     shift, and go to state 107
    GREAT_EQ  shift, and go to state 108
    EQUAL     shift, and go to state 109
    LESS_EQ   shift, and go to state 110
    LESS      shift, and go to state 111
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    $default  reduce using rule 125 (for_control_entry)


state 226

  121 for_control: SEMICOLON nonEmpty_for_control .
  123 nonEmpty_for_control: nonEmpty_for_control . COMMA for_control_entry

    COMMA  shift, and go to state 242

    $default  reduce using rule 121 (for_control)


state 227

  124 nonEmpty_for_control: for_control_entry .

    $default  reduce using rule 124 (nonEmpty_for_control)


state 228

  117 for_incre: SEMICOLON . nonEmpty_for_incre
  118          | SEMICOLON .

    L_PAREN          shift, and go to state 64
    NOT              shift, and go to state 65
    MINUS            shift, and go to state 66
    ID               shift, and go to state 19
    CONS_INTEGER     shift, and go to state 67
    CONS_FLOAT       shift, and go to state 68
    CONS_SCIENTIFIC  shift, and go to state 69
    CONS_STRING      shift, and go to state 70
    CONS_BOOL        shift, and go to state 71

    $default  reduce using rule 118 (for_incre)

    symbol_id           go to state 202
    literal_constant    go to state 73
    var_ref             go to state 74
    expr                go to state 203
    nonEmpty_for_incre  go to state 243
    for_single_entry    go to state 244
    funct_invoc_ref     go to state 76


state 229

  112 for_st: FOR for_init for_control for_incre . R_PAREN compound_st

    R_PAREN  shift, and go to state 245


state 230

  133 funct_invoc_st: symbol_id funct_invoc_list R_PAREN SEMICOLON .

    $default  reduce using rule 133 (funct_invoc_st)


state 231

   76 simple_st: var_ref ASSIGN expr SEMICOLON .

    $default  reduce using rule 76 (simple_st)


state 232

   88 while_st: WHILE L_PAREN bool_expr R_PAREN compound_st .

    $default  reduce using rule 88 (while_st)


state 233

   89 while_st: DO compound_st WHILE L_PAREN bool_expr . R_PAREN SEMICOLON

    R_PAREN  shift, and go to state 246


state 234

   85 condition_st: IF L_PAREN bool_expr R_PAREN compound_st .
   86             | IF L_PAREN bool_expr R_PAREN compound_st . ELSE compound_st

    ELSE  shift, and go to state 247

    $default  reduce using rule 85 (condition_st)


state 235

   25 array_indice: L_BRACKET CONS_INTEGER . R_BRACKET
   40 literal_constant: CONS_INTEGER .

    R_BRACKET  shift, and go to state 95

    R_BRACKET  [reduce using rule 40 (literal_constant)]
    $default   reduce using rule 40 (literal_constant)


state 236

   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr
  128 for_single_entry: symbol_id ASSIGN expr .

    OR        shift, and go to state 104
    AND       shift, and go to state 105
    NOT_EQ    shift, and go to state 106
    GREAT     shift, and go to state 107
    GREAT_EQ  shift, and go to state 108
    EQUAL     shift, and go to state 109
    LESS_EQ   shift, and go to state 110
    LESS      shift, and go to state 111
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    $default  reduce using rule 128 (for_single_entry)


state 237

  129 for_single_entry: symbol_id array_indice ASSIGN . init_array

    L_BRACE  shift, and go to state 118

    init_array     go to state 248
    init_arr_list  go to state 120


state 238

  131 for_single_entry: symbol_id funct_invoc_list R_PAREN .
  132 funct_invoc_ref: symbol_id funct_invoc_list R_PAREN .

    R_PAREN    reduce using rule 131 (for_single_entry)
    R_PAREN    [reduce using rule 132 (funct_invoc_ref)]
    SEMICOLON  reduce using rule 131 (for_single_entry)
    SEMICOLON  [reduce using rule 132 (funct_invoc_ref)]
    COMMA      reduce using rule 131 (for_single_entry)
    COMMA      [reduce using rule 132 (funct_invoc_ref)]
    $default   reduce using rule 132 (funct_invoc_ref)


state 239

  115 nonEmpty_for_init: nonEmpty_for_init COMMA for_single_entry .

    $default  reduce using rule 115 (nonEmpty_for_init)


state 240

  126 for_control_entry: symbol_id ASSIGN . expr

    L_PAREN          shift, and go to state 64
    NOT              shift, and go to state 65
    MINUS            shift, and go to state 66
    ID               shift, and go to state 19
    CONS_INTEGER     shift, and go to state 67
    CONS_FLOAT       shift, and go to state 68
    CONS_SCIENTIFIC  shift, and go to state 69
    CONS_STRING      shift, and go to state 70
    CONS_BOOL        shift, and go to state 71

    symbol_id         go to state 72
    literal_constant  go to state 73
    var_ref           go to state 74
    expr              go to state 249
    funct_invoc_ref   go to state 76


state 241

   24 array_indice: array_indice . L_BRACKET CONS_INTEGER R_BRACKET
  127 for_control_entry: symbol_id array_indice . ASSIGN init_array

    L_BRACKET  shift, and go to state 77
    ASSIGN     shift, and go to state 250


state 242

  123 nonEmpty_for_control: nonEmpty_for_control COMMA . for_control_entry

    L_PAREN          shift, and go to state 64
    NOT              shift, and go to state 65
    MINUS            shift, and go to state 66
    ID               shift, and go to state 19
    CONS_INTEGER     shift, and go to state 67
    CONS_FLOAT       shift, and go to state 68
    CONS_SCIENTIFIC  shift, and go to state 69
    CONS_STRING      shift, and go to state 70
    CONS_BOOL        shift, and go to state 71

    symbol_id          go to state 224
    literal_constant   go to state 73
    var_ref            go to state 74
    expr               go to state 225
    for_control_entry  go to state 251
    funct_invoc_ref    go to state 76


state 243

  117 for_incre: SEMICOLON nonEmpty_for_incre .
  119 nonEmpty_for_incre: nonEmpty_for_incre . COMMA for_single_entry

    COMMA  shift, and go to state 252

    $default  reduce using rule 117 (for_incre)


state 244

  120 nonEmpty_for_incre: for_single_entry .

    $default  reduce using rule 120 (nonEmpty_for_incre)


state 245

  112 for_st: FOR for_init for_control for_incre R_PAREN . compound_st

    L_BRACE  shift, and go to state 87

    compound_st    go to state 253
    compound_list  go to state 90


state 246

   89 while_st: DO compound_st WHILE L_PAREN bool_expr R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 254


state 247

   86 condition_st: IF L_PAREN bool_expr R_PAREN compound_st ELSE . compound_st

    L_BRACE  shift, and go to state 87

    compound_st    go to state 255
    compound_list  go to state 90


state 248

  129 for_single_entry: symbol_id array_indice ASSIGN init_array .

    $default  reduce using rule 129 (for_single_entry)


state 249

   94 expr: expr . OR expr
   95     | expr . AND expr
   97     | expr . LESS expr
   98     | expr . LESS_EQ expr
   99     | expr . EQUAL expr
  100     | expr . GREAT_EQ expr
  101     | expr . GREAT expr
  102     | expr . NOT_EQ expr
  103     | expr . PLUS expr
  104     | expr . MINUS expr
  105     | expr . MULTIPLY expr
  106     | expr . DIVIDE expr
  107     | expr . MOD expr
  126 for_control_entry: symbol_id ASSIGN expr .

    OR        shift, and go to state 104
    AND       shift, and go to state 105
    NOT_EQ    shift, and go to state 106
    GREAT     shift, and go to state 107
    GREAT_EQ  shift, and go to state 108
    EQUAL     shift, and go to state 109
    LESS_EQ   shift, and go to state 110
    LESS      shift, and go to state 111
    MINUS     shift, and go to state 112
    PLUS      shift, and go to state 113
    MOD       shift, and go to state 114
    DIVIDE    shift, and go to state 115
    MULTIPLY  shift, and go to state 116

    $default  reduce using rule 126 (for_control_entry)


state 250

  127 for_control_entry: symbol_id array_indice ASSIGN . init_array

    L_BRACE  shift, and go to state 118

    init_array     go to state 256
    init_arr_list  go to state 120


state 251

  123 nonEmpty_for_control: nonEmpty_for_control COMMA for_control_entry .

    $default  reduce using rule 123 (nonEmpty_for_control)


state 252

  119 nonEmpty_for_incre: nonEmpty_for_incre COMMA . for_single_entry

    L_PAREN          shift, and go to state 64
    NOT              shift, and go to state 65
    MINUS            shift, and go to state 66
    ID               shift, and go to state 19
    CONS_INTEGER     shift, and go to state 67
    CONS_FLOAT       shift, and go to state 68
    CONS_SCIENTIFIC  shift, and go to state 69
    CONS_STRING      shift, and go to state 70
    CONS_BOOL        shift, and go to state 71

    symbol_id         go to state 202
    literal_constant  go to state 73
    var_ref           go to state 74
    expr              go to state 203
    for_single_entry  go to state 257
    funct_invoc_ref   go to state 76


state 253

  112 for_st: FOR for_init for_control for_incre R_PAREN compound_st .

    $default  reduce using rule 112 (for_st)


state 254

   89 while_st: DO compound_st WHILE L_PAREN bool_expr R_PAREN SEMICOLON .

    $default  reduce using rule 89 (while_st)


state 255

   86 condition_st: IF L_PAREN bool_expr R_PAREN compound_st ELSE compound_st .

    $default  reduce using rule 86 (condition_st)


state 256

  127 for_control_entry: symbol_id array_indice ASSIGN init_array .

    $default  reduce using rule 127 (for_control_entry)


state 257

  119 nonEmpty_for_incre: nonEmpty_for_incre COMMA for_single_entry .

    $default  reduce using rule 119 (nonEmpty_for_incre)
